/******************************************************************************

                  版权所有 (C), 1999-2013, 烽火通信科技股份有限公司

******************************************************************************
   文 件 名   : spm_vpws_proc.c
   版 本 号   : 初稿
   作    者   : xiaoxiang
   生成日期   : 2012年9月18日
   最近修改   :
   功能描述   : VPWS配置处理
   函数列表   :
   修改历史   :
   1.日    期   : 2012年9月18日
    作    者   : xiaoxiang
    修改内容   : 创建文件

******************************************************************************/

#define SHARED_DATA_TYPE SPM_SHARED_LOCAL

#include <nbase.h>
#include <spmincl.h>

#ifdef VPWS_CFG

extern unsigned char vpws_cfg_print_setting;

/*****************************************************************************
   函 数 名  : spm_rcv_dci_set_vpws
   功能描述  : VPWS配置处理
   输入参数  : ATG_DCI_SET_VPWS *pstSetVpws
   输出参数  : 无
   返 回 值  :
   调用函数  :
   被调函数  :

   修改历史      :
   1.日    期   : 2012年10月12日
    作    者   : xiaoxiang
    修改内容   : 新生成函数

*****************************************************************************/
NBB_VOID spm_rcv_dci_set_vpws(ATG_DCI_SET_VPWS *pstSetVpws NBB_CCXT_T NBB_CXT)
{
    NBB_CHAR ucMessage[SPM_MSG_INFO_LEN];
    NBB_BYTE ucMessageLen = 0;

    NBB_ULONG i = 0, j = 0;
    NBB_INT ret = SUCCESS;
    NBB_BYTE ucC3Unit = 0;
    NBB_INT iVpNum = 0;
	NBB_BYTE ucProtectFlag = 0;
	NBB_USHORT usFrrGroupId = 0;
	NBB_USHORT usNniVpNo = 0;

    NBB_INT iNniExistPos = 0;
    NBB_INT iUniExistPos = 0;
    NBB_UINT iVpUniPosId = 0;
    NBB_UINT iVpNniPosId = 0;

    NBB_USHORT usNniPosId[ATG_DCI_VPWS_NNI_NUM];
    NBB_USHORT usUniPosId[ATG_DCI_VPWS_UNI_NUM];

    SPM_VPWS_CB *pstVpws = NULL;

    ATG_DCI_VC_KEY stVcKeyMainOld;
    ATG_DCI_VC_KEY stVcKeyBackOld;
    ATG_DCI_VC_KEY stVcKeyMainNew;
    ATG_DCI_VC_KEY stVcKeyBackNew;
    ATG_DCI_VC_KEY stBypassVcKey;
    ATG_DCI_VC_KEY stTmpMainVcKey;
    ATG_DCI_VC_KEY stTmpBackVcKey;
    LSPPROT_KEY st_lspprot_key;  //LSPPROT  key值
    LSPPROT_KEY st_lspprot_key_back;  //LSPPROT  key值
    LSPPROT_KEY st_lspprot_key_bypass;  //LSPPROT  key值
    
    SPM_VC_INFO_CB stVcDrvInfoMainOld;
    SPM_VC_INFO_CB stVcDrvInfoBackOld;
    SPM_VC_INFO_CB stVcDrvInfoBypassOld;
    SPM_LOGICAL_PORT_INFO_CB stLogicalPortDrvInfo;
    SPM_LOGICAL_PORT_CB *pstLogcialPort = NULL;
    SPM_LOGICAL_PORT_CB *pstLogcialPortBack = NULL;

    SPM_VPN_PORT_INFO_CB stVpwsPortInfo;

    /* 用来保存从IPS中获取的子配置 */
    ATG_DCI_VPWS_BASIC_DATA *pstBasicData = NULL;
    ATG_DCI_VPWS_NNI_DATA *pstNniData[ATG_DCI_VPWS_NNI_NUM];
    ATG_DCI_VPWS_UNI_DATA *pstUniData[ATG_DCI_VPWS_UNI_NUM];
    ATG_DCI_VPWS_BYPASS_PW_DATA *pstBypassData = NULL;

    /* IPS消息偏移的首地址 */
    NBB_BYTE *pucBasicDataStart = NULL;
    NBB_BYTE *pucNniDataStart = NULL;
    NBB_BYTE *pucUniDataStart = NULL;
    NBB_BYTE *pucBypassDataStart = NULL;

    /* 子配置的操作模式 */
    NBB_ULONG ulOperBasic = ATG_DCI_OPER_NULL;
    NBB_ULONG ulOperNni = ATG_DCI_OPER_NULL;
    NBB_ULONG ulOperUni = ATG_DCI_OPER_NULL;
    NBB_ULONG ulOperBypass = ATG_DCI_OPER_NULL;

    /* VPWS的键值 */
    NBB_USHORT usVpwsIdKey = 0;
    NBB_USHORT usVsiMcId = 0;

    NBB_BYTE ucIfExist = ATG_DCI_EXIST;

    /* UNI对应的逻辑端口索引*/
    NBB_ULONG ulPortIndex = 0;
    NBB_ULONG ulPortIndexBack = 0;

    NBB_TRC_ENTRY("spm_rcv_dci_set_vpws");

    /* 输入参数指针必须有效 */
    NBB_ASSERT(pstSetVpws != NULL);

	if (pstSetVpws == NULL)
	{
        NBB_TRC_FLOW((NBB_FORMAT "  ***ERROR***:spm_rcv_dci_set_vpws(pstSetVpws==NULL)"));

        OS_PRINTF("***ERROR***:spm_rcv_dci_set_vpws(pstSetVpws==NULL)\n");

        OS_SPRINTF(ucMessage, "***ERROR***:spm_rcv_dci_set_vpws(pstSetVpws==NULL)\n");
        BMU_SLOG(BMU_INFO, SPM_L2_LOG_DIR, ucMessage);

        NBB_EXCEPTION((PCT_SPM | VPWS_PD, 0, "ld d s s", 0,
                FUNC_IN_PARAM_IS_NULL,
                "FUNC_IN_PARAM_IS_NULL",
                ucMessage));
                
        goto EXIT_LABEL;
    }

    //首先将IPS消息的返回值设置为OK，如果有一个子配置失败，则置为FAIL
    pstSetVpws->return_code = ATG_DCI_RC_OK;

    /* 初始化UNI、NNI指针数组 */
    for (i = 0; i < 2; i++)
    {
        pstNniData[i] = NULL;
        pstUniData[i] = NULL;
        usNniPosId[i] = 0;
        usUniPosId[i] = 0;
    }

    OS_MEMSET(&stVcKeyMainOld, 0, sizeof(ATG_DCI_VC_KEY));
    OS_MEMSET(&stVcKeyBackOld, 0, sizeof(ATG_DCI_VC_KEY));
    OS_MEMSET(&stVcKeyMainNew, 0, sizeof(ATG_DCI_VC_KEY));
    OS_MEMSET(&stVcKeyBackNew, 0, sizeof(ATG_DCI_VC_KEY));
    OS_MEMSET(&stBypassVcKey, 0, sizeof(ATG_DCI_VC_KEY));
    OS_MEMSET(&stTmpMainVcKey, 0, sizeof(ATG_DCI_VC_KEY));
    OS_MEMSET(&stTmpBackVcKey, 0, sizeof(ATG_DCI_VC_KEY));
    OS_MEMSET(&st_lspprot_key, 0, sizeof(LSPPROT_KEY));
    OS_MEMSET(&st_lspprot_key_back, 0, sizeof(LSPPROT_KEY));
    OS_MEMSET(&st_lspprot_key_bypass, 0, sizeof(LSPPROT_KEY));
    OS_MEMSET(&stVpwsPortInfo, 0, sizeof(SPM_VPN_PORT_INFO_CB));
    OS_MEMSET(&stVcDrvInfoMainOld, 0, sizeof(SPM_VC_INFO_CB));
    OS_MEMSET(&stVcDrvInfoBackOld, 0, sizeof(SPM_VC_INFO_CB));
    OS_MEMSET(&stVcDrvInfoBypassOld, 0, sizeof(SPM_VC_INFO_CB));
    OS_MEMSET(&stLogicalPortDrvInfo, 0, sizeof(SPM_LOGICAL_PORT_INFO_CB));

    usVpwsIdKey = pstSetVpws->key;
    pstVpws = AVLL_FIND(SHARED.vpws_tree, &usVpwsIdKey);

    if (pstVpws == NULL)    //条目不存在
    {
        ucIfExist = ATG_DCI_UNEXIST;
    }

    /* 获取子配置的操作类型 */
    ulOperBasic = pstSetVpws->oper_basic;
    ulOperNni = pstSetVpws->oper_nni;
    ulOperUni = pstSetVpws->oper_uni;
    ulOperBypass = pstSetVpws->oper_bypass_pw;

    /* 删除整个条目 */
    if (pstSetVpws->delete_struct == TRUE)
    {
        NBB_TRC_DETAIL((NBB_FORMAT "  删除VPWS_ID=%ld的 VPWS配置", usVpwsIdKey));

        /* 如果条目不存在，不删除 */
        if (ucIfExist == ATG_DCI_UNEXIST)
        {
            /* 待修改：加打印PD */
            NBB_TRC_FLOW((NBB_FORMAT "  ***ERROR***:要删除的配置并不存在，退出!"));

            OS_PRINTF("***ERROR***:要删除的配置并不存在，退出!\n");

            OS_SPRINTF(ucMessage, "***ERROR***:要删除的配置并不存在，退出!\n");
            BMU_SLOG(BMU_INFO, SPM_L2_LOG_DIR, ucMessage);

            NBB_EXCEPTION((PCT_SPM | VPWS_PD, 0, "ld d s s", usVpwsIdKey,
                    DEL_UNEXIST_CONFIG_ERROR,
                    "DEL_UNEXIST_CONFIG_ERROR",
                    ucMessage));
                    
            goto EXIT_LABEL;
        }

        /* 存在，删除 */
        else
        {
            NBB_TRC_FLOW((NBB_FORMAT "  查询到此配置，删除此VPWS，并从tree中删除存储数据"));
            spm_dbg_print_vpws_head(usVpwsIdKey, SPM_OPER_DEL);
            spm_dbg_record_vpws_head(usVpwsIdKey, SPM_OPER_DEL);

#ifdef SPU
            ret = SUCCESS;

            /* 删除VPWS */
            for (ucC3Unit = 0; ucC3Unit < SHARED.c3_num; ucC3Unit++)
            {
                ret += ApiC3DelMplsVpn(ucC3Unit, L2VPN_VPWS, usVpwsIdKey);
            }

            if (pstVpws == NULL)
            {
            	goto EXIT_LABEL;
            }

            //删除成功要删除VPWS下挂VC，逻辑接口，流的驱动返回信息
            if (ret == SUCCESS)
            {
            	//NNI
                for (i = 0; i < ATG_DCI_VPWS_NNI_NUM; i++)
                {
                    if (pstVpws->nni_cfg_cb[i] != NULL)
                    {
                        stVcKeyMainOld.vc_id = pstVpws->nni_cfg_cb[i]->vc_id;
                        stVcKeyMainOld.vc_type = pstVpws->nni_cfg_cb[i]->vc_type;
                        stVcKeyMainOld.peer_ip = pstVpws->nni_cfg_cb[i]->peer_ip;

                        stVcKeyBackOld.vc_id = pstVpws->nni_cfg_cb[i]->vc_id_bak;
                        stVcKeyBackOld.vc_type = pstVpws->nni_cfg_cb[i]->vc_type_bak;
                        stVcKeyBackOld.peer_ip = pstVpws->nni_cfg_cb[i]->peer_ip_bak;
    		    				
						spm_get_vc_drvinfo(stVcKeyMainOld,&stVcDrvInfoMainOld NBB_CCXT);
						spm_get_vc_drvinfo(stVcKeyBackOld,&stVcDrvInfoBackOld NBB_CCXT);
						spm_get_vc_lspprotkey(stVcKeyMainOld,&st_lspprot_key NBB_CCXT);
						spm_get_vc_lspprotkey(stVcKeyBackOld,&st_lspprot_key_back NBB_CCXT);
                        
						if (stVcDrvInfoMainOld.frr_group_id != 0)
						{
							usFrrGroupId = stVcDrvInfoMainOld.frr_group_id;
						}
						else if (stVcDrvInfoBackOld.frr_group_id != 0)
						{
							usFrrGroupId = stVcDrvInfoBackOld.frr_group_id;
						}
						
						ucProtectFlag = pstVpws->nni_cfg_cb[i]->use_protect;

						ret = SUCCESS;

						if((usFrrGroupId != 0) && (ucProtectFlag == 1))
						{
							for(ucC3Unit = 0; ucC3Unit < SHARED.c3_num; ucC3Unit++)
							{
								ret += ApiC3DeleteFrrGroup(ucC3Unit, usFrrGroupId);
							}

							if(ret != SUCCESS)
							{
								NBB_TRC_DETAIL((NBB_FORMAT "***ERROR***: ApiC3DeleteFrrGroup() error! ret=%d", ret));

				                OS_SPRINTF(ucMessage, "***ERROR***: ApiC3DeleteFrrGroup() ret=%d VPWS_ID=%d\n", ret, usVpwsIdKey);
				                BMU_SLOG(BMU_INFO, SPM_L2_LOG_DIR, ucMessage);
                
                				NBB_EXCEPTION((PCT_SPM | VPWS_PD, 0, "ld d s s", usVpwsIdKey,
                        		ret,
                        		"CALL_C3_FUNC_ERROR",
                        		"ApiC3DeleteFrrGroup()"));
							}

						 //调用dk的接口获取ftnIndex
                                            if (ATG_DCI_FTN == stVcDrvInfoBackOld.lsp_option)
                                            {
                                            	spm_l3_delvpldp(stVcKeyBackOld.peer_ip, 
                                            					stVcDrvInfoBackOld.vp_idx, 
                                            					stVcDrvInfoBackOld.next_hop_id
                                            					NBB_CCXT);		            
                                            }
                                            else if (ATG_DCI_CR_LSP == stVcDrvInfoBackOld.lsp_option)
                                            {
                                            	spm_l3_delvprsvp(&st_lspprot_key_back, 
                                            					stVcDrvInfoBackOld.vp_idx, 
                                            					stVcDrvInfoBackOld.next_hop_id
                                            					NBB_CCXT);	
                                            }		
						}
						
					 //调用dk的接口获取ftnIndex
                                        if (ATG_DCI_FTN == stVcDrvInfoMainOld.lsp_option)
                                        {
                                        	spm_l3_delvpldp(stVcKeyMainOld.peer_ip, 
                                        					stVcDrvInfoMainOld.vp_idx, 
                                        					stVcDrvInfoMainOld.next_hop_id
                                        					NBB_CCXT);		            
                                        }
                                        else if (ATG_DCI_CR_LSP == stVcDrvInfoMainOld.lsp_option)
                                        {
                                        	spm_l3_delvprsvp(&st_lspprot_key, 
                                        					stVcDrvInfoMainOld.vp_idx, 
                                        					stVcDrvInfoMainOld.next_hop_id
                                        					NBB_CCXT);	
                                        }	

						spm_lps_del_entity(FRR_TYPE, usFrrGroupId);
						
						//回收next_hop_id
		    		    //if (stVcDrvInfoMainOld.next_hop_id != 0)
		    		    if (0 != pstVpws->nni_info_cb[i].next_hop_id)
		    		    {
		    		    	spm_free_vc_nhi_id(pstVpws->nni_info_cb[i].next_hop_id NBB_CCXT);
		    		    }

		    		    //if (stVcDrvInfoBackOld.next_hop_id != 0)
                                if (0 != pstVpws->nni_info_cb[i].next_hop_id_p)
		    		    {
		    		    	spm_free_vc_nhi_id(pstVpws->nni_info_cb[i].next_hop_id_p NBB_CCXT);
		    		    }
		    		    				
                        spm_vc_drvinfo_clear(&stVcKeyMainOld NBB_CCXT);
                        spm_vc_drvinfo_clear(&stVcKeyBackOld NBB_CCXT);
                    }
                }

				//UNI
                for (i = 0; i < ATG_DCI_VPWS_UNI_NUM; i++)
                {
                    if (pstVpws->uni_cfg_cb[i] != NULL)
                    {
                        ulPortIndex = pstVpws->uni_cfg_cb[i]->port_index;
                        pstLogcialPort = AVLL_FIND(SHARED.logical_port_tree, &ulPortIndex);
                   
                        if (NULL != pstLogcialPort)
                        {
                            //回收next_hop_id资源
                            if (pstLogcialPort->logic_port_info_cb.next_hop_id != 0)
                            {
                                spm_free_vc_nhi_id(pstLogcialPort->logic_port_info_cb.next_hop_id NBB_CCXT);
                                spm_free_vc_nhi_id(pstLogcialPort->logic_port_info_cb.p_next_hop_id NBB_CCXT);
                            }

                            //清空逻辑接口配置中的驱动返回值
                            spm_logical_port_drvinfo_clear(ulPortIndex NBB_CCXT);
                        } 
                        
                        ulPortIndexBack = pstVpws->uni_cfg_cb[i]->slave_port_index;
                        pstLogcialPortBack = AVLL_FIND(SHARED.logical_port_tree, &ulPortIndexBack);

                        if (pstLogcialPortBack != NULL)
                        {
                            //回收next_hop_id资源
                            if (pstLogcialPortBack->logic_port_info_cb.next_hop_id != 0)
                            {
                                spm_free_vc_nhi_id(pstLogcialPortBack->logic_port_info_cb.next_hop_id NBB_CCXT);
                                spm_free_vc_nhi_id(pstLogcialPortBack->logic_port_info_cb.p_next_hop_id NBB_CCXT);
                            }

                            //清空逻辑接口配置中的驱动返回值
                            spm_logical_port_drvinfo_clear(ulPortIndexBack NBB_CCXT);
                        }
                    }
                }

				//BYPASS
				if (pstVpws->bypass_cfg_cb != NULL)
				{
					stBypassVcKey.vc_id = pstVpws->bypass_cfg_cb->vc_id;
					stBypassVcKey.vc_type = pstVpws->bypass_cfg_cb->vc_type;
					stBypassVcKey.peer_ip = pstVpws->bypass_cfg_cb->peer_ip;

					spm_get_vc_drvinfo(stBypassVcKey,&stVcDrvInfoBypassOld NBB_CCXT);
                                   spm_get_vc_lspprotkey(stBypassVcKey,&st_lspprot_key_bypass NBB_CCXT);
                    
				         //调用dk的接口获取ftnIndex
                                    if (ATG_DCI_FTN == stVcDrvInfoBypassOld.lsp_option)
                                    {
                                    	spm_l3_delvpldp(stBypassVcKey.peer_ip, 
                                    					stVcDrvInfoBypassOld.vp_idx, 
                                    					stVcDrvInfoBypassOld.next_hop_id
                                    					NBB_CCXT);		            
                                    }
                                    else if (ATG_DCI_CR_LSP == stVcDrvInfoBypassOld.lsp_option)
                                    {
                                    	spm_l3_delvprsvp(&st_lspprot_key_bypass, 
                                    					stVcDrvInfoBypassOld.vp_idx, 
                                    					stVcDrvInfoBypassOld.next_hop_id
                                    					NBB_CCXT);	
                                    }	
                                        
					//回收next_hop_id
	    		    if (stVcDrvInfoBypassOld.next_hop_id != 0)
	    		    {
	    		    	spm_free_vc_nhi_id(stVcDrvInfoBypassOld.next_hop_id NBB_CCXT);
	    		    }
		    		    
					spm_vc_drvinfo_clear(&stBypassVcKey NBB_CCXT);
				}
            }
            else
            {
                NBB_TRC_DETAIL((NBB_FORMAT "  ***ERROR***:删除VPWS(ID=%d)失败! >>> ApiC3DelMplsVpn() ret=%d",
                        usVpwsIdKey, ret));

                OS_PRINTF("***ERROR***:删除VPWS(ID=%d)失败! >>> ApiC3DelMplsVpn() ret=%d\n", usVpwsIdKey, ret);

                OS_SPRINTF(ucMessage,
                    "***ERROR***:删除VPWS(ID=%d)失败! >>> ApiC3DelMplsVpn() ret=%d\n",
                    usVpwsIdKey,
                    ret);
                BMU_SLOG(BMU_INFO, SPM_L2_LOG_DIR, ucMessage);

                NBB_EXCEPTION((PCT_SPM | VPWS_PD, 0, "ld d s s", usVpwsIdKey,
                        ret,
                        "CALL_C3_FUNC_ERROR",
                        ucMessage));
                        
                pstSetVpws->return_code = ATG_DCI_RC_UNSUCCESSFUL;

                goto EXIT_LABEL;
            }
#endif
			if (pstVpws != NULL)
			{
	            //从树中删除节点
	            AVLL_DELETE(SHARED.vpws_tree, pstVpws->spm_vpws_node);

	            //释放节点内存空间
	            spm_free_vpws_cb(pstVpws NBB_CCXT);
			}

        }
    }

    /* 增加或更新条目 ，注意约定VPWS以条目全量的形式下发*/
    else
    {

        /* 如果条目不存在，新申请内存空间保存数据 */
        if (ucIfExist == ATG_DCI_UNEXIST)
        {
            NBB_TRC_DETAIL((NBB_FORMAT "  增加VPWS_ID=%ld 的VPWS配置", usVpwsIdKey));
            spm_dbg_print_vpws_head(usVpwsIdKey, SPM_OPER_ADD);
            spm_dbg_record_vpws_head(usVpwsIdKey, SPM_OPER_ADD);

            /* 申请一个新条目的内存空间 */
            pstVpws = spm_alloc_vpws_cb(NBB_CXT);

			if (pstVpws != NULL)
			{
	            //将更新节点插入到tree中
	            pstVpws->vpws_id_key = usVpwsIdKey;

	            //coverity[no_effect_test]
	            AVLL_INSERT(SHARED.vpws_tree, pstVpws->spm_vpws_node);
			}

#ifdef SPU
            ret = SUCCESS;

            /* 创建VPWS */
            for (ucC3Unit = 0; ucC3Unit < SHARED.c3_num; ucC3Unit++)
            {
                ret += ApiC3CreateMplsVpn(ucC3Unit, L2VPN_VPWS, usVpwsIdKey);
            }

            if (ret != SUCCESS)
            {
                NBB_TRC_DETAIL((NBB_FORMAT "  ***ERROR***:创建VPWS(ID=%d)失败! >>> ApiC3CreateMplsVpn() ret=%d",
                        usVpwsIdKey, ret));

                OS_PRINTF("***ERROR***:创建VPWS(ID=%d)失败! >>> ApiC3CreateMplsVpn() ret=%d\n", usVpwsIdKey, ret);

                OS_SPRINTF(ucMessage,
                    "***ERROR***:创建VPWS(ID=%d)失败! >>> ApiC3CreateMplsVpn() ret=%d\n",
                    usVpwsIdKey,
                    ret);
                BMU_SLOG(BMU_INFO, SPM_L2_LOG_DIR, ucMessage);

                NBB_EXCEPTION((PCT_SPM | VPWS_PD, 0, "ld d s s", usVpwsIdKey,
                        ret,
                        "CALL_C3_FUNC_ERROR",
                        ucMessage));
                        
                pstSetVpws->return_code = ATG_DCI_RC_UNSUCCESSFUL;
                pstSetVpws->basic_return_code = ATG_DCI_RC_UNSUCCESSFUL;
                pstSetVpws->bypass_pw_return_code = ATG_DCI_RC_UNSUCCESSFUL;
                
                for (i=0; i<ATG_DCI_VPWS_NNI_NUM; i++)
                {
                    pstSetVpws->nni_return_code[i] = ATG_DCI_RC_UNSUCCESSFUL;
                }

                for (i=0; i<ATG_DCI_VPWS_UNI_NUM; i++)
                {
                    pstSetVpws->uni_return_code[i] = ATG_DCI_RC_UNSUCCESSFUL;
                }

                goto EXIT_LABEL;
            }
#endif
        }
        else
        {
            NBB_TRC_DETAIL((NBB_FORMAT "  更新VPWS_ID=%ld的 VPWS配置", usVpwsIdKey));
            spm_dbg_print_vpws_head(usVpwsIdKey, SPM_OPER_UPD);
            spm_dbg_record_vpws_head(usVpwsIdKey, SPM_OPER_UPD);
        }

		//增加此判断，取消PC-Lint告警
        if (pstVpws == NULL)
        {
            NBB_TRC_FLOW((NBB_FORMAT "  ***ERROR***:要增加 VPWS_ID=%d 的VPWS配置未能成功申请内存!", usVpwsIdKey));

            OS_PRINTF("***ERROR***:要增加 VPWS_ID=%d 的VPWS配置未能成功申请内存!\n", usVpwsIdKey);

            OS_SPRINTF(ucMessage, "***ERROR***:要增加 VPWS_ID=%d 的VPWS配置未能成功申请内存!\n", usVpwsIdKey);
            BMU_SLOG(BMU_INFO, SPM_L2_LOG_DIR, ucMessage);

            NBB_EXCEPTION((PCT_SPM | VPLS_PD, 0, "ld d s s", usVpwsIdKey, 
                                                             ALLOC_MEMORY_ERROR, 
                                                             "ALLOC_MEMORY_ERROR", 
                                                             ucMessage));
            pstSetVpws->return_code = ATG_DCI_RC_UNSUCCESSFUL;
            
            goto EXIT_LABEL;
        }

        /***************************************************************************/
        /*                              获取配置                                   */
        /***************************************************************************/
        /******************************** 基本配置 *********************************/
        if (ulOperBasic == ATG_DCI_OPER_ADD)
        {

            /* 计算第一个entry的地址。*/
            pucBasicDataStart = (NBB_BYTE *)NTL_OFFLEN_GET_POINTER(pstSetVpws, &pstSetVpws->basic_data);

            /* 如果指针为NULL，无数据 */
            if (pucBasicDataStart == NULL)
            {
                NBB_TRC_FLOW((NBB_FORMAT "  pucBasicDataStart is NULL."));
                NBB_EXCEPTION((PCT_SPM | 7, 1, "lx", SHARED.spm_index));
            }
            else
            {
                pstBasicData = (ATG_DCI_VPWS_BASIC_DATA *)pucBasicDataStart;

                /* 配置处理，todo */
                NBB_TRC_DETAIL((NBB_FORMAT "  L2VC ID = %d", pstBasicData->l2vc_id));
                
                if (vpws_cfg_print_setting == SPM_PRINT_CFG)
                {
                    printf("  1）基本配置\n");
                    spm_dbg_print_vpws_basic_cfg(pstBasicData);
                }

                OS_SPRINTF(ucMessage,"  1）基本配置\n");
                BMU_SLOG(BMU_INFO, SPM_L2_LOG_DIR, ucMessage);
                
                //spm_dbg_record_vpws_basic_cfg(pstBasicData);
                
                if (pstVpws->basic_cfg_cb == NULL)
                {
                    pstVpws->basic_cfg_cb = (ATG_DCI_VPWS_BASIC_DATA *)NBB_MM_ALLOC(sizeof(ATG_DCI_VPWS_BASIC_DATA),
                        NBB_NORETRY_ACT,
                        MEM_SPM_VPWS_BASIC_CB);
                }

                //保存数据
                OS_MEMCPY(pstVpws->basic_cfg_cb, pstBasicData, sizeof(ATG_DCI_VPWS_BASIC_DATA));

            }
        }
        else if (ulOperBasic == ATG_DCI_OPER_DEL)
        {
            NBB_EXCEPTION((PCT_SPM | 7, 1, "lx", SHARED.spm_index));
        }
        else if (ulOperBasic == ATG_DCI_OPER_UPDATE)
        {
            NBB_EXCEPTION((PCT_SPM | 7, 2, "lx", SHARED.spm_index));
        }

        /******************************** NNI配置 *********************************/
        if (ulOperNni == ATG_DCI_OPER_ADD)
        {

            /* 计算第一个entry的地址。*/
            pucNniDataStart = (NBB_BYTE *)NTL_OFFLEN_GET_POINTER(pstSetVpws, &pstSetVpws->nni_data);

            /* 如果指针为NULL，无数据 */
            if (pucNniDataStart == NULL)
            {
                NBB_TRC_FLOW((NBB_FORMAT "  pucNniDataStart is NULL."));
                NBB_EXCEPTION((PCT_SPM | 7, 0, "lx", SHARED.spm_index));
            }
            else
            {
                if (vpws_cfg_print_setting == SPM_PRINT_CFG)
                {
                    printf("  2）NNI接口配置[1-2] (nni_num=%d) ADD\n", pstSetVpws->nni_num);
                }

                OS_SPRINTF(ucMessage, "  2）NNI接口配置[1-2] (nni_num=%d) ADD\n", pstSetVpws->nni_num);
                BMU_SLOG(BMU_INFO, SPM_L2_LOG_DIR, ucMessage);

                for (i = 0; i < pstSetVpws->nni_num; i++)
                {
                    pstNniData[i] = (ATG_DCI_VPWS_NNI_DATA *)
                        (pucNniDataStart + (NBB_ALIGN_OFFSET(sizeof(ATG_DCI_VPWS_NNI_DATA))) * i);

                    NBB_TRC_DETAIL((NBB_FORMAT "  NNI ID = %d", i + 1));
                    NBB_TRC_DETAIL((NBB_FORMAT "  VC ID = %ld", pstNniData[i]->vc_id));
                    NBB_TRC_DETAIL((NBB_FORMAT "  PEER_IP = %s", spm_set_ulong_to_ipv4(pstNniData[i]->peer_ip NBB_CCXT)));
                    NBB_TRC_DETAIL((NBB_FORMAT "  VC_TYPE = %d", pstNniData[i]->vc_type));
                    NBB_TRC_DETAIL((NBB_FORMAT "  保护 = %s", pstNniData[i]->use_protect ? "有" : "无"));
                    NBB_TRC_DETAIL((NBB_FORMAT "  备VC ID = %ld", pstNniData[i]->vc_id_bak));
                    NBB_TRC_DETAIL((NBB_FORMAT "  备PEER_IP = %s", spm_set_ulong_to_ipv4(pstNniData[i]->peer_ip_bak NBB_CCXT)));
                    NBB_TRC_DETAIL((NBB_FORMAT "  备VC_TYPE = %d", pstNniData[i]->vc_type_bak));
                    NBB_TRC_DETAIL((NBB_FORMAT "  保护类型 = %d", pstNniData[i]->prot_type));
                    NBB_TRC_DETAIL((NBB_FORMAT "  保护是否返回 = %s", pstNniData[i]->if_return ? "返回" : "不返回"));
                    NBB_TRC_DETAIL((NBB_FORMAT "  等待恢复时间 = %d(分钟)", pstNniData[i]->restore_time));
                    NBB_TRC_DETAIL((NBB_FORMAT "  拖延时间 = %d(10毫秒)", pstNniData[i]->holdoff_time));
                    NBB_TRC_DETAIL((NBB_FORMAT "  NNI_NO = %d", pstNniData[i]->nni_no));

                    if (vpws_cfg_print_setting == SPM_PRINT_CFG)
                    {
                        spm_dbg_print_vpws_nni_cfg(pstNniData[i], i);
                    }

                    //spm_dbg_record_vpws_nni_cfg(pstNniData[i], i);
                    sprintf(ucMessage,"     NNI_NO  = %d\n", pstNniData[i]->nni_no);
                    BMU_SLOG(BMU_INFO, SPM_L2_LOG_DIR, ucMessage);

                    iVpNum = 0;
                    spm_vpws_get_vp_num(usVpwsIdKey, &iVpNum NBB_CCXT);

                    //stVcKeyMainNew.vc_id = pstNniData[i]->vc_id;
                    //stVcKeyMainNew.vc_type = pstNniData[i]->vc_type;
                    //stVcKeyMainNew.peer_ip = pstNniData[i]->peer_ip;

                    //stVcKeyBackNew.vc_id = pstNniData[i]->vc_id_bak;
                    //stVcKeyBackNew.vc_type = pstNniData[i]->vc_type_bak;
                    //stVcKeyBackNew.peer_ip = pstNniData[i]->peer_ip_bak;

                    usNniVpNo = pstNniData[i]->nni_no;

                    iNniExistPos = spm_if_vpn_nni_exist(L2VPN_VPWS, usNniVpNo, pstVpws NBB_CCXT);

                    OS_MEMSET(&stVpwsPortInfo, 0, sizeof(SPM_VPN_PORT_INFO_CB));

                    //1、VPWS不存在
                    //2、VPWS存在，但NNI不存在
                    //此时新增一个NNI,只有UNI+NNI的数目小于2时，才能增加相应VP
                    if ((ucIfExist == UNEXIST)
                        || ((ucIfExist == EXIST) && (iNniExistPos == 0)))
                    {
                        //如果是新增必须VP数据必须小于2
                        if (iVpNum < 2)
                        {
                            ret = spm_vpn_add_vp_nni(L2VPN_VPWS, usVpwsIdKey, usVsiMcId, pstNniData[i], &stVpwsPortInfo NBB_CCXT);

                            //成功，保存数据
                            if (ret == SUCCESS)
                            {
                                //在NNI的数组中找一个存储位置
                                for (j = 0; j < ATG_DCI_VPWS_NNI_NUM; j++)
                                {
                                    //如果为NULL，说明这个位置为无数据，可以存储数据
                                    if (pstVpws->nni_cfg_cb[j] == NULL)
                                    {
                                        pstVpws->nni_cfg_cb[j] =
                                            (ATG_DCI_VPWS_NNI_DATA *)NBB_MM_ALLOC(sizeof(ATG_DCI_VPWS_NNI_DATA),
                                            NBB_NORETRY_ACT,
                                            MEM_SPM_VPWS_NNI_CB);
                                        
                                        pstVpws->nni_info_cb[j].vp_idx = stVpwsPortInfo.vp_idx;
                                        pstVpws->nni_info_cb[j].port_index = stVpwsPortInfo.port_index;
                                        pstVpws->nni_info_cb[j].slot_id = stVpwsPortInfo.slot_id;
                                        pstVpws->nni_info_cb[j].port_type = stVpwsPortInfo.port_type;
                                        pstVpws->nni_info_cb[j].frr_group_id = stVpwsPortInfo.frr_group_id;
                                        pstVpws->nni_info_cb[j].port_num = stVpwsPortInfo.port_num;
                                        pstVpws->nni_info_cb[j].next_hop_id = stVpwsPortInfo.next_hop_id;
                                        pstVpws->nni_info_cb[j].next_hop_id_p = stVpwsPortInfo.next_hop_id_p;

                                        OS_MEMCPY(pstVpws->nni_info_cb[j].port_index_mc, stVpwsPortInfo.port_index_mc, 
                                            sizeof(NBB_ULONG) * ATG_DCI_ECMP_PORT_NUM);
                                        OS_MEMCPY(pstVpws->nni_info_cb[j].port_id_mc, stVpwsPortInfo.port_id_mc, 
                                            sizeof(NBB_USHORT) * ATG_DCI_ECMP_PORT_NUM);
                                        OS_MEMCPY(pstVpws->nni_info_cb[j].slot_id_mc, stVpwsPortInfo.slot_id_mc, 
                                            sizeof(NBB_BYTE) * ATG_DCI_ECMP_PORT_NUM);
                                        OS_MEMCPY(pstVpws->nni_info_cb[j].port_type_mc, stVpwsPortInfo.port_type_mc, 
                                            sizeof(NBB_BYTE) * ATG_DCI_ECMP_PORT_NUM);
                                        OS_MEMCPY(pstVpws->nni_cfg_cb[j], pstNniData[i], sizeof(ATG_DCI_VPWS_NNI_DATA));
                                        
                                        pstVpws->nni_num++;

                                        break;
                                    }
                                }
                            }
                            else    //如果增加NNI口失败记录错误状态
                            {
                                pstSetVpws->nni_return_code[i] = ATG_DCI_RC_UNSUCCESSFUL;

                                NBB_TRC_DETAIL((NBB_FORMAT
                                        "  ***ERROR***: <VPWS_ID=%d> spm_vpn_add_vp_nni() VPWS error! ret=%d",
                                        usVpwsIdKey, ret));

                                OS_PRINTF("***ERROR***: <VPWS_ID=%d> spm_vpn_add_vp_nni() VPWS error! ret=%d\n",
                                    usVpwsIdKey,
                                    ret);

                                OS_SPRINTF(ucMessage,
                                    "***ERROR***: <VPWS_ID=%d> spm_vpn_add_vp_nni() VPWS error! ret=%d\n",
                                    usVpwsIdKey,
                                    ret);
                                BMU_SLOG(BMU_INFO, SPM_L2_LOG_DIR, ucMessage);

                                NBB_EXCEPTION((PCT_SPM | VPWS_PD, 0, "ld d s s", usVpwsIdKey,
                                        ret,
                                        "CALL_FUNC_ERROR",
                                        ucMessage));
                            }
                        }
                        else
                        {
                            pstSetVpws->nni_return_code[i] = ATG_DCI_RC_UNSUCCESSFUL;

                            NBB_TRC_DETAIL((NBB_FORMAT "  ***ERROR***: <VPWS_ID=%d> VP NUM=%d 超过VPWS的定义范围！NNI",
                                    usVpwsIdKey, iVpNum));

                            OS_PRINTF("***ERROR***: <VPWS_ID=%d> VP NUM=%d 超过VPWS的定义范围！NNI\n",
                                usVpwsIdKey,
                                iVpNum);

                            OS_SPRINTF(ucMessage,
                                "***ERROR***: <VPWS_ID=%d> VP NUM=%d 超过VPWS的定义范围！NNI\n",
                                usVpwsIdKey,
                                iVpNum);
                            BMU_SLOG(BMU_INFO, SPM_L2_LOG_DIR, ucMessage);

                            NBB_EXCEPTION((PCT_SPM | VPWS_PD, 0, "ld d s s", usVpwsIdKey,
                                    VPWS_VP_NUM_IS_FULL,
                                    "VPWS_VP_NUM_IS_FULL",
                                    ucMessage));
                        }
                    }

                    //3、VPWS存在，且NNI存在，此时更新一个NNI
                    else if ((ucIfExist == EXIST) && (iNniExistPos != 0))
                    {

						ucProtectFlag = pstVpws->nni_cfg_cb[iNniExistPos - 1]->use_protect;
						
                        //清空旧主用VC配置中的驱动返回值
                        stTmpMainVcKey.vc_id = pstVpws->nni_cfg_cb[iNniExistPos - 1]->vc_id;
                        stTmpMainVcKey.vc_type = pstVpws->nni_cfg_cb[iNniExistPos - 1]->vc_type;
                        stTmpMainVcKey.peer_ip = pstVpws->nni_cfg_cb[iNniExistPos - 1]->peer_ip;

                        //清空之前先保存
                        spm_get_vc_drvinfo(stTmpMainVcKey, &stVcDrvInfoMainOld NBB_CCXT);
                        spm_get_vc_lspprotkey(stTmpMainVcKey,&st_lspprot_key NBB_CCXT);
                        
	                 //调用dk的接口获取ftnIndex
                        if (ATG_DCI_FTN == stVcDrvInfoMainOld.lsp_option)
                        {
                        	spm_l3_delvpldp(stTmpMainVcKey.peer_ip, 
                        					stVcDrvInfoMainOld.vp_idx, 
                        					stVcDrvInfoMainOld.next_hop_id
                        					NBB_CCXT);		            
                        }
                        else if (ATG_DCI_CR_LSP == stVcDrvInfoMainOld.lsp_option)
                        {
                        	spm_l3_delvprsvp(&st_lspprot_key, 
                        					stVcDrvInfoMainOld.vp_idx, 
                        					stVcDrvInfoMainOld.next_hop_id
                        					NBB_CCXT);	
                        }	
										
                        //spm_vc_drvinfo_clear(&stTmpMainVcKey NBB_CCXT);
                        spm_vc_drvinfo_nhi_clear(&stTmpMainVcKey NBB_CCXT);

						//如果上一次配置了保护
						if(ucProtectFlag == 1)
						{
							
							//清空旧备用VC配置中的驱动返回值
                        	stTmpBackVcKey.vc_id = pstVpws->nni_cfg_cb[iNniExistPos - 1]->vc_id_bak;
                        	stTmpBackVcKey.vc_type = pstVpws->nni_cfg_cb[iNniExistPos - 1]->vc_type_bak;
                        	stTmpBackVcKey.peer_ip = pstVpws->nni_cfg_cb[iNniExistPos - 1]->peer_ip_bak;

                        	//清空之前先保存
                        	spm_get_vc_drvinfo(stTmpBackVcKey, &stVcDrvInfoBackOld NBB_CCXT);
                            spm_get_vc_lspprotkey(stTmpBackVcKey,&st_lspprot_key_back NBB_CCXT);
                            
		              //调用dk的接口获取ftnIndex
                            if (ATG_DCI_FTN == stVcDrvInfoBackOld.lsp_option)
                            {
                            	spm_l3_delvpldp(stTmpBackVcKey.peer_ip, 
                            					stVcDrvInfoBackOld.vp_idx, 
                            					stVcDrvInfoBackOld.next_hop_id
                            					NBB_CCXT);		            
                            }
                            else if (ATG_DCI_CR_LSP == stVcDrvInfoBackOld.lsp_option)
                            {
                            	spm_l3_delvprsvp(&st_lspprot_key_back, 
                            					stVcDrvInfoBackOld.vp_idx, 
                            					stVcDrvInfoBackOld.next_hop_id
                            					NBB_CCXT);	
                            }	
                                            
                        	//spm_vc_drvinfo_clear(&stTmpBackVcKey NBB_CCXT);
                        	spm_vc_drvinfo_nhi_clear(&stTmpBackVcKey NBB_CCXT);

							//保存保护组id
							if (stVcDrvInfoMainOld.frr_group_id != 0)
							{
								stVpwsPortInfo.frr_group_id = stVcDrvInfoMainOld.frr_group_id;
							}
							else if (stVcDrvInfoBackOld.frr_group_id != 0)
							{
								stVpwsPortInfo.frr_group_id = stVcDrvInfoBackOld.frr_group_id;
							}
						}
						
                        stVpwsPortInfo.vp_idx = pstVpws->nni_cfg_cb[iNniExistPos - 1]->nni_no;
                        stVpwsPortInfo.next_hop_id = pstVpws->nni_info_cb[iNniExistPos - 1].next_hop_id;
                        stVpwsPortInfo.next_hop_id_p = pstVpws->nni_info_cb[iNniExistPos - 1].next_hop_id_p;

                        ret = spm_vpn_add_vp_nni(L2VPN_VPWS, usVpwsIdKey, usVsiMcId, pstNniData[i], &stVpwsPortInfo NBB_CCXT);

                        //成功，保存数据
                        if (ret == SUCCESS)
                        {
                            pstVpws->nni_info_cb[iNniExistPos - 1].port_index = stVpwsPortInfo.port_index;
                            pstVpws->nni_info_cb[iNniExistPos - 1].slot_id = stVpwsPortInfo.slot_id;
                            pstVpws->nni_info_cb[iNniExistPos - 1].port_type = stVpwsPortInfo.port_type;
                            pstVpws->nni_info_cb[iNniExistPos - 1].frr_group_id = stVpwsPortInfo.frr_group_id;
                            pstVpws->nni_info_cb[iNniExistPos - 1].port_num = stVpwsPortInfo.port_num;
                            pstVpws->nni_info_cb[iNniExistPos - 1].next_hop_id = stVpwsPortInfo.next_hop_id;
                            pstVpws->nni_info_cb[iNniExistPos - 1].next_hop_id_p = stVpwsPortInfo.next_hop_id_p;

                            OS_MEMCPY(pstVpws->nni_info_cb[iNniExistPos - 1].port_index_mc, 
                                stVpwsPortInfo.port_index_mc, 
                                sizeof(NBB_ULONG) * ATG_DCI_ECMP_PORT_NUM);
                            OS_MEMCPY(pstVpws->nni_info_cb[iNniExistPos - 1].port_id_mc, stVpwsPortInfo.port_id_mc, 
                                sizeof(NBB_USHORT) * ATG_DCI_ECMP_PORT_NUM);
                            OS_MEMCPY(pstVpws->nni_info_cb[iNniExistPos - 1].slot_id_mc, stVpwsPortInfo.slot_id_mc, 
                                sizeof(NBB_BYTE) * ATG_DCI_ECMP_PORT_NUM);
                            OS_MEMCPY(pstVpws->nni_info_cb[iNniExistPos - 1].port_type_mc, stVpwsPortInfo.port_type_mc, 
                                sizeof(NBB_BYTE) * ATG_DCI_ECMP_PORT_NUM);                            
                            OS_MEMCPY(pstVpws->nni_cfg_cb[iNniExistPos - 1], pstNniData[i],
                                sizeof(ATG_DCI_VPWS_NNI_DATA));
                          
                        }
                        else    //如果删除NNI口失败记录错误状态
                        {
							//还原VC表的驱动返回值
							spm_set_vc_drvinfo(stTmpMainVcKey, &stVcDrvInfoMainOld NBB_CCXT);

							if(ucProtectFlag == 1)
							{
								spm_set_vc_drvinfo(stTmpBackVcKey, &stVcDrvInfoBackOld NBB_CCXT);
							}
							
                            pstSetVpws->nni_return_code[i] = ATG_DCI_RC_UNSUCCESSFUL;

                            NBB_TRC_DETAIL((NBB_FORMAT
                                    "  ***ERROR***: <VPWS_ID=%d> spm_vpn_add_vp_nni() 更新 VPWS error! ret=%d",
                                    usVpwsIdKey,
                                    ret));

                            OS_PRINTF("***ERROR***: <VPWS_ID=%d> spm_vpn_add_vp_nni() 更新 VPWS error! ret=%d\n",
                                usVpwsIdKey,
                                ret);

                            OS_SPRINTF(ucMessage,
                                "***ERROR***: <VPWS_ID=%d> spm_vpn_add_vp_nni() 更新 VPWS error! ret=%d\n",
                                usVpwsIdKey,
                                ret);
                            BMU_SLOG(BMU_INFO, SPM_L2_LOG_DIR, ucMessage);

                            NBB_EXCEPTION((PCT_SPM | VPWS_PD, 0, "ld d s s", usVpwsIdKey,
                                    ret,
                                    "CALL_FUNC_ERROR",
                                    ucMessage));
                        }
                    }
                }
            }
        }
        else if (ulOperNni == ATG_DCI_OPER_DEL)
        {
            NBB_TRC_DETAIL((NBB_FORMAT "  NNI DEL"));

            //如果此Key值的VPWS配置不存在，则无法删除VPWS内的端口
            if (ucIfExist == ATG_DCI_UNEXIST)
            {
                NBB_TRC_DETAIL((NBB_FORMAT "  ***ERROR***:单独删除VPWS内NNI端口时，VPWS_ID=%d 的业务不存在，无法处理!",
                        usVpwsIdKey));

                OS_PRINTF("***ERROR***:单独删除VPWS内NNI端口时，VPWS_ID=%d 的业务不存在，无法处理!\n", usVpwsIdKey);

                OS_SPRINTF(ucMessage,
                    "***ERROR***:单独删除VPWS内NNI端口时，VPWS_ID=%d 的业务不存在，无法处理!\n",
                    usVpwsIdKey);
                BMU_SLOG(BMU_INFO, SPM_L2_LOG_DIR, ucMessage);

                NBB_EXCEPTION((PCT_SPM | VPWS_PD, 0, "ld d s s", usVpwsIdKey,
                        BASIC_CONFIG_NOT_EXIST,
                        "BASIC_CONFIG_NOT_EXIST",
                        ucMessage));
                        
                goto EXIT_LABEL;
            }

            /* 计算第一个entry的地址。*/
            pucNniDataStart = (NBB_BYTE *)NTL_OFFLEN_GET_POINTER(pstSetVpws, &pstSetVpws->nni_data);

            /* 如果指针为NULL，无数据 */
            if (pucNniDataStart == NULL)
            {
                NBB_TRC_FLOW((NBB_FORMAT "  pucNniDataStart is NULL."));
                NBB_EXCEPTION((PCT_SPM | 7, 0, "lx", SHARED.spm_index));
            }
            else
            {
                if (vpws_cfg_print_setting == SPM_PRINT_CFG)
                {
                    printf("  2）NNI接口配置[1-2] (nni_num=%d) DEL\n", pstSetVpws->nni_num);
                }

                OS_SPRINTF(ucMessage, "  2）NNI接口配置[1-2] (nni_num=%d) DEL\n", pstSetVpws->nni_num);
                BMU_SLOG(BMU_INFO, SPM_L2_LOG_DIR, ucMessage);

                for (i = 0; i < pstSetVpws->nni_num; i++)
                {
                    pstNniData[i] = (ATG_DCI_VPWS_NNI_DATA *)
                        (pucNniDataStart + (NBB_ALIGN_OFFSET(sizeof(ATG_DCI_VPWS_NNI_DATA))) * i);

                    NBB_TRC_DETAIL((NBB_FORMAT "  NNI ID = %d", i + 1));
                    NBB_TRC_DETAIL((NBB_FORMAT "  VC ID = %ld", pstNniData[i]->vc_id));
                    NBB_TRC_DETAIL((NBB_FORMAT "  PEER_IP = %s", spm_set_ulong_to_ipv4(pstNniData[i]->peer_ip NBB_CCXT)));
                    NBB_TRC_DETAIL((NBB_FORMAT "  VC_TYPE = %d", pstNniData[i]->vc_type));
                    NBB_TRC_DETAIL((NBB_FORMAT "  保护 = %s", pstNniData[i]->use_protect ? "有" : "无"));
                    NBB_TRC_DETAIL((NBB_FORMAT "  备VC ID = %ld", pstNniData[i]->vc_id_bak));
                    NBB_TRC_DETAIL((NBB_FORMAT "  备PEER_IP = %s", spm_set_ulong_to_ipv4(pstNniData[i]->peer_ip_bak NBB_CCXT)));
                    NBB_TRC_DETAIL((NBB_FORMAT "  备VC_TYPE = %d", pstNniData[i]->vc_type_bak));
                    NBB_TRC_DETAIL((NBB_FORMAT "  保护类型 = %d", pstNniData[i]->prot_type));
                    NBB_TRC_DETAIL((NBB_FORMAT "  保护是否返回 = %s", pstNniData[i]->if_return ? "返回" : "不返回"));
                    NBB_TRC_DETAIL((NBB_FORMAT "  等待恢复时间 = %d(分钟)", pstNniData[i]->restore_time));
                    NBB_TRC_DETAIL((NBB_FORMAT "  拖延时间 = %d(10毫秒)", pstNniData[i]->holdoff_time));

                    if (vpws_cfg_print_setting == SPM_PRINT_CFG)
                    {
                        spm_dbg_print_vpws_nni_cfg(pstNniData[i], i);
                    }

                    //spm_dbg_record_vpws_nni_cfg(pstNniData[i], i);

                    ret = spm_vpn_del_vp_nni(L2VPN_VPWS, usVpwsIdKey, usVsiMcId, pstNniData[i] NBB_CCXT);

                    if (ret == SUCCESS)
                    {
                        for (j = 0; j < ATG_DCI_VPWS_NNI_NUM; j++)
                        {
                            if ((pstVpws->nni_cfg_cb[j] != NULL)
                                && (pstVpws->nni_cfg_cb[j]->nni_no == pstNniData[i]->nni_no))
                            {
                                //free
                                NBB_MM_FREE(pstVpws->nni_cfg_cb[j], MEM_SPM_VPWS_NNI_CB);

                                pstVpws->nni_cfg_cb[j] = NULL;
                                pstVpws->nni_num--;
                                
				    //回收next_hop_id
                                if (0 != pstVpws->nni_info_cb[j].next_hop_id)
		    		    {
		    		    	spm_free_vc_nhi_id(pstVpws->nni_info_cb[j].next_hop_id NBB_CCXT);
		    		    }
                                
                                if (0 != pstVpws->nni_info_cb[j].next_hop_id_p)
		    		    {
		    		    	spm_free_vc_nhi_id(pstVpws->nni_info_cb[j].next_hop_id_p NBB_CCXT);
                            
		    		    }
                                
                                OS_MEMSET(&pstVpws->nni_info_cb[j], 0, sizeof(SPM_VPN_PORT_INFO_CB));

                                break;
                            }
                        }
                    }
                    else
                    {
                        pstSetVpws->nni_return_code[i] = ATG_DCI_RC_UNSUCCESSFUL;

                        NBB_TRC_DETAIL((NBB_FORMAT "  ***ERROR***: <VPWS_ID=%d> spm_vpn_del_vp_nni() error! ret=%d",
                                usVpwsIdKey, ret));

                        OS_PRINTF("***ERROR***: <VPWS_ID=%d> spm_vpn_del_vp_nni() ret=%d\n", usVpwsIdKey, ret);

                        OS_SPRINTF(ucMessage,
                            "***ERROR***: <VPWS_ID=%d> spm_vpn_del_vp_nni() ret=%d\n",
                            usVpwsIdKey,
                            ret);
                        BMU_SLOG(BMU_INFO, SPM_L2_LOG_DIR, ucMessage);

                        NBB_EXCEPTION((PCT_SPM | VPWS_PD, 0, "ld d s s", usVpwsIdKey,
                                ret,
                                "CALL_FUNC_ERROR",
                                ucMessage));
                    }

                }
            }
        }
        else if (ulOperNni == ATG_DCI_OPER_UPDATE)
        {
            NBB_EXCEPTION((PCT_SPM | 7, 2, "lx", SHARED.spm_index));
        }

        /******************************** UNI配置 *********************************/
        if (ulOperUni == ATG_DCI_OPER_ADD)
        {

            /* 计算第一个entry的地址。*/
            pucUniDataStart = (NBB_BYTE *)NTL_OFFLEN_GET_POINTER(pstSetVpws, &pstSetVpws->uni_data);

            /* 如果指针为NULL，无数据 */
            if (pucUniDataStart == NULL)
            {
                NBB_TRC_FLOW((NBB_FORMAT "  pucUniDataStart is NULL."));
                NBB_EXCEPTION((PCT_SPM | 7, 0, "lx", SHARED.spm_index));
            }
            else
            {
                if (vpws_cfg_print_setting == SPM_PRINT_CFG)
                {
                    printf("  3）UNI接口配置[1-2] (uni_num=%d) ADD\n", pstSetVpws->uni_num);
                }

                OS_SPRINTF(ucMessage, "  3）UNI接口配置[1-2] (uni_num=%d) ADD\n", pstSetVpws->uni_num);
                BMU_SLOG(BMU_INFO, SPM_L2_LOG_DIR, ucMessage);

                for (i = 0; i < pstSetVpws->uni_num; i++)
                {
                    pstUniData[i] = (ATG_DCI_VPWS_UNI_DATA *)
                        (pucUniDataStart + (NBB_ALIGN_OFFSET(sizeof(ATG_DCI_VPWS_UNI_DATA))) * i);

                    NBB_TRC_DETAIL((NBB_FORMAT "  端口Index = %ld", pstUniData[i]->port_index));
                    NBB_TRC_DETAIL((NBB_FORMAT "  备用端口Index = %d", pstUniData[i]->slave_port_index));
                    NBB_TRC_DETAIL((NBB_FORMAT "  MSP ID = %d", pstUniData[i]->msp_id));
                    NBB_TRC_DETAIL((NBB_FORMAT "  UNI NO = %d", pstUniData[i]->uni_no));

                    if (vpws_cfg_print_setting == SPM_PRINT_CFG)
                    {
                        spm_dbg_print_vpws_uni_cfg(pstUniData[i], i);
                    }

                    //spm_dbg_record_vpws_uni_cfg(pstUniData[i], i);
                    sprintf(ucMessage,"     UNI_NO  = %d\n", pstUniData[i]->uni_no);
                    BMU_SLOG(BMU_INFO, SPM_L2_LOG_DIR, ucMessage);

                    iVpNum = 0;
                    spm_vpws_get_vp_num(usVpwsIdKey, &iVpNum NBB_CCXT);

                    OS_MEMSET(&stVpwsPortInfo, 0, sizeof(SPM_VPN_PORT_INFO_CB));

                    iUniExistPos = spm_if_vpn_uni_exist(L2VPN_VPWS, pstUniData[i]->port_index, pstVpws NBB_CCXT);

                    //1、VPWS不存在
                    //2、VPWS存在，但UNI不存在
                    //此时新增一个UNI,只有UNI+NNI的数目小于2时，才能增加相应VP
                    if ((ucIfExist == UNEXIST)
                        || ((ucIfExist == EXIST) && (iUniExistPos == 0)))
                    {
                        if (iVpNum < 2)
                        {
                            ret = spm_vpn_add_vp_uni(L2VPN_VPWS, usVpwsIdKey, usVsiMcId, pstUniData[i], &stVpwsPortInfo NBB_CCXT);

                            //如果成功，保存数据
                            if (ret == SUCCESS)
                            {
                                for (j = 0; j < ATG_DCI_VPWS_UNI_NUM; j++)
                                {

                                    //如果为NULL，说明这个位置为无数据，可以存储数据
                                    if (pstVpws->uni_cfg_cb[j] == NULL)
                                    {
                                        pstVpws->uni_cfg_cb[j] =
                                            (ATG_DCI_VPWS_UNI_DATA *)NBB_MM_ALLOC(sizeof(ATG_DCI_VPWS_UNI_DATA),
                                            NBB_NORETRY_ACT,
                                            MEM_SPM_VPWS_UNI_CB);

                                        pstVpws->uni_info_cb[j].vp_idx = stVpwsPortInfo.vp_idx;
                                        pstVpws->uni_info_cb[j].port_index = stVpwsPortInfo.port_index;
                                        OS_MEMCPY(pstVpws->uni_cfg_cb[j], pstUniData[i], sizeof(ATG_DCI_VPWS_UNI_DATA));

                                        pstVpws->uni_num++;

                                        break;
                                    }
                                }
                            }
                            else    //如果增加UNI口失败记录错误状态
                            {
                                pstSetVpws->uni_return_code[i] = ATG_DCI_RC_UNSUCCESSFUL;

                                NBB_TRC_DETAIL((NBB_FORMAT
                                        "  ***ERROR***: <VPWS_ID=%d> spm_vpn_add_vp_uni() VPWS error! ret=%d",
                                        usVpwsIdKey, ret));

                                OS_PRINTF("***ERROR***: <VPWS_ID=%d> spm_vpn_add_vp_uni() VPWS ret=%d\n",
                                    usVpwsIdKey,
                                    ret);

                                OS_SPRINTF(ucMessage,
                                    "***ERROR***: <VPWS_ID=%d> spm_vpn_add_vp_uni() VPWS ret=%d\n",
                                    usVpwsIdKey,
                                    ret);
                                BMU_SLOG(BMU_INFO, SPM_L2_LOG_DIR, ucMessage);

                                NBB_EXCEPTION((PCT_SPM | VPWS_PD, 0, "ld d s s", usVpwsIdKey,
                                        ret,
                                        "CALL_FUNC_ERROR",
                                        ucMessage));
                            }
                        }
                        else
                        {
                            pstSetVpws->uni_return_code[i] = ATG_DCI_RC_UNSUCCESSFUL;

                            NBB_TRC_DETAIL((NBB_FORMAT "  ***ERROR***: <VPWS_ID=%d> VP NUM=%d 超过VPWS的定义范围！UNI",
                                    usVpwsIdKey, iVpNum));

                            OS_PRINTF("***ERROR***: <VPWS_ID=%d> VP NUM=%d 超过VPWS的定义范围！UNI\n",
                                usVpwsIdKey,
                                iVpNum);

                            OS_SPRINTF(ucMessage,
                                "***ERROR***: <VPWS_ID=%d> VP NUM=%d 超过VPWS的定义范围！UNI\n",
                                usVpwsIdKey,
                                iVpNum);
                            BMU_SLOG(BMU_INFO, SPM_L2_LOG_DIR, ucMessage);

                            NBB_EXCEPTION((PCT_SPM | VPWS_PD, 0, "ld d s s", usVpwsIdKey,
                                    VPWS_VP_NUM_IS_FULL,
                                    "VPWS_VP_NUM_IS_FULL",
                                    ucMessage));
                        }
                    }

                    //3、VPWS存在，且UNI存在
                    //此时更新一个UNI
                    else if ((ucIfExist == EXIST) && (iUniExistPos != 0))
                    {
                        stVpwsPortInfo.vp_idx = pstVpws->uni_info_cb[iUniExistPos - 1].vp_idx;

						//清空之前先保存逻辑接口的驱动返回值
						spm_get_logical_port_drvinfo(pstUniData[i]->port_index, &stLogicalPortDrvInfo NBB_CCXT);
						
                        //清空逻辑接口配置中的驱动返回值
                        //spm_uni_logical_port_drvinfo_clear(pstUniData[i]->port_index NBB_CCXT);
                        spm_uni_logical_port_drvinfo_nhi_clear(pstUniData[i]->port_index NBB_CCXT);

                        ret = spm_vpn_add_vp_uni(L2VPN_VPWS, usVpwsIdKey, usVsiMcId, pstUniData[i], &stVpwsPortInfo NBB_CCXT);

                        //成功，保存数据
                        if (ret == SUCCESS)
                        {
                        	pstVpws->uni_info_cb[iUniExistPos - 1].port_index = stVpwsPortInfo.port_index;
                            OS_MEMCPY(pstVpws->uni_cfg_cb[iUniExistPos - 1], pstUniData[i],
                                sizeof(ATG_DCI_VPWS_UNI_DATA));
                        }
                        else    //如果删除NNI口失败记录错误状态
                        {
                        	//失败就还原驱动返回值
                        	spm_set_logical_port_drvinfo(pstUniData[i]->port_index, &stLogicalPortDrvInfo NBB_CCXT);
                        	
                            pstSetVpws->uni_return_code[i] = ATG_DCI_RC_UNSUCCESSFUL;

                            NBB_TRC_DETAIL((NBB_FORMAT
                                    "  ***ERROR***: <VPWS_ID=%d> spm_vpn_add_vp_uni() 更新 VPWS error! ret=%d",
                                    usVpwsIdKey,
                                    ret));

                            OS_PRINTF("***ERROR***: <VPWS_ID=%d> spm_vpn_add_vp_uni() 更新 VPWS error! ret=%d\n",
                                usVpwsIdKey,
                                ret);

                            OS_SPRINTF(ucMessage,
                                "***ERROR***: <VPWS_ID=%d> spm_vpn_add_vp_uni() 更新 VPWS error! ret=%d\n",
                                usVpwsIdKey,
                                ret);
                            BMU_SLOG(BMU_INFO, SPM_L2_LOG_DIR, ucMessage);

                            NBB_EXCEPTION((PCT_SPM | VPWS_PD, 0, "ld d s s", usVpwsIdKey,
                                    ret,
                                    "CALL_FUNC_ERROR",
                                    ucMessage));
                        }
                    }
                }
            }
        }
        else if (ulOperUni == ATG_DCI_OPER_DEL)
        {
            NBB_TRC_DETAIL((NBB_FORMAT "  UNI DEL"));

            //如果此Key值的VPWS配置不存在，则无法删除VPWS内的端口
            if (ucIfExist == ATG_DCI_UNEXIST)
            {
                NBB_TRC_DETAIL((NBB_FORMAT "  ***ERROR***:单独删除VPWS内UNI端口时，VPWS_ID=%d的业务不存在，无法处理!",
                        usVpwsIdKey));

                OS_PRINTF("***ERROR***:单独删除VPWS内UNI端口时，VPWS_ID=%d 的业务不存在，无法处理!\n", usVpwsIdKey);

                OS_SPRINTF(ucMessage,
                    "***ERROR***:单独删除VPWS内UNI端口时，VPWS_ID=%d 的业务不存在，无法处理!\n",
                    usVpwsIdKey);
                BMU_SLOG(BMU_INFO, SPM_L2_LOG_DIR, ucMessage);

                NBB_EXCEPTION((PCT_SPM | VPWS_PD, 0, "ld d s s", usVpwsIdKey,
                        BASIC_CONFIG_NOT_EXIST,
                        "BASIC_CONFIG_NOT_EXIST",
                        ucMessage));
                        
                goto EXIT_LABEL;
            }

            /* 计算第一个entry的地址。*/
            pucUniDataStart = (NBB_BYTE *)NTL_OFFLEN_GET_POINTER(pstSetVpws, &pstSetVpws->uni_data);

            /* 如果指针为NULL，无数据 */
            if (pucUniDataStart == NULL)
            {
                NBB_TRC_FLOW((NBB_FORMAT "  pucUniDataStart is NULL."));
                NBB_EXCEPTION((PCT_SPM | 7, 0, "lx", SHARED.spm_index));
            }
            else
            {
                if (vpws_cfg_print_setting == SPM_PRINT_CFG)
                {
                    printf("  3）UNI接口配置[1-2] (uni_num=%d) DEL\n", pstSetVpws->uni_num);
                }

                OS_SPRINTF(ucMessage, "  3）UNI接口配置[1-2] (uni_num=%d) DEL\n", pstSetVpws->uni_num);
                BMU_SLOG(BMU_INFO, SPM_L2_LOG_DIR, ucMessage);

                for (i = 0; i < pstSetVpws->uni_num; i++)
                {
                    pstUniData[i] = (ATG_DCI_VPWS_UNI_DATA *)
                        (pucUniDataStart + (NBB_ALIGN_OFFSET(sizeof(ATG_DCI_VPWS_UNI_DATA))) * i);

                    NBB_TRC_DETAIL((NBB_FORMAT "  端口Index = %ld", pstUniData[i]->port_index));
                    NBB_TRC_DETAIL((NBB_FORMAT "  UNI NO = %d", pstUniData[i]->uni_no));

                    if (vpws_cfg_print_setting == SPM_PRINT_CFG)
                    {
                        spm_dbg_print_vpws_uni_cfg(pstUniData[i], i);
                    }

                    //spm_dbg_record_vpws_uni_cfg(pstUniData[i], i);

                    ret = spm_vpn_del_vp_uni(L2VPN_VPWS, usVpwsIdKey, usVsiMcId, pstUniData[i] NBB_CCXT);

                    if (ret == SUCCESS)
                    {
                        for (j = 0; j < ATG_DCI_VPWS_UNI_NUM; j++)
                        {
                            if ((pstVpws->uni_cfg_cb[j] != NULL)
                                && (pstVpws->uni_cfg_cb[j]->port_index == pstUniData[i]->port_index))
                            {
                                //free
                                NBB_MM_FREE(pstVpws->uni_cfg_cb[j], MEM_SPM_VPWS_UNI_CB);

                                pstVpws->uni_cfg_cb[j] = NULL;
                                pstVpws->uni_num--;
                                                                
                                OS_MEMSET(&pstVpws->uni_info_cb[j], 0, sizeof(SPM_VPN_PORT_INFO_CB));

                                break;
                            }
                        }
                    }
                    else
                    {
                        pstSetVpws->uni_return_code[i] = ATG_DCI_RC_UNSUCCESSFUL;

                        NBB_TRC_DETAIL((NBB_FORMAT "  ***ERROR***: <VPWS_ID=%d> spm_vpn_del_vp_uni() error! ret=%d",
                                usVpwsIdKey, ret));

                        OS_PRINTF("***ERROR***: <VPWS_ID=%d> spm_vpn_del_vp_uni() ret=%d\n", usVpwsIdKey, ret);

                        OS_SPRINTF(ucMessage,
                            "***ERROR***: <VPWS_ID=%d> spm_vpn_del_vp_uni() ret=%d\n",
                            usVpwsIdKey,
                            ret);
                        BMU_SLOG(BMU_INFO, SPM_L2_LOG_DIR, ucMessage);

                        NBB_EXCEPTION((PCT_SPM | VPWS_PD, 0, "ld d s s", usVpwsIdKey,
                                ret,
                                "CALL_FUNC_ERROR",
                                ucMessage));
                    }
                }
            }
        }
        else if (ulOperUni == ATG_DCI_OPER_UPDATE)
        {
            NBB_EXCEPTION((PCT_SPM | 7, 2, "lx", SHARED.spm_index));
        }

        /******************************** Bypass PW配置 *********************************/
        if (ulOperBypass == ATG_DCI_OPER_ADD)
        {
            NBB_TRC_DETAIL((NBB_FORMAT "  BYPASS ADD"));

            /* 计算第一个entry的地址。*/
            pucBypassDataStart = (NBB_BYTE *)NTL_OFFLEN_GET_POINTER(pstSetVpws, &pstSetVpws->bypass_pw_data);

            /* 如果指针为NULL，无数据 */
            if (pucBypassDataStart == NULL)
            {
                NBB_TRC_FLOW((NBB_FORMAT "  pucBypassDataStart is NULL."));
                NBB_EXCEPTION((PCT_SPM | 7, 0, "lx", SHARED.spm_index));
            }
            else
            {
                pstBypassData = (ATG_DCI_VPWS_BYPASS_PW_DATA *)pucBypassDataStart;

                NBB_TRC_DETAIL((NBB_FORMAT "  VC ID = %ld", pstBypassData->vc_id));
                NBB_TRC_DETAIL((NBB_FORMAT "  PEER_IP = %s", spm_set_ulong_to_ipv4(pstBypassData->peer_ip NBB_CCXT)));
                NBB_TRC_DETAIL((NBB_FORMAT "  VC_TYPE = %d", pstBypassData->vc_type));
                NBB_TRC_DETAIL((NBB_FORMAT "  双归关联ID = %d", pstBypassData->dualhome_id));
                NBB_TRC_DETAIL((NBB_FORMAT "  BYPASS_DH_ID = %d", pstBypassData->bypass_dh_id));
                NBB_TRC_DETAIL((NBB_FORMAT "  NNI_NO = %d", pstBypassData->nni_no));

                if (vpws_cfg_print_setting == SPM_PRINT_CFG)
                {
                    printf("  4）Bypass PW配置 ADD\n");
                    spm_dbg_print_vpws_bypass_cfg(pstBypassData);
                }

                OS_SPRINTF(ucMessage, "  4）Bypass PW配置 ADD\n");
                BMU_SLOG(BMU_INFO, SPM_L2_LOG_DIR, ucMessage);
                
                //spm_dbg_record_vpws_bypass_cfg(pstBypassData);

                //如果 双归关联ID＝0 或 BYPASS_DH_ID＝0配置有误，跳出
                if ((pstBypassData->dualhome_id == 0) || (pstBypassData->bypass_dh_id == 0))
                {
                    pstSetVpws->bypass_pw_return_code = ATG_DCI_RC_UNSUCCESSFUL;

                    NBB_TRC_DETAIL((NBB_FORMAT
                            "  ***ERROR***: <VPWS_ID=%d> 双归关联ID=%d 或 BYPASS_DH_ID=%d 出错返回", usVpwsIdKey,
                            pstBypassData->dualhome_id, pstBypassData->bypass_dh_id));

                    OS_PRINTF("***ERROR***: <VPWS_ID=%d> 双归关联ID=%d 或 BYPASS_DH_ID=%d 出错返回\n", usVpwsIdKey,
                            pstBypassData->dualhome_id, pstBypassData->bypass_dh_id);

                    OS_SPRINTF(ucMessage,
                        "***ERROR***: <VPWS_ID=%d> 双归关联ID=%d 或 BYPASS_DH_ID=%d 出错返回\n", usVpwsIdKey,
                            pstBypassData->dualhome_id, pstBypassData->bypass_dh_id);
                    BMU_SLOG(BMU_INFO, SPM_L2_LOG_DIR, ucMessage);

                    NBB_EXCEPTION((PCT_SPM | VPWS_PD, 0, "ld d s s", usVpwsIdKey,
                            ret,
                            "BASIC_CONFIG_NOT_EXIST",
                            ucMessage));

                    goto EXIT_LABEL;
                }

                stBypassVcKey.vc_id = pstBypassData->vc_id;
                stBypassVcKey.vc_type = pstBypassData->vc_type;
                stBypassVcKey.peer_ip = pstBypassData->peer_ip;

                OS_MEMSET(&stVpwsPortInfo, 0, sizeof(SPM_VPN_PORT_INFO_CB));

                //如果UNI和NNI配置同时存在一对，那么可以建Bypass
                if (((pstVpws->nni_info_cb[0].vp_idx != 0) || (pstVpws->nni_info_cb[1].vp_idx != 0))
                    && ((pstVpws->uni_info_cb[0].vp_idx != 0) || (pstVpws->uni_info_cb[1].vp_idx != 0)))
                {
                	stVpwsPortInfo.vp_idx = pstVpws->bypass_info_cb.vp_idx;
                	
                    ret = spm_vpn_add_vp_bypass(L2VPN_VPWS, usVpwsIdKey, usVsiMcId, pstBypassData, &stVpwsPortInfo NBB_CCXT);

#ifdef SPU

                    //找到Bypass NNI
                    for (i = 0; i < ATG_DCI_VPWS_NNI_NUM; i++)
                    {
                        if (pstVpws->nni_info_cb[i].vp_idx != 0)
                        {
                            iVpNniPosId = pstVpws->nni_info_cb[i].vp_idx;
                            break;
                        }
                    }

                    //找到Bypass UNI
                    for (i = 0; i < ATG_DCI_VPWS_UNI_NUM; i++)
                    {
                        if (pstVpws->uni_info_cb[i].vp_idx != 0)
                        {
                            iVpUniPosId = pstVpws->uni_info_cb[i].vp_idx;
                            break;
                        }
                    }

                    for (ucC3Unit = 0; ucC3Unit < SHARED.c3_num; ucC3Unit++)
                    {
                        ret += ApiC3BindVp(ucC3Unit, iVpNniPosId, iVpUniPosId);

                        NBB_TRC_DETAIL((NBB_FORMAT "  ApiC3BindVp() ret=%d", ret));
                    }

#endif

                    //成功，保存数据
                    if (ret == SUCCESS)
                    {
                        //如果为NULL，说明这个位置为无数据，可以存储数据
                        if (pstVpws->bypass_cfg_cb == NULL)
                        {
                            pstVpws->bypass_cfg_cb =
                                (ATG_DCI_VPWS_BYPASS_PW_DATA *)NBB_MM_ALLOC(sizeof(ATG_DCI_VPWS_BYPASS_PW_DATA),
                                NBB_NORETRY_ACT,
                                MEM_SPM_VPWS_BYPASS_CB);
                        }
                        
                        pstVpws->bypass_info_cb.vp_idx = stVpwsPortInfo.vp_idx;
                        pstVpws->bypass_info_cb.next_hop_id = stVpwsPortInfo.next_hop_id;
                        OS_MEMCPY(pstVpws->bypass_cfg_cb, pstBypassData, sizeof(ATG_DCI_VPWS_BYPASS_PW_DATA));
                            
                        //传递保护配置
                        spm_set_bypass_prot(pstVpws, pstBypassData->dualhome_id, pstBypassData->bypass_dh_id NBB_CCXT);
                    }
                    else    //如果增加NNI口失败记录错误状态
                    {
                        pstSetVpws->bypass_pw_return_code = ATG_DCI_RC_UNSUCCESSFUL;

                        NBB_TRC_DETAIL((NBB_FORMAT
                                "  ***ERROR***: <VPWS_ID=%d> spm_vpn_add_vp_bypass() VPWS error! ret=%d", usVpwsIdKey,
                                ret));

                        OS_PRINTF("***ERROR***: <VPWS_ID=%d> spm_vpn_add_vp_bypass() VPWS error! ret=%d\n",
                            usVpwsIdKey,
                            ret);

                        OS_SPRINTF(ucMessage,
                            "***ERROR***: <VPWS_ID=%d> spm_vpn_add_vp_bypass() VPWS error! ret=%d\n",
                            usVpwsIdKey,
                            ret);
                        BMU_SLOG(BMU_INFO, SPM_L2_LOG_DIR, ucMessage);

                        NBB_EXCEPTION((PCT_SPM | VPWS_PD, 0, "ld d s s", usVpwsIdKey,
                                ret,
                                "CALL_FUNC_ERROR",
                                ucMessage));
                    }
                }
                else
                {
                    pstSetVpws->bypass_pw_return_code = ATG_DCI_RC_UNSUCCESSFUL;

                    NBB_TRC_DETAIL((NBB_FORMAT
                            "  ***ERROR***: <VPWS_ID=%d> 不存在一对UNI和NNI配置，那么无法建立Bypass", usVpwsIdKey));

                    OS_PRINTF("***ERROR***: <VPWS_ID=%d> 不存在一对UNI和NNI配置，那么无法建立Bypass\n", usVpwsIdKey);

                    OS_SPRINTF(ucMessage,
                        "***ERROR***: <VPWS_ID=%d> 不存在一对UNI和NNI配置，那么无法建立Bypass\n", usVpwsIdKey);
                    BMU_SLOG(BMU_INFO, SPM_L2_LOG_DIR, ucMessage);

                    NBB_EXCEPTION((PCT_SPM | VPWS_PD, 0, "ld d s s", usVpwsIdKey,
                            0,
                            "CALL_FUNC_ERROR",
                            ucMessage));
                }

            }
        }
        else if (ulOperBypass == ATG_DCI_OPER_DEL)
        {
            NBB_TRC_DETAIL((NBB_FORMAT "  BYPASS DEL"));

            //如果此Key值的VPWS配置不存在，则无法删除VPWS内的端口
            if (ucIfExist == ATG_DCI_UNEXIST)
            {
                NBB_TRC_DETAIL((NBB_FORMAT
                        "  ***ERROR***:单独删除VPWS内BYPASS端口时，VPWS_ID=%d 的业务不存在，无法处理!", usVpwsIdKey));

                OS_PRINTF("***ERROR***:单独删除VPWS内BYPASS端口时，VPWS_ID=%d 的业务不存在，无法处理!\n", usVpwsIdKey);

                OS_SPRINTF(ucMessage,
                    "***ERROR***:单独删除VPWS内BYPASS端口时，VPWS_ID=%d 的业务不存在，无法处理!\n",
                    usVpwsIdKey);
                BMU_SLOG(BMU_INFO, SPM_L2_LOG_DIR, ucMessage);

                NBB_EXCEPTION((PCT_SPM | VPWS_PD, 0, "ld d s s", usVpwsIdKey,
                        BASIC_CONFIG_NOT_EXIST,
                        "BASIC_CONFIG_NOT_EXIST",
                        ucMessage));
                        
                goto EXIT_LABEL;
            }

            /* 计算第一个entry的地址。*/
            pucBypassDataStart = (NBB_BYTE *)NTL_OFFLEN_GET_POINTER(pstSetVpws, &pstSetVpws->bypass_pw_data);

            /* 如果指针为NULL，无数据 */
            if (pucBypassDataStart == NULL)
            {
                NBB_TRC_FLOW((NBB_FORMAT "  pucBypassDataStart is NULL."));
                NBB_EXCEPTION((PCT_SPM | 7, 0, "lx", SHARED.spm_index));
            }
            else
            {
                pstBypassData = (ATG_DCI_VPWS_BYPASS_PW_DATA *)pucBypassDataStart;

                NBB_TRC_DETAIL((NBB_FORMAT "  VC ID = %ld", pstBypassData->vc_id));
                NBB_TRC_DETAIL((NBB_FORMAT "  PEER_IP = %s", spm_set_ulong_to_ipv4(pstBypassData->peer_ip NBB_CCXT)));
                NBB_TRC_DETAIL((NBB_FORMAT "  VC_TYPE = %d", pstBypassData->vc_type));
                NBB_TRC_DETAIL((NBB_FORMAT "  双归关联ID = %d", pstBypassData->dualhome_id));
                NBB_TRC_DETAIL((NBB_FORMAT "  BYPASS_DH_ID = %d", pstBypassData->bypass_dh_id));
                NBB_TRC_DETAIL((NBB_FORMAT "  NNI_NO = %d", pstBypassData->nni_no));
                
                if (vpws_cfg_print_setting == SPM_PRINT_CFG)
                {
                    printf("  4）Bypass PW配置 DEL\n");
                    spm_dbg_print_vpws_bypass_cfg(pstBypassData);
                }

                OS_SPRINTF(ucMessage, "  4）Bypass PW配置 DEL\n");
                BMU_SLOG(BMU_INFO, SPM_L2_LOG_DIR, ucMessage);
                
                //spm_dbg_record_vpws_bypass_cfg(pstBypassData);

                stBypassVcKey.vc_id = pstBypassData->vc_id;
                stBypassVcKey.vc_type = pstBypassData->vc_type;
                stBypassVcKey.peer_ip = pstBypassData->peer_ip;
				
                //如果Bypass存在，可以删除Bypass
                if (pstVpws->bypass_info_cb.vp_idx != 0)
                {
#ifdef SPU
                    ret = SUCCESS;

                    for (ucC3Unit = 0; ucC3Unit < SHARED.c3_num; ucC3Unit++)
                    {
                        ret += ApiC3DelMplsPortFromVpn(ucC3Unit,
                            L2VPN_VPWS,
                            usVpwsIdKey,
                            pstVpws->bypass_info_cb.vp_idx);
                    }

                    //成功，保存数据
                    if (ret == SUCCESS)
                    {
                        spm_get_vc_drvinfo(stBypassVcKey, &stVcDrvInfoBypassOld NBB_CCXT);
                        spm_get_vc_lspprotkey(stBypassVcKey,&st_lspprot_key_bypass NBB_CCXT);
                        
	                 //调用dk的接口获取ftnIndex
                        if (ATG_DCI_FTN == stVcDrvInfoBypassOld.lsp_option)
                        {
                        	spm_l3_delvpldp(stBypassVcKey.peer_ip, 
                        					stVcDrvInfoBypassOld.vp_idx, 
                        					stVcDrvInfoBypassOld.next_hop_id
                        					NBB_CCXT);		            
                        }
                        else if (ATG_DCI_CR_LSP == stVcDrvInfoBypassOld.lsp_option)
                        {
                        	spm_l3_delvprsvp(&st_lspprot_key_bypass, 
                        					stVcDrvInfoBypassOld.vp_idx, 
                        					stVcDrvInfoBypassOld.next_hop_id
                        					NBB_CCXT);	
                        }	
                        
                        //调用删除Bypass的保护接口
                        aps_del_bypass_vpws(pstVpws->vpws_id_key);
                        
                        //free
                        NBB_MM_FREE(pstVpws->bypass_cfg_cb, MEM_SPM_VPWS_BYPASS_CB);

                        pstVpws->bypass_cfg_cb = NULL;
                        OS_MEMSET(&pstVpws->bypass_info_cb, 0, sizeof(SPM_VPN_PORT_INFO_CB));

						
										
                        if (stVcDrvInfoBypassOld.next_hop_id != 0)
                        {
                        	spm_free_vc_nhi_id(stVcDrvInfoBypassOld.next_hop_id);
                        }

                        spm_vc_drvinfo_clear(&stBypassVcKey NBB_CCXT);

                        //如果删除成功，要把剩下的两个端口绑在一起。如果剩下两个端口就绑，如果没有端口就不绑
                        iVpNniPosId = 0;
                        iVpUniPosId = 0;

                        //找到Bypass NNI
                        for (i = 0; i < ATG_DCI_VPWS_NNI_NUM; i++)
                        {
                            if (pstVpws->nni_info_cb[i].vp_idx != 0)
                            {
                                iVpNniPosId = pstVpws->nni_info_cb[i].vp_idx;
                                break;
                            }
                        }

                        //找到Bypass UNI
                        for (i = 0; i < ATG_DCI_VPWS_UNI_NUM; i++)
                        {
                            if (pstVpws->uni_info_cb[i].vp_idx != 0)
                            {
                                iVpUniPosId = pstVpws->uni_info_cb[i].vp_idx;
                                break;
                            }
                        }

                        //如果剩下两个端口就绑，如果没有端口就不绑
                        if ((iVpNniPosId != 0) && (iVpUniPosId != 0))
                        {
                            for (ucC3Unit = 0; ucC3Unit < SHARED.c3_num; ucC3Unit++)
                            {
                                ret += ApiC3BindVp(ucC3Unit, iVpNniPosId, iVpUniPosId);

                                NBB_TRC_DETAIL((NBB_FORMAT "  ApiC3BindVp() ret=%d", ret));
                            }
                        }
                    }
                    else    //如果删除NNI口失败记录错误状态
                    {
                        pstSetVpws->bypass_pw_return_code = ATG_DCI_RC_UNSUCCESSFUL;

                        NBB_TRC_DETAIL((NBB_FORMAT
                                "  ***ERROR***: <VPWS_ID=%d> ApiC3DelMplsPortFromVpn() VPWS error! ret=%d",
                                usVpwsIdKey, ret));

                        OS_PRINTF("***ERROR***: <VPWS_ID=%d> ApiC3DelMplsPortFromVpn() ret=%d\n", usVpwsIdKey, ret);

                        OS_SPRINTF(ucMessage,
                            "***ERROR***: <VPWS_ID=%d> ApiC3DelMplsPortFromVpn() ret=%d\n",
                            usVpwsIdKey,
                            ret);
                        BMU_SLOG(BMU_INFO, SPM_L2_LOG_DIR, ucMessage);

                        NBB_EXCEPTION((PCT_SPM | VPWS_PD, 0, "ld d s s", usVpwsIdKey,
                                ret,
                                "CALL_C3_FUNC_ERROR",
                                ucMessage));
                    }
#endif
                }

            }
        }
        else if (ulOperBypass == ATG_DCI_OPER_UPDATE)
        {
            NBB_EXCEPTION((PCT_SPM | 7, 2, "lx", SHARED.spm_index));
        }

    }

EXIT_LABEL: NBB_TRC_EXIT();
	
 return;

}

/*****************************************************************************
   函 数 名  : spm_vpn_add_vp_nni
   功能描述  : 为VPWS添加一个VP(NNI)
   输入参数  : NBB_BYTE ucNniId
             NBB_ULONG ulVpwsId
             ATG_DCI_VPWS_NNI_DATA* pstNniData
   输出参数  : 无
   返 回 值  :
   调用函数  :
   被调函数  :

   修改历史      :
   1.日    期   : 2012年10月30日
    作    者   : xiaoxiang
    修改内容   : 新生成函数

*****************************************************************************/
NBB_INT spm_vpn_add_vp_nni(NBB_BYTE ucVpnType,
    NBB_USHORT usVpnId,
    NBB_USHORT usVsiMcId,
    NBB_VOID *pstNniData,
    SPM_VPN_PORT_INFO_CB *pstVpnPortInfo NBB_CCXT_T NBB_CXT)
{
    NBB_CHAR ucMessage[SPM_MSG_INFO_LEN];

    VPORT_T stNniVport;
    NBB_INT ret = SUCCESS;
    NBB_BYTE ucC3Unit = 0;
    SPM_VC_CB *pstVcMain = NULL;
    SPM_VC_CB *pstVcBack = NULL;
    ATG_DCI_VC_KEY stVcKeyMain;
    ATG_DCI_VC_KEY stVcKeyBack;
    CRTXLSP_KEY stCrLspKey;    //最新的用这个接口
    LSPPROT_KEY st_lspprot_key;  //LSPPROT  key值
    LSPPROT_KEY st_lspprot_key_back;  //LSPPROT  key值
    FTN_KEY stFtnKey;
    SPM_VP_INFO_REFRESH_CB stVpInfoRefreshMain;
    SPM_VP_INFO_REFRESH_CB stVpInfoRefreshBack;

    NBB_ULONG ulTunnelIndexMaster = 0;
    NBB_ULONG ulTunnelIndexSlave = 0;
    NBB_ULONG ulPortIndexMaster = 0;
    NBB_ULONG ulPortIndexSlave = 0;

    NBB_ULONG arPortIndexMaster[ATG_DCI_ECMP_PORT_NUM] = {0};
    NBB_ULONG arPortIndexSlave[ATG_DCI_ECMP_PORT_NUM] = {0};
    NBB_BYTE ucNniPortNum = 0;
    NBB_BYTE uc_nni_port_num_master = 0;
    NBB_BYTE uc_nni_port_num_slave = 0;

    //NBB_BYTE             ucSlot = 0;
    NBB_BYTE ucProtectFlag = 0;
    NBB_BYTE ucProtectType = 0;
    NBB_USHORT usFrrGroupId = 0;
    NBB_UINT iVpId = 0;
    NBB_UINT iNhiIdMain = 0;
    NBB_UINT iNhiIdBack = 0;
    
    NBB_UINT i = 0;
    SPM_PORT_INFO_CB stPortInfoall[ATG_DCI_ECMP_PORT_NUM]; 
    
    ATG_DCI_VPWS_NNI_DATA *pstVpwsNni = NULL;
    ATG_DCI_VPLS_NNI_DATA *pstVplsNni = NULL;

    SPM_LINEAR_PROTECT_SWITCH stLps;
    SPM_PORT_INFO_CB stPortInfoMaster;
    SPM_PORT_INFO_CB stPortInfoSlave;
    NBB_BYTE port_num_temp = 0;
    NBB_UINT nhi_temp = 0;
    NBB_UINT nhi_p_temp = 0; 
    
    NBB_TRC_ENTRY("spm_vpn_add_vp_nni");

    for(i=0;i<ATG_DCI_ECMP_PORT_NUM;i++)
    {
        OS_MEMSET(&stPortInfoall[i], 0, sizeof(SPM_PORT_INFO_CB));
    }
    
    if (pstNniData == NULL)
    {
        NBB_TRC_DETAIL((NBB_FORMAT "  ***ERROR***:spm_vpn_add_vp_nni(pstNniData==NULL)"));

        OS_PRINTF("***ERROR***:spm_vpn_add_vp_nni(pstNniData==NULL)\n");

        OS_SPRINTF(ucMessage, "***ERROR***:spm_vpn_add_vp_nni(pstNniData==NULL)\n");
        BMU_SLOG(BMU_INFO, SPM_L2_LOG_DIR, ucMessage);

        NBB_EXCEPTION((PCT_SPM | VPWS_PD, 0, "ld d s s", usVpnId,
                FUNC_IN_PARAM_IS_NULL,
                "FUNC_IN_PARAM_IS_NULL",
                ucMessage));
                
        ret = ERROR;
        goto EXIT_LABEL;
    }

    OS_MEMSET(&stNniVport, 0, sizeof(VPORT_T));
    OS_MEMSET(&stVcKeyMain, 0, sizeof(ATG_DCI_VC_KEY));
    OS_MEMSET(&stVcKeyBack, 0, sizeof(ATG_DCI_VC_KEY));
    OS_MEMSET(&stCrLspKey, 0, sizeof(CRTXLSP_KEY));
    OS_MEMSET(&st_lspprot_key, 0, sizeof(LSPPROT_KEY));
    OS_MEMSET(&st_lspprot_key_back, 0, sizeof(LSPPROT_KEY));
    OS_MEMSET(&stFtnKey, 0, sizeof(FTN_KEY));
    OS_MEMSET(&stLps, 0, sizeof(SPM_LINEAR_PROTECT_SWITCH));
    OS_MEMSET(&stPortInfoMaster, 0, sizeof(SPM_PORT_INFO_CB));
    OS_MEMSET(&stPortInfoSlave, 0, sizeof(SPM_PORT_INFO_CB));
    OS_MEMSET(&stVpInfoRefreshMain, 0, sizeof(SPM_VP_INFO_REFRESH_CB));
    OS_MEMSET(&stVpInfoRefreshBack, 0, sizeof(SPM_VP_INFO_REFRESH_CB));
    nhi_temp = pstVpnPortInfo->next_hop_id;
    nhi_p_temp = pstVpnPortInfo->next_hop_id_p;
        
    if (ucVpnType == L2VPN_VPWS)
    {
        pstVpwsNni = (ATG_DCI_VPWS_NNI_DATA *)pstNniData;

        iVpId = pstVpwsNni->nni_no;

        stVcKeyMain.vc_id = pstVpwsNni->vc_id;
        stVcKeyMain.peer_ip = pstVpwsNni->peer_ip;
        stVcKeyMain.vc_type = pstVpwsNni->vc_type;

        stVcKeyBack.vc_id = pstVpwsNni->vc_id_bak;
        stVcKeyBack.peer_ip = pstVpwsNni->peer_ip_bak;
        stVcKeyBack.vc_type = pstVpwsNni->vc_type_bak;

        stNniVport.eVpType = VP_NNI;

		stVpInfoRefreshMain.vpn_type = L2VPN_VPWS;
		stVpInfoRefreshBack.vpn_type = L2VPN_VPWS;

        ucProtectFlag = pstVpwsNni->use_protect;
        ucProtectType = pstVpwsNni->prot_type;

        stLps.revertiveType = (SPM_LPS_REVERTIVE_TYPE_E)pstVpwsNni->if_return;
        stLps.holdOffTime = pstVpwsNni->holdoff_time;
        stLps.wtrTime = pstVpwsNni->restore_time;
    }
    else if (ucVpnType == L2VPN_VPLS)
    {
        pstVplsNni = (ATG_DCI_VPLS_NNI_DATA *)pstNniData;

        iVpId = pstVplsNni->nni_no;

        stVcKeyMain.vc_id = pstVplsNni->vc_id;
        stVcKeyMain.peer_ip = pstVplsNni->peer_ip;
        stVcKeyMain.vc_type = pstVplsNni->vc_type;

        stVcKeyBack.vc_id = pstVplsNni->vc_id_bak;
        stVcKeyBack.peer_ip = pstVplsNni->peer_ip_bak;
        stVcKeyBack.vc_type = pstVplsNni->vc_type_bak;

        stNniVport.eVpType = VP_NNI;
        
		stVpInfoRefreshMain.vpn_type = L2VPN_VPLS;
		stVpInfoRefreshBack.vpn_type = L2VPN_VPLS;

        ucProtectFlag = pstVplsNni->use_protect;
        ucProtectType = pstVplsNni->prot_type;

        stLps.revertiveType = (SPM_LPS_REVERTIVE_TYPE_E)pstVplsNni->if_return;
        stLps.holdOffTime = pstVplsNni->holdoff_time;
        stLps.wtrTime = pstVplsNni->restore_time;
    }
    else
    {
        NBB_TRC_DETAIL((NBB_FORMAT "  ***ERROR***: ucVpnType=%d 不存在", ucVpnType));

        OS_PRINTF("***ERROR***: ucVpnType=%d 不存在\n", ucVpnType);

        OS_SPRINTF(ucMessage, "***ERROR***: ucVpnType=%d 不存在\n", ucVpnType);
        BMU_SLOG(BMU_INFO, SPM_L2_LOG_DIR, ucMessage);

        NBB_EXCEPTION((PCT_SPM | VPWS_PD, 0, "ld d s s", usVpnId,
                VPN_NOT_VPWS_NOR_VPLS,
                "VPN_NOT_VPWS_NOR_VPLS",
                ucMessage));
                
        ret = ERROR;
        goto EXIT_LABEL;
    }

	//如果NNI_NO为0，直接报错返回
    if (iVpId == 0)
    {
        NBB_TRC_DETAIL((NBB_FORMAT "  ***ERROR***: VPN_ID=%d ucVpnType=%d iVpId=%d ADD NNI", usVpnId, ucVpnType, iVpId));

        OS_PRINTF("***ERROR***: VPN_ID=%d ucVpnType=%d iVpId=%d ADD NNI\n", usVpnId, ucVpnType, iVpId);

        OS_SPRINTF(ucMessage, "***ERROR***: VPN_ID=%d ucVpnType=%d iVpId=%d ADD NNI\n", usVpnId, ucVpnType, iVpId);
        BMU_SLOG(BMU_INFO, SPM_L2_LOG_DIR, ucMessage);

        NBB_EXCEPTION((PCT_SPM | VPWS_PD, 0, "ld d s s", usVpnId,
                BASIC_CONFIG_NOT_EXIST,
                "BASIC_CONFIG_NOT_EXIST",
                ucMessage));
                
        ret = ERROR;
        goto EXIT_LABEL;
    }

    stNniVport.vpIdx = iVpId;
    stNniVport.mcId = usVsiMcId;

    stVpInfoRefreshMain.if_main = VC_MAIN;
	stVpInfoRefreshBack.if_main = VC_BACK;
    stVpInfoRefreshMain.vpn_id = usVpnId;
	stVpInfoRefreshBack.vpn_id = usVpnId;

    /* 获取到VC表的配置 */
    pstVcMain = AVLL_FIND(SHARED.vc_tree, &stVcKeyMain);
    pstVcBack = AVLL_FIND(SHARED.vc_tree, &stVcKeyBack);

/*
    if ((pstVcMain == NULL)
        || (pstVcMain->basic_cfg_cb == NULL)
        || ((pstVcBack != NULL) && (pstVcBack->basic_cfg_cb == NULL)))
    {
        NBB_TRC_DETAIL((NBB_FORMAT "  ***ERROR***: 主用VC不存在，主用VC基本配置不存在，或备用VC存在但基本配置不存在！"));

        OS_PRINTF("***ERROR***: 主用VC不存在，主用VC基本配置不存在，或备用VC存在但基本配置不存在！\n");

        OS_SPRINTF(ucMessage, "***ERROR***: 主用VC不存在，主用VC基本配置不存在，或备用VC存在但基本配置不存在！\n");
        BMU_SLOG(BMU_INFO, SPM_L2_LOG_DIR, ucMessage);

        NBB_EXCEPTION((PCT_SPM | VPWS_PD, 0, "ld d s s", usVpnId,
                VC_NOT_MASTER_NOR_SLAVE,
                "VC_NOT_MASTER_NOR_SLAVE",
                ucMessage));
                
        ret = ERROR;
        goto EXIT_LABEL;
    }
*/

    //主用配置
	if ((pstVcMain != NULL) && (pstVcMain->basic_cfg_cb != NULL))
	{
	    stVpInfoRefreshMain.vc_key.vc_id = stVcKeyMain.vc_id;
	    stVpInfoRefreshMain.vc_key.vc_type = stVcKeyMain.vc_type;
	    stVpInfoRefreshMain.vc_key.peer_ip = stVcKeyMain.peer_ip;

	    //VLAN 接收TAG识别
	    if (pstVcMain->basic_cfg_cb->recv_action == ATG_DCI_TAGGED_VLAN)
	    {
	        stNniVport.flags |= VPORT_PTAG_IDENTIFY_ON;
	    }

	    //VLAN 发送TAG行为 主用
	    switch (pstVcMain->basic_cfg_cb->send_tag_action)
	    {
	        case ATG_DCI_ADD_VID_PRI:
	            stNniVport.tNextHop.eEgrPtagAction = EGR_ENCAP;
	            break;
	        case ATG_DCI_DEL_VID_PRI:
	            stNniVport.tNextHop.eEgrPtagAction = EGR_NO_ENCAP;
	            break;
	        default:
	        	break;
	    }
	    
	    stNniVport.tNextHop.egrPtagVlan = pstVcMain->basic_cfg_cb->send_vlan_id;
	    stNniVport.tNextHop.egrPtagPri = pstVcMain->basic_cfg_cb->send_vlan_pri;

	    if (pstVcMain->basic_cfg_cb->tag_type == 0x8100)
	    {
	        stNniVport.tNextHop.eEgrPtagTpidType = TPID_0X8100;
	    }
	    else if (pstVcMain->basic_cfg_cb->tag_type == 0x88a8)
	    {
	        stNniVport.tNextHop.eEgrPtagTpidType = TPID_0X88A8;
	    }

        if((0 == pstVcMain->basic_cfg_cb->pw_in_label) || (3 == pstVcMain->basic_cfg_cb->pw_in_label))
        {
            NBB_TRC_DETAIL((NBB_FORMAT "  ***ERROR***: MainVc_in_label=%d", pstVcMain->basic_cfg_cb->pw_in_label));

            OS_PRINTF("***ERROR***: MainVc_in_label=%d\n", pstVcMain->basic_cfg_cb->pw_in_label);

            OS_SPRINTF(ucMessage, "***ERROR***: MainVc_in_label=%d\n", pstVcMain->basic_cfg_cb->pw_in_label);
            BMU_SLOG(BMU_INFO, SPM_L2_LOG_DIR, ucMessage);

            ret = ERROR;
            goto EXIT_LABEL;                  
        }
        
	    stNniVport.matchVcLabel = pstVcMain->basic_cfg_cb->pw_in_label;

	    stNniVport.tNextHop.flags |= L2_NEXT_HOP_ENCAP_TUNNEL;

        //if (pstVcMain->vc_info_cb.next_hop_id != 0)
        if (0 != pstVpnPortInfo->next_hop_id)
        {
        	//stNniVport.tNextHop.nhIdx = pstVcMain->vc_info_cb.next_hop_id;
        	stNniVport.tNextHop.nhIdx = pstVpnPortInfo->next_hop_id;
        }
        else
        {
        	spm_alloc_vc_nhi_id(&iNhiIdMain NBB_CCXT);
        	stNniVport.tNextHop.nhIdx = iNhiIdMain;
        }

	    stNniVport.tNextHop.tPwLabel.label_un.tlabel.label = pstVcMain->basic_cfg_cb->pw_out_label;
	    stNniVport.tNextHop.tPwLabel.label_un.tlabel.bottom = 1;
	    stNniVport.tNextHop.tPwLabel.label_un.tlabel.ttl = 255; //协议里面需要定义 todo

	    //调用dk的接口获取ftnIndex
	    if (pstVcMain->basic_cfg_cb->lsp_option == ATG_DCI_FTN)
	    {
	        stFtnKey.fec = pstVcMain->basic_cfg_cb->next_hop_ip;
	        stFtnKey.mask = 32;
	        stFtnKey.vrfid = 0;

	        ret = spm_l3_ldpforoam(&stFtnKey, &ulPortIndexMaster, &ulTunnelIndexMaster NBB_CCXT);

	        if (ret != SUCCESS)
	        {
	            NBB_TRC_DETAIL((NBB_FORMAT "  ***ERROR***: spm_l3_ldpforoam() error! ret=%d", ret));

	            OS_PRINTF("***ERROR***: spm_l3_ldpforoam() ret=%d\n", ret);

	            OS_SPRINTF(ucMessage, "***ERROR***: spm_l3_ldpforoam() ret=%d\n", ret);
	            BMU_SLOG(BMU_INFO, SPM_L2_LOG_DIR, ucMessage);

	            NBB_EXCEPTION((PCT_SPM | VPWS_PD, 0, "ld d s s", usVpnId,
	                    ret,
	                    "CALL_FUNC_ERROR",
	                    ucMessage));
	                    
	            spm_vc_drvinfo_clear(&stVcKeyMain NBB_CCXT);
                
	            //spm_vc_drvinfo_clear(&stVcKeyBack NBB_CCXT);

	            goto EXIT_LABEL;
	        }

	        uc_nni_port_num_master = 0;
	        ret = spm_l3_ldpallport(&stFtnKey, arPortIndexMaster, &uc_nni_port_num_master NBB_CCXT);

	        if (ret != SUCCESS)
	        {
	            NBB_TRC_DETAIL((NBB_FORMAT "  ***ERROR***: spm_l3_ldpallport() error! ret=%d", ret));

	            OS_PRINTF("***ERROR***: spm_l3_ldpallport() ret=%d\n", ret);

	            OS_SPRINTF(ucMessage, "***ERROR***: spm_l3_ldpallport() ret=%d\n", ret);
	            BMU_SLOG(BMU_INFO, SPM_L2_LOG_DIR, ucMessage);

	            NBB_EXCEPTION((PCT_SPM | VPWS_PD, 0, "ld d s s", usVpnId,
	                    ret,
	                    "CALL_FUNC_ERROR",
	                    ucMessage));
	        }
	    }
	    else if (pstVcMain->basic_cfg_cb->lsp_option == ATG_DCI_CR_LSP)
	    {
	        stCrLspKey.ingress = pstVcMain->basic_cfg_cb->ingress;
	        stCrLspKey.egress = pstVcMain->basic_cfg_cb->egress;
	        stCrLspKey.tunnelid = pstVcMain->basic_cfg_cb->tunnel_id;
	        stCrLspKey.lspid = 0;
	        st_lspprot_key.ingress  = pstVcMain->basic_cfg_cb->ingress;
	        st_lspprot_key.egress   = pstVcMain->basic_cfg_cb->egress;
	        st_lspprot_key.tunnelid = pstVcMain->basic_cfg_cb->tunnel_id;
	        ret = spm_l3_rsvpforoam(&stCrLspKey, &ulPortIndexMaster, &ulTunnelIndexMaster NBB_CCXT);    //用新接口替代

	        if (ret != SUCCESS)
	        {
	            NBB_TRC_DETAIL((NBB_FORMAT "  ***ERROR***: spm_l3_rsvpforoam() error! ret=%d", ret));

	            OS_PRINTF("***ERROR***: spm_l3_rsvpforoam() ret=%d\n", ret);

	            OS_SPRINTF(ucMessage, "***ERROR***: spm_l3_rsvpforoam() ret=%d\n", ret);
	            BMU_SLOG(BMU_INFO, SPM_L2_LOG_DIR, ucMessage);

	            NBB_EXCEPTION((PCT_SPM | VPWS_PD, 0, "ld d s s", usVpnId,
	                    ret,
	                    "CALL_FUNC_ERROR",
	                    ucMessage));
	                    
	            spm_vc_drvinfo_clear(&stVcKeyMain NBB_CCXT);
                
	            //spm_vc_drvinfo_clear(&stVcKeyBack NBB_CCXT);

	            goto EXIT_LABEL;
	        }

		 uc_nni_port_num_master = 0;
		 ret = spm_l3_rsvpallport(&stCrLspKey, arPortIndexMaster, &uc_nni_port_num_master NBB_CCXT);

	        if (ret != SUCCESS)
	        {
	            NBB_TRC_DETAIL((NBB_FORMAT "  ***ERROR***: spm_l3_rsvpallport() error! ret=%d", ret));

	            OS_PRINTF("***ERROR***: spm_l3_rsvpallport() ret=%d\n", ret);

	            OS_SPRINTF(ucMessage, "***ERROR***: spm_l3_rsvpallport() ret=%d\n", ret);
	            BMU_SLOG(BMU_INFO, SPM_L2_LOG_DIR, ucMessage);

	            NBB_EXCEPTION((PCT_SPM | VPWS_PD, 0, "ld d s s", usVpnId,
	                    ret,
	                    "CALL_FUNC_ERROR",
	                    ucMessage));
	        }
	    }
	    else
	    {
	        NBB_TRC_DETAIL((NBB_FORMAT "  ***ERROR***: 主用VC LSP选择 未配置"));

	        OS_PRINTF("***ERROR***: 主用VC LSP选择 未配置\n");

	        OS_SPRINTF(ucMessage, "***ERROR***: 主用VC LSP选择 未配置\n");
	        BMU_SLOG(BMU_INFO, SPM_L2_LOG_DIR, ucMessage);

	        NBB_EXCEPTION((PCT_SPM | VPWS_PD, 0, "ld d s s", usVpnId,
	                BASIC_CONFIG_NOT_EXIST,
	                "BASIC_CONFIG_NOT_EXIST",
	                ucMessage));
	                
	        spm_vc_drvinfo_clear(&stVcKeyMain NBB_CCXT);
	        spm_vc_drvinfo_clear(&stVcKeyBack NBB_CCXT);

			ret = ERROR;
	        goto EXIT_LABEL;
	    }

	    pstVcMain->vc_info_cb.port_index = ulPortIndexMaster;
	    stNniVport.tNextHop.tunnelIdx = ulTunnelIndexMaster;

	    NBB_TRC_DETAIL((NBB_FORMAT "  ulFtnIndexMaster=%d ulPortIndexMaster=%d", ulTunnelIndexMaster, ulPortIndexMaster));

	    //给主用保护配置
	    spm_get_portid_from_logical_port_index(ulPortIndexMaster, &stPortInfoMaster NBB_CCXT);
	    //stLps.workEntity.portIndex = ulPortIndexMaster;
	    stLps.workEntity.portIndex = 0;
	    stLps.workEntity.tpId = 0;
	    stLps.workEntity.type = 1;
	    stLps.workEntity.vckey.vc_id = stVcKeyMain.vc_id;
	    stLps.workEntity.vckey.vc_type = stVcKeyMain.vc_type;
	    stLps.workEntity.vckey.peer_ip = stVcKeyMain.peer_ip;

	    //控制字使能。
	    if (pstVcMain->basic_cfg_cb->control_word_enable == ENABLE)
	    {
	        stNniVport.flags |= VPORT_CW_SN;
	        stNniVport.tNextHop.eCwMode = EGR_CW_SEQ;
	    }

	    //如果是VPLS业务，需要配置MCA学习和水平分割
	    if (ucVpnType == L2VPN_VPLS)
	    {
	        //MAC学习开关
	        if (pstVcMain->basic_cfg_cb->mac_learning_enable == DISABLE)
	        {
	            stNniVport.flags |= VPORT_LEARN_DISABLE;
	        }

	        //水平分割开关
	        if (pstVcMain->basic_cfg_cb->split_horizon_enable == ENABLE)
	        {
	            stNniVport.flags |= VPORT_NETWORK;
	        }

			//IGMP
			if (pstVplsNni != NULL)
			{
		        stNniVport.igmpId = pstVplsNni->virtual_index;
			}
	    }
	}

    //备用配置
    if ((ucProtectFlag == 1) && (pstVcBack != NULL) && (pstVcBack->basic_cfg_cb != NULL))
    {
        stVpInfoRefreshBack.vc_key.vc_id = stVcKeyBack.vc_id;
    	stVpInfoRefreshBack.vc_key.vc_type = stVcKeyBack.vc_type;
    	stVpInfoRefreshBack.vc_key.peer_ip = stVcKeyBack.peer_ip;

	    //VLAN 接收TAG识别
	    if (pstVcBack->basic_cfg_cb->recv_action == ATG_DCI_TAGGED_VLAN)
	    {
	        stNniVport.flags |= VPORT_BACKUP_PTAG_IDENTIFY_ON;
	    }
	    
        //VLAN 发送TAG行为 备用
        switch (pstVcBack->basic_cfg_cb->send_tag_action)
        {
            case ATG_DCI_ADD_VID_PRI:
                stNniVport.tNextHop_p.eEgrPtagAction = EGR_ENCAP;
                break;
            case ATG_DCI_DEL_VID_PRI:
                stNniVport.tNextHop_p.eEgrPtagAction = EGR_NO_ENCAP;
                break;
            default:
            break;
        }

        stNniVport.tNextHop_p.egrPtagVlan = pstVcBack->basic_cfg_cb->send_vlan_id;
        stNniVport.tNextHop_p.egrPtagPri = pstVcBack->basic_cfg_cb->send_vlan_pri;

        if (pstVcBack->basic_cfg_cb->tag_type == 0x8100)
        {
            stNniVport.tNextHop_p.eEgrPtagTpidType = TPID_0X8100;
        }
        else if (pstVcBack->basic_cfg_cb->tag_type == 0x88a8)
        {
            stNniVport.tNextHop_p.eEgrPtagTpidType = TPID_0X88A8;
        }
        
        if((0 == pstVcBack->basic_cfg_cb->pw_in_label) || (3 == pstVcBack->basic_cfg_cb->pw_in_label))
        {
            NBB_TRC_DETAIL((NBB_FORMAT "  ***ERROR***: BackVc_in_label=%d", pstVcBack->basic_cfg_cb->pw_in_label));

            OS_PRINTF("***ERROR***: BackVc_in_label=%d\n", pstVcBack->basic_cfg_cb->pw_in_label);

            OS_SPRINTF(ucMessage, "***ERROR***: BackVc_in_label=%d\n", pstVcBack->basic_cfg_cb->pw_in_label);
            BMU_SLOG(BMU_INFO, SPM_L2_LOG_DIR, ucMessage);

            ret = ERROR;
            goto EXIT_LABEL;                  
        }
        
        stNniVport.matchVcLabel_p = pstVcBack->basic_cfg_cb->pw_in_label;

        stNniVport.tNextHop_p.flags |= L2_NEXT_HOP_ENCAP_TUNNEL;

        //if (pstVcBack->vc_info_cb.next_hop_id != 0)
        if (0 != pstVpnPortInfo->next_hop_id_p)
        {
        	//stNniVport.tNextHop_p.nhIdx = pstVcBack->vc_info_cb.next_hop_id;
        	stNniVport.tNextHop_p.nhIdx = pstVpnPortInfo->next_hop_id_p;
        }
        else
        {
        	spm_alloc_vc_nhi_id(&iNhiIdBack NBB_CCXT);
        	stNniVport.tNextHop_p.nhIdx = iNhiIdBack;
        }

        stNniVport.tNextHop_p.tPwLabel.label_un.tlabel.label = pstVcBack->basic_cfg_cb->pw_out_label;
        stNniVport.tNextHop_p.tPwLabel.label_un.tlabel.bottom = 1;
        stNniVport.tNextHop_p.tPwLabel.label_un.tlabel.ttl = 255;  //协议里面需要定义 todo

        if (pstVcBack->basic_cfg_cb->lsp_option == ATG_DCI_FTN)
        {
            stFtnKey.fec = pstVcBack->basic_cfg_cb->next_hop_ip;
            stFtnKey.mask = 32;
            stFtnKey.vrfid = 0;

            ret = spm_l3_ldpforoam(&stFtnKey, &ulPortIndexSlave, &ulTunnelIndexSlave NBB_CCXT);

            if (ret != SUCCESS)
            {
                NBB_TRC_DETAIL((NBB_FORMAT "  ***ERROR***: spm_l3_ldpforoam() error! ret=%d", ret));

                OS_PRINTF("***ERROR***: spm_l3_ldpforoam() ret=%d\n", ret);

                OS_SPRINTF(ucMessage, "***ERROR***: spm_l3_ldpforoam() ret=%d\n", ret);
                BMU_SLOG(BMU_INFO, SPM_L2_LOG_DIR, ucMessage);

                NBB_EXCEPTION((PCT_SPM | VPWS_PD, 0, "ld d s s", usVpnId,
                        ret,
                        "CALL_FUNC_ERROR",
                        ucMessage));
                        
                //spm_vc_drvinfo_clear(&stVcKeyMain NBB_CCXT);
                spm_vc_drvinfo_clear(&stVcKeyBack NBB_CCXT);

                goto EXIT_LABEL;
            }

		 uc_nni_port_num_slave = 0;
	        ret = spm_l3_ldpallport(&stFtnKey, arPortIndexSlave, &uc_nni_port_num_slave NBB_CCXT);

	        if (ret != SUCCESS)
	        {
	            NBB_TRC_DETAIL((NBB_FORMAT "  ***ERROR***: spm_l3_ldpallport() error! ret=%d", ret));

	            OS_PRINTF("***ERROR***: spm_l3_ldpallport() ret=%d\n", ret);

	            OS_SPRINTF(ucMessage, "***ERROR***: spm_l3_ldpallport() ret=%d\n", ret);
	            BMU_SLOG(BMU_INFO, SPM_L2_LOG_DIR, ucMessage);

	            NBB_EXCEPTION((PCT_SPM | VPWS_PD, 0, "ld d s s", usVpnId,
	                    ret,
	                    "CALL_FUNC_ERROR",
	                    ucMessage));
	        }
        }
        else if (pstVcBack->basic_cfg_cb->lsp_option == ATG_DCI_CR_LSP)
        {
            //调用dk的接口获取ftn_index? todo
            stCrLspKey.ingress = pstVcBack->basic_cfg_cb->ingress;
            stCrLspKey.egress = pstVcBack->basic_cfg_cb->egress;
            stCrLspKey.tunnelid = pstVcBack->basic_cfg_cb->tunnel_id;
            stCrLspKey.lspid = 0;
	     st_lspprot_key_back.ingress  = pstVcBack->basic_cfg_cb->ingress;
	     st_lspprot_key_back.egress   = pstVcBack->basic_cfg_cb->egress;
	     st_lspprot_key_back.tunnelid = pstVcBack->basic_cfg_cb->tunnel_id;
            ret = spm_l3_rsvpforoam(&stCrLspKey, &ulPortIndexSlave, &ulTunnelIndexSlave NBB_CCXT);    //用新接口替代

            if (ret != SUCCESS)
            {
                NBB_TRC_DETAIL((NBB_FORMAT "  ***ERROR***: spm_l3_rsvpforoam() error! ret=%d", ret));

                OS_PRINTF("***ERROR***: spm_l3_rsvpforoam() ret=%d\n", ret);

                OS_SPRINTF(ucMessage, "***ERROR***: spm_l3_rsvpforoam() ret=%d\n", ret);
                BMU_SLOG(BMU_INFO, SPM_L2_LOG_DIR, ucMessage);

                NBB_EXCEPTION((PCT_SPM | VPWS_PD, 0, "ld d s s", usVpnId,
                        ret,
                        "CALL_FUNC_ERROR",
                        ucMessage));
                        
                //spm_vc_drvinfo_clear(&stVcKeyMain NBB_CCXT);
                spm_vc_drvinfo_clear(&stVcKeyBack NBB_CCXT);

                goto EXIT_LABEL;
            }

			uc_nni_port_num_slave = 0;
			ret = spm_l3_rsvpallport(&stCrLspKey, arPortIndexSlave, &uc_nni_port_num_slave NBB_CCXT);

	        if (ret != SUCCESS)
	        {
	            NBB_TRC_DETAIL((NBB_FORMAT "  ***ERROR***: spm_l3_rsvpallport() error! ret=%d", ret));

	            OS_PRINTF("***ERROR***: spm_l3_rsvpallport() ret=%d\n", ret);

	            OS_SPRINTF(ucMessage, "***ERROR***: spm_l3_rsvpallport() ret=%d\n", ret);
	            BMU_SLOG(BMU_INFO, SPM_L2_LOG_DIR, ucMessage);

	            NBB_EXCEPTION((PCT_SPM | VPWS_PD, 0, "ld d s s", usVpnId,
	                    ret,
	                    "CALL_FUNC_ERROR",
	                    ucMessage));
	        }
        }
        else
        {
            NBB_TRC_DETAIL((NBB_FORMAT "  ***ERROR***: 备用VC LSP选择 未配置"));

            OS_PRINTF("***ERROR***: 备用VC LSP选择 未配置\n");

            OS_SPRINTF(ucMessage, "***ERROR***: 备用VC LSP选择 未配置\n");
            BMU_SLOG(BMU_INFO, SPM_L2_LOG_DIR, ucMessage);

            NBB_EXCEPTION((PCT_SPM | VPWS_PD, 0, "ld d s s", usVpnId,
                    BASIC_CONFIG_NOT_EXIST,
                    "BASIC_CONFIG_NOT_EXIST",
                    ucMessage));
                    
            spm_vc_drvinfo_clear(&stVcKeyMain NBB_CCXT);
            spm_vc_drvinfo_clear(&stVcKeyBack NBB_CCXT);

            ret = ERROR;
            goto EXIT_LABEL;
        }

        pstVcBack->vc_info_cb.port_index = ulPortIndexSlave;
        stNniVport.tNextHop_p.tunnelIdx = ulTunnelIndexSlave;

        NBB_TRC_DETAIL((NBB_FORMAT "  ulFtnIndexSlave=%d  ulPortIndexSlave=%d", ulTunnelIndexSlave, ulPortIndexSlave));

        //给备用保护配置
        spm_get_portid_from_logical_port_index(ulPortIndexSlave, &stPortInfoSlave NBB_CCXT);
        //stLps.protEntity.portIndex = ulPortIndexSlave;
        stLps.protEntity.portIndex = 0;
		stLps.protEntity.tpId = 0;
        stLps.protEntity.type = 1;
        stLps.protEntity.vckey.vc_id = stVcKeyBack.vc_id;
        stLps.protEntity.vckey.vc_type = stVcKeyBack.vc_type;
        stLps.protEntity.vckey.peer_ip = stVcKeyBack.peer_ip;

	    //控制字使能。
	    if (pstVcBack->basic_cfg_cb->control_word_enable == ENABLE)
	    {
	        stNniVport.flags |= VPORT_CW_SN;
	        stNniVport.tNextHop_p.eCwMode = EGR_CW_SEQ;
	    }

	    //如果是VPLS业务，需要配置MCA学习和水平分割
	    if (ucVpnType == L2VPN_VPLS)
	    {
	        //MAC学习开关
	        if (pstVcBack->basic_cfg_cb->mac_learning_enable == DISABLE)
	        {
	            stNniVport.flags |= VPORT_LEARN_DISABLE;
	        }

	        //水平分割开关
	        if (pstVcBack->basic_cfg_cb->split_horizon_enable == ENABLE)
	        {
	            stNniVport.flags |= VPORT_NETWORK;
	        }

			//IGMP
			if (pstVplsNni != NULL)
			{
		        stNniVport.igmpId = pstVplsNni->virtual_index;
			}
	    }
	    
        //如果配置PW冗余保护
        if (ucProtectType == ATG_DCI_PW_PROT_1B1)
        {
            stNniVport.eProtType = VP_NHI_FRR;
        }
        if (ucProtectType == 4)
        {
            stNniVport.eProtType = VP_NHI_FRR;
        }

#ifdef SPU
        ret = SUCCESS;

		//1、如果vp_idx等于0，是新增，需要创建group_id
		//2、或: vp_idx不等于0，且更新前的group_id也为0，需要创建group_id
        if ((pstVpnPortInfo->vp_idx == 0) 
         || ((pstVpnPortInfo->vp_idx != 0) && (pstVpnPortInfo->frr_group_id == 0)))
        {
            for (ucC3Unit = 0; ucC3Unit < SHARED.c3_num; ucC3Unit++)
            {
                ret += ApiC3CreateFrrGroup(ucC3Unit, &usFrrGroupId, 0, 0);
            }

            if (ret == SUCCESS)
            {
                stNniVport.frrGroupId = usFrrGroupId;
                NBB_TRC_DETAIL((NBB_FORMAT "usFrrGroupId=%d", stNniVport.frrGroupId));

                stLps.protType = FRR_TYPE;
                stLps.protGroupId = usFrrGroupId;
                stLps.lpsType = FRR_1B1;
                if (ucProtectType == 4)
                {
                    stLps.lpsType = FRR_UNIDIR;
                    stLps.vpId = iVpId;
                }
            }
            else
            {
                if ((pstVcMain != NULL) && (pstVcMain->basic_cfg_cb != NULL))
                {
                    NBB_TRC_DETAIL((NBB_FORMAT 
                        "***ERROR***: ApiC3CreateFrrGroup() ret=%d mvcid=%u peeip=%s bvcid=%u peeip=%s", 
                        ret,stVcKeyMain.vc_id,spm_set_ulong_to_ipv4(stVcKeyMain.peer_ip NBB_CCXT),
                        stVcKeyBack.vc_id,spm_set_ulong_to_ipv4(stVcKeyBack.peer_ip NBB_CCXT)));

                    OS_SPRINTF(ucMessage, "***ERROR***: ApiC3CreateFrrGroup() ret=%d mvcid=%u peeip=%s bvcid=%u peeip=%s\n", 
                        ret,stVcKeyMain.vc_id,spm_set_ulong_to_ipv4(stVcKeyMain.peer_ip NBB_CCXT),
                        stVcKeyBack.vc_id,spm_set_ulong_to_ipv4(stVcKeyBack.peer_ip NBB_CCXT));
                    BMU_SLOG(BMU_INFO, SPM_L2_LOG_DIR, ucMessage);

                    NBB_EXCEPTION((PCT_SPM | VPWS_PD, 0, "ld d s s", usVpnId,
                    ret,
                    "CALL_C3_FUNC_ERROR",
                    "ApiC3CreateFrrGroup()"));
                }
                
                if (pstVcMain == NULL) 
                {
                    NBB_TRC_DETAIL((NBB_FORMAT "***ERROR***: ApiC3CreateFrrGroup() ret=%d bvcid=%u peeip=%s", 
                        ret,stVcKeyBack.vc_id,spm_set_ulong_to_ipv4(stVcKeyBack.peer_ip NBB_CCXT)));

                    OS_SPRINTF(ucMessage, "***ERROR***: ApiC3CreateFrrGroup() ret=%d bvcid=%u peeip=%s\n", 
                        ret,stVcKeyBack.vc_id,spm_set_ulong_to_ipv4(stVcKeyBack.peer_ip NBB_CCXT));
                    BMU_SLOG(BMU_INFO, SPM_L2_LOG_DIR, ucMessage);

                    NBB_EXCEPTION((PCT_SPM | VPWS_PD, 0, "ld d s s", usVpnId,
                    ret,
                    "CALL_C3_FUNC_ERROR",
                    "ApiC3CreateFrrGroup()"));
                }
            }
        }
        else
        {
            stNniVport.frrGroupId = pstVpnPortInfo->frr_group_id;
            stLps.protType = FRR_TYPE;
            stLps.protGroupId = pstVpnPortInfo->frr_group_id;
            stLps.lpsType = FRR_1B1;
            if (ucProtectType == 4)
            {
                stLps.lpsType = FRR_UNIDIR;	
                stLps.vpId = iVpId;
            }
        }

#endif
    }
    
#ifdef SPU

    //上次有保护本次无保护
    if ((ucProtectFlag == 0) && (pstVpnPortInfo->vp_idx != 0) && (pstVpnPortInfo->frr_group_id != 0))
    {
        for(ucC3Unit = 0; ucC3Unit < SHARED.c3_num; ucC3Unit++)
        {
            ret += ApiC3DeleteFrrGroup(ucC3Unit, pstVpnPortInfo->frr_group_id);
        }

        if(ret != SUCCESS)
        {
            NBB_TRC_DETAIL((NBB_FORMAT "***ERROR***: ApiC3DeleteFrrGroup() last error! ret=%d", ret));

            OS_SPRINTF(ucMessage, "***ERROR***: ApiC3DeleteFrrGroup() last !ret=%d usVpnId=%d\n", ret, usVpnId);
            BMU_SLOG(BMU_INFO, SPM_L2_LOG_DIR, ucMessage);

            NBB_EXCEPTION((PCT_SPM | VPWS_PD, 0, "ld d s s", usVpnId,
            ret,
            "CALL_C3_FUNC_ERROR",
            "ApiC3DeleteFrrGroup()"));
        }
    }
#endif

/*
	//如果主用VC不存在，备用VC存在，必须把备用的配置赋给主用保护模块
    if (((pstVcMain == NULL) || (pstVcMain->basic_cfg_cb == NULL))
    	&& ((pstVcBack != NULL) && (pstVcBack->basic_cfg_cb != NULL)))
	{
	    stLps.workEntity.portIndex = 0;
	    stLps.workEntity.tpId = 0;
	    stLps.workEntity.type = 1;
	    stLps.workEntity.vckey.vc_id = stVcKeyBack.vc_id;
	    stLps.workEntity.vckey.vc_type = stVcKeyBack.vc_type;
	    stLps.workEntity.vckey.peer_ip = stVcKeyBack.peer_ip;
	}
*/
    //如果主用vc不存在，要置工作实体的vc删除标志位
    if ((pstVcMain == NULL) || (pstVcMain->basic_cfg_cb == NULL))
    {
        stLps.workEntity.vcDelFlag = 1;
    }

    //如果备用vc不存在，要置保护实体的vc删除标志位
    if ((pstVcBack == NULL) || (pstVcBack->basic_cfg_cb == NULL))
    {
        stLps.protEntity.vcDelFlag = 1;
    }

    //设置包计数等标志
    //stNniVport.flags |= VPORT_COUNTER_ON;

    //stNniVport.tNextHop.flags |= L2_NEXT_HOP_COUNTER_ON;
    //stNniVport.tNextHop_p.flags |= L2_NEXT_HOP_COUNTER_ON;

    ret = SUCCESS;

#ifdef SPU

    if (pstVpnPortInfo->vp_idx == 0)
    {
        //调用API函数进行配置，将VP加入到VPN中
        for (ucC3Unit = 0; ucC3Unit < SHARED.c3_num; ucC3Unit++)
        {
            ret += ApiC3AddMplsPortToVpn(ucC3Unit, ucVpnType, usVpnId, &stNniVport);
            NBB_TRC_DETAIL((NBB_FORMAT "  ApiAddMplsPortToVpn[NNI]:  ret=%d", ret));
        }
    }
    else
    {
        //调用API函数进行配置，更新VP
        stNniVport.vpIdx = pstVpnPortInfo->vp_idx;

        for (ucC3Unit = 0; ucC3Unit < SHARED.c3_num; ucC3Unit++)
        {
            ret += ApiC3ModVp(ucC3Unit, &stNniVport);
            NBB_TRC_DETAIL((NBB_FORMAT "  ApiC3ModVp[NNI]:  ret=%d", ret));
        }
    }
#endif

    if (ret == SUCCESS)
    {
        //如果配置了保护，且group_id不为0
    	if ((ucProtectFlag == 1) && (stLps.protGroupId != 0))
    	{
    		spm_lps_add_entity(&stLps);
    	}

    	//如果上次配置了保护，本次没有配置保护，要调用保护删除的接口
    	if ((pstVpnPortInfo->frr_group_id != 0) && (ucProtectFlag == 0))
    	{
    		spm_lps_del_entity(FRR_TYPE, pstVpnPortInfo->frr_group_id);
    	}

    	pstVpnPortInfo->vp_idx = stNniVport.vpIdx;
    	pstVpnPortInfo->frr_group_id = stNniVport.frrGroupId;

        //更新下一跳ID
        pstVpnPortInfo->next_hop_id = stNniVport.tNextHop.nhIdx;
        pstVpnPortInfo->next_hop_id_p = stNniVport.tNextHop_p.nhIdx;

        //传入时不为0，更新后为0的下一跳ID要释放
        //回收next_hop_id
        if ((0 == pstVpnPortInfo->next_hop_id) && (0 != nhi_temp))
        {
        	spm_free_vc_nhi_id(nhi_temp NBB_CCXT);
        }
                
        if ((0 == pstVpnPortInfo->next_hop_id_p) && (0 != nhi_p_temp))
        {
        	spm_free_vc_nhi_id(nhi_p_temp NBB_CCXT);
            
        }
        
    	if ((pstVcMain != NULL) && (pstVcMain->basic_cfg_cb != NULL))
    	{	    	
	        pstVcMain->vc_info_cb.vp_idx = stNniVport.vpIdx;

	        pstVcMain->vc_info_cb.next_hop_counter_id = stNniVport.tNextHop.counterIdx;
            
	        pstVcMain->vc_info_cb.next_hop_id = stNniVport.tNextHop.nhIdx;
            
	        pstVcMain->vc_info_cb.frr_group_id = stNniVport.frrGroupId;
		    pstVcMain->vc_info_cb.vpn_id = usVpnId;
		    pstVcMain->vc_info_cb.vpn_type = ucVpnType;
		    pstVcMain->vc_info_cb.if_main = VC_MAIN;
		    //pstVcMain->vc_info_cb.port_index = ulPortIndexMaster;
	    	pstVcMain->vc_info_cb.port_id = stPortInfoMaster.port_id;
              pstVcMain->vc_info_cb.drv_tunnel_id = stNniVport.tNextHop.tunnelIdx;
              pstVcMain->vc_info_cb.lsp_option = pstVcMain->basic_cfg_cb->lsp_option;

	        pstVpnPortInfo->port_index = ulPortIndexMaster;	        
	        pstVpnPortInfo->port_type = stPortInfoMaster.port_type;
	        pstVpnPortInfo->port_num = uc_nni_port_num_master;

	        OS_MEMCPY(pstVpnPortInfo->port_index_mc, arPortIndexMaster, 
                   sizeof(NBB_ULONG) * ATG_DCI_ECMP_PORT_NUM);

               if(ATG_DCI_ECMP_PORT_NUM >= pstVpnPortInfo->port_num)
               {
                    port_num_temp = pstVpnPortInfo->port_num;
               }
               else
               {
                    port_num_temp = ATG_DCI_ECMP_PORT_NUM;
               }
               
               //增加ECMP端口驱动返回信息
               //for(i = 0;i < pstVpnPortInfo->port_num;i++)
               for(i = 0;i < port_num_temp;i++)
               {               
                    //获取VP所对应所有端口
                    spm_get_portid_from_logical_port_index(pstVpnPortInfo->port_index_mc[i], 
                        &stPortInfoall[i] NBB_CCXT);
                    if (stPortInfoall[i].port_type == ATG_DCI_LAG)
        	        {
        	        	pstVpnPortInfo->slot_id_mc[i] = stPortInfoall[i].lag_slot_id;
        	        	pstVpnPortInfo->port_id_mc[i] = stPortInfoall[i].lag_port_id;   
                            pstVpnPortInfo->port_type_mc[i] = stPortInfoall[i].port_type; 
        	        }
        	        else
        	        {
        	        	pstVpnPortInfo->slot_id_mc[i] = stPortInfoall[i].slot_id;
        	        	pstVpnPortInfo->port_id_mc[i] = stPortInfoall[i].port_id;   
                            pstVpnPortInfo->port_type_mc[i] = stPortInfoall[i].port_type;
        	        }
               }

	        if (stPortInfoMaster.port_type == ATG_DCI_LAG)
	        {
	        	pstVpnPortInfo->slot_id = stPortInfoMaster.lag_slot_id;
	        	pstVcMain->vc_info_cb.slot_id = stPortInfoMaster.lag_slot_id;        	
	        }
	        else
	        {
	        	pstVpnPortInfo->slot_id = stPortInfoMaster.slot_id;
	        	pstVcMain->vc_info_cb.slot_id = stPortInfoMaster.slot_id;
	        }

	        if (pstVcMain->basic_cfg_cb->lsp_option == ATG_DCI_FTN)
	        {
	            //调用dk接口，传vpid与tunnelid的对应关系
	            spm_l3_addvpldp(&stVpInfoRefreshMain, stNniVport.vpIdx, 
	                stNniVport.tNextHop.nhIdx, stNniVport.tNextHop.tunnelIdx NBB_CCXT); 
	        }
	        else if (ATG_DCI_CR_LSP == pstVcMain->basic_cfg_cb->lsp_option)
	        {
	            //20160104 调用dk接口，传vpid与tunnelid的对应关系
	            spm_l3_addvprsvp(&stVpInfoRefreshMain, stNniVport.vpIdx, 
	                stNniVport.tNextHop.nhIdx,&st_lspprot_key, 
	                stNniVport.tNextHop.tunnelIdx NBB_CCXT); 
	        }				
    	}
		
        if ((pstVcBack != NULL) && (pstVcBack->basic_cfg_cb != NULL))
        {
            pstVcBack->vc_info_cb.vp_idx = stNniVport.vpIdx;

            pstVcBack->vc_info_cb.next_hop_counter_id = stNniVport.tNextHop_p.counterIdx;
            
            pstVcBack->vc_info_cb.next_hop_id = stNniVport.tNextHop_p.nhIdx;

            pstVcBack->vc_info_cb.frr_group_id = stNniVport.frrGroupId;
	        pstVcBack->vc_info_cb.vpn_id = usVpnId;
	        pstVcBack->vc_info_cb.vpn_type = ucVpnType;
	        pstVcBack->vc_info_cb.if_main = VC_BACK;
	        //pstVcBack->vc_info_cb.port_index = ulPortIndexSlave;
        	pstVcBack->vc_info_cb.port_id = stPortInfoSlave.port_id;        	
              pstVcBack->vc_info_cb.drv_tunnel_id = stNniVport.tNextHop_p.tunnelIdx;
              pstVcBack->vc_info_cb.lsp_option = pstVcBack->basic_cfg_cb->lsp_option;
              
        	if (stPortInfoSlave.port_type == ATG_DCI_LAG)
        	{
        		pstVcBack->vc_info_cb.slot_id = stPortInfoSlave.lag_slot_id;
        	}
        	else
        	{
        		pstVcBack->vc_info_cb.slot_id = stPortInfoSlave.slot_id;
        	}

		if (pstVcBack->basic_cfg_cb->lsp_option == ATG_DCI_FTN)
		{
		    //调用dk接口，传vpid与tunnelid的对应关系
		    spm_l3_addvpldp(&stVpInfoRefreshBack, stNniVport.vpIdx, 
		    stNniVport.tNextHop_p.nhIdx, stNniVport.tNextHop_p.tunnelIdx NBB_CCXT);
		}
		else if (ATG_DCI_CR_LSP == pstVcBack->basic_cfg_cb->lsp_option)
		{
		    //20160104 调用dk接口，传vpid与tunnelid的对应关系
		    spm_l3_addvprsvp(&stVpInfoRefreshBack, stNniVport.vpIdx, 
		        stNniVport.tNextHop_p.nhIdx,&st_lspprot_key_back, 
		        stNniVport.tNextHop_p.tunnelIdx NBB_CCXT); 
		}			
        }

        //如果主VC不存在，备VC存在，VP的出口就要刷成备用出口
        if ((pstVcMain == NULL) && (pstVcBack != NULL))
        {
	        pstVpnPortInfo->port_index = ulPortIndexSlave;	        
	        pstVpnPortInfo->port_type = stPortInfoSlave.port_type;
               pstVpnPortInfo->port_num = uc_nni_port_num_slave;
               
	        OS_MEMCPY(pstVpnPortInfo->port_index_mc, arPortIndexSlave, 
                   sizeof(NBB_ULONG) * ATG_DCI_ECMP_PORT_NUM);

               if(ATG_DCI_ECMP_PORT_NUM >= pstVpnPortInfo->port_num)
               {
                    port_num_temp = pstVpnPortInfo->port_num;
               }
               else
               {
                    port_num_temp = ATG_DCI_ECMP_PORT_NUM;
               }
               
               //增加ECMP端口驱动返回信息
               //for(i = 0;i < pstVpnPortInfo->port_num;i++)
               for(i = 0;i < port_num_temp;i++)
               {               
                    //获取VP所对应所有端口
                    spm_get_portid_from_logical_port_index(pstVpnPortInfo->port_index_mc[i], 
                        &stPortInfoall[i] NBB_CCXT);
                    if (stPortInfoall[i].port_type == ATG_DCI_LAG)
        	        {
        	        	pstVpnPortInfo->slot_id_mc[i] = stPortInfoall[i].lag_slot_id;
        	        	pstVpnPortInfo->port_id_mc[i] = stPortInfoall[i].lag_port_id;   
                            pstVpnPortInfo->port_type_mc[i] = stPortInfoall[i].port_type; 
        	        }
        	        else
        	        {
        	        	pstVpnPortInfo->slot_id_mc[i] = stPortInfoall[i].slot_id;
        	        	pstVpnPortInfo->port_id_mc[i] = stPortInfoall[i].port_id;   
                            pstVpnPortInfo->port_type_mc[i] = stPortInfoall[i].port_type;
        	        }
               }
               
	        if (stPortInfoSlave.port_type == ATG_DCI_LAG)
	        {
	        	pstVpnPortInfo->slot_id = stPortInfoSlave.lag_slot_id;       	
	        }
	        else
	        {
	        	pstVpnPortInfo->slot_id = stPortInfoSlave.slot_id;
	        }
#ifdef SPU
	        //强行倒换到备用
	        for (ucC3Unit = 0; ucC3Unit < SHARED.c3_num; ucC3Unit++)
	        {
	        	ApiC3SetFrrGroupStatus(ucC3Unit, stNniVport.frrGroupId, 1);
	        }
#endif
        }

		//如果是vpls，记录组播ID
		if ((ucVpnType == L2VPN_VPLS) && (pstVcMain != NULL) && (pstVcMain->basic_cfg_cb != NULL))
		{
		    stFtnKey.fec = pstVcMain->basic_cfg_cb->next_hop_ip;
            stFtnKey.mask = 32;
            stFtnKey.vrfid = 0;
            
        	spm_l3_add_mcid_ldp(usVpnId, usVsiMcId, ATG_DCI_FTN, stFtnKey, stCrLspKey, ulPortIndexMaster NBB_CCXT);
		}
    }
    else
    {
    	//coverity[dead_error_begin]
        NBB_EXCEPTION((PCT_SPM | VPWS_PD, 0, "ld d s s", usVpnId,
                ret,
                "CALL_C3_FUNC_ERROR",
                ucMessage));
        
        if (pstVpnPortInfo->vp_idx == 0)
        {
            NBB_TRC_DETAIL((NBB_FORMAT "  ***ERROR***:ApiAddMplsPortToVpn:  ret=%d", ret));

            OS_PRINTF("***ERROR***:ApiAddMplsPortToVpn:  ret=%d\n", ret);

            OS_SPRINTF(ucMessage, "***ERROR***:ApiAddMplsPortToVpn:  ret=%d\n", ret);
            BMU_SLOG(BMU_INFO, SPM_L2_LOG_DIR, ucMessage);
        }
        else
        {
             NBB_TRC_DETAIL((NBB_FORMAT "  ***ERROR***:ApiC3ModVp:  ret=%d", ret));

            OS_PRINTF("***ERROR***:ApiC3ModVp:  ret=%d\n", ret);

            OS_SPRINTF(ucMessage, "***ERROR***:ApiC3ModVp:  ret=%d\n", ret);
            BMU_SLOG(BMU_INFO, SPM_L2_LOG_DIR, ucMessage);       
        }
            
        if ((pstVcMain != NULL) && (pstVcMain->basic_cfg_cb != NULL))
        {
            NBB_TRC_DETAIL((NBB_FORMAT "mvcid=%u peeip=%s", 
                stVcKeyMain.vc_id,spm_set_ulong_to_ipv4(stVcKeyMain.peer_ip NBB_CCXT)));

            OS_SPRINTF(ucMessage, "mvcid=%u peeip=%s\n", 
                stVcKeyMain.vc_id,spm_set_ulong_to_ipv4(stVcKeyMain.peer_ip NBB_CCXT));
            BMU_SLOG(BMU_INFO, SPM_L2_LOG_DIR, ucMessage);
        }
        
        if ((ucProtectFlag == 1) && (pstVcBack != NULL) && (pstVcBack->basic_cfg_cb != NULL))
        {
            NBB_TRC_DETAIL((NBB_FORMAT "bvcid=%u peeip=%s", 
                stVcKeyBack.vc_id,spm_set_ulong_to_ipv4(stVcKeyBack.peer_ip NBB_CCXT)));

            OS_SPRINTF(ucMessage, "bvcid=%u peeip=%s\n", 
                stVcKeyBack.vc_id,spm_set_ulong_to_ipv4(stVcKeyBack.peer_ip NBB_CCXT));
            BMU_SLOG(BMU_INFO, SPM_L2_LOG_DIR, ucMessage);
        }

        //新建VP不成功要回收next_hop_id，修改不成功不能回收
        if (pstVpnPortInfo->vp_idx == 0)
        {
        	if (iNhiIdMain != 0)
        	{
        		spm_free_vc_nhi_id(iNhiIdMain NBB_CCXT);
        	}

        	if (iNhiIdBack != 0)
        	{
        		spm_free_vc_nhi_id(iNhiIdBack NBB_CCXT);
        	}
        }
        
        goto EXIT_LABEL;
    }


#if 0
    /**************************************************************************/
    /*                             增加VC Diff-Serv                           */
    /**************************************************************************/
    if (pstVcMain->diff_serv_cfg_cb != NULL)
    {
        ret = spm_ds_add_vc_node(pstVcMain->diff_serv_cfg_cb->diff_serv_id,
            &stVcKeyMain,
            pstVcMain->vc_info_cb.vp_idx,
            pstVcMain->vc_info_cb.if_main);

        if (ret == SUCCESS)
        {
            pstVcMain->vc_info_cb.if_qos = ATG_DCI_USED;
        }
    }

    //如果备用存在，且QoS配置存在
    if ((pstVcBack != NULL) && (pstVcBack->diff_serv_cfg_cb != NULL))
    {
        ret = spm_ds_add_vc_node(pstVcBack->diff_serv_cfg_cb->diff_serv_id,
            &stVcKeyBack,
            pstVcBack->vc_info_cb.vp_idx,
            pstVcBack->vc_info_cb.if_main);

        if (ret == SUCCESS)
        {
            pstVcBack->vc_info_cb.if_qos = ATG_DCI_USED;
        }
    }

    /**************************************************************************/
    /*                          上话VPN QOS策略配置                           */
    /**************************************************************************/
    if (pstVcMain->up_vpn_cfg_cb != NULL)
    {
        stCrLspKey.ingress = pstVcMain->basic_cfg_cb->ingress;
        stCrLspKey.egress = pstVcMain->basic_cfg_cb->egress;
        stCrLspKey.tunnelid = pstVcMain->basic_cfg_cb->tunnel_id;
        stCrLspKey.lspid = 0;

        ret = spm_hqos_add_vc_node(stPortInfoMaster.slot_id,
            stPortInfoMaster.port_id,
            pstVcMain->vc_info_cb.vp_idx,
            pstVcMain->vc_info_cb.if_main,
            &stCrLspKey,
            &stVcKeyMain,
            pstVcMain->up_vpn_cfg_cb);

        if (ret == SUCCESS)
        {
            pstVcMain->vc_info_cb.if_qos = ATG_DCI_USED;
        }
    }

    //如果备用存在，且QoS配置存在
    if ((pstVcBack != NULL) && (pstVcBack->up_vpn_cfg_cb != NULL))
    {
        stCrLspKey.ingress = pstVcBack->basic_cfg_cb->ingress;
        stCrLspKey.egress = pstVcBack->basic_cfg_cb->egress;
        stCrLspKey.tunnelid = pstVcBack->basic_cfg_cb->tunnel_id;
        stCrLspKey.lspid = 0;

        ret = spm_hqos_add_vc_node(stPortInfoSlave.slot_id,
            stPortInfoSlave.port_id,
            pstVcBack->vc_info_cb.vp_idx,
            pstVcBack->vc_info_cb.if_main,
            &stCrLspKey,
            &stVcKeyBack,
            pstVcBack->up_vpn_cfg_cb);

        if (ret == SUCCESS)
        {
            pstVcMain->vc_info_cb.if_qos = ATG_DCI_USED;
        }
    }
#endif

EXIT_LABEL: NBB_TRC_EXIT();

    return ret;
}

/*****************************************************************************
   函 数 名  : spm_vpn_add_vp_uni
   功能描述  : 为VPWS添加一个VP(UNI)
   输入参数  : NBB_BYTE ucUniId
             NBB_ULONG ulVpwsId
             ATG_DCI_VPWS_UNI_DATA* pstUniData
   输出参数  : 无
   返 回 值  :
   调用函数  :
   被调函数  :

   修改历史      :
   1.日    期   : 2012年10月30日
    作    者   : xiaoxiang
    修改内容   : 新生成函数

*****************************************************************************/
NBB_INT spm_vpn_add_vp_uni(NBB_BYTE ucVpnType,
    NBB_USHORT usVpnId,
    NBB_USHORT usVsiMcId,
    NBB_VOID *pstUniData,
    SPM_VPN_PORT_INFO_CB *pstVpnPortInfo NBB_CCXT_T NBB_CXT)
{
    NBB_CHAR ucMessage[SPM_MSG_INFO_LEN];

    NBB_INT ret = SUCCESS;
    NBB_BYTE ucLocalSlot = 0;
    NBB_BYTE ucC3Unit = 0;
    NBB_ULONG ulLogicalPortIndex = 0;
    NBB_ULONG ulLogicalPortIndexBack = 0;
    NBB_ULONG ulMspId = 0;
    NBB_USHORT usVpPosId = 0;
    NBB_USHORT i = 0;
    NBB_USHORT usFlowId = 0;
    VPORT_T stUniVport;
    INTF_T stIntfFlow;
    SPM_PORT_INFO_CB stPortInfo;
    SPM_PORT_INFO_CB stMspBackPortInfo;

    SPM_LOGICAL_PORT_CB *pstLogicalPort = NULL;
    SPM_LOGICAL_PORT_CB *pstLogicalPortBack = NULL;
    SPM_PHYSICAL_PORT_CB *pstPhysicalPort = NULL;
    SPM_TERMINAL_IF_CB *pstTerminalIfCb = NULL;
    SPM_MSP_CB *pstMsp = NULL;

    ATG_DCI_VPWS_UNI_DATA *pstVpwsUni;
    ATG_DCI_VPLS_UNI_DATA *pstVplsUni;

    //SPM_QOS_LOGIC_FLOW_KEY stQosFlowKey;

	NBB_UINT iNhiId = 0;
	NBB_UINT iVpId = 0;
    SUB_PORT stSubPort;
    NBB_ULONG backininderectPhykey = 0;

    SPM_FLOW_DIFF_SERV_CB *pstflowdiffservcb = NULL;  
    SPM_INCLASSIFY_QOS_CB *pstinclassifyqoscb = NULL;     
    SPM_TRAFFIC_FILTER_CB *psttrafficfiltercb = NULL; 
    
    //ATG_DCI_LOG_PORT_DS_L2_DATA *pstdsl2data = NULL; 
    
    //QoS结构体
    SPM_QOS_LOGIC_FLOW_KEY stqosflowkey;
    
    //SPM_QOS_LOGIC_INTF_KEY stqosintfkey;
    SPM_QOS_LOGIC_UNIVP stunivp;
    
    ATG_DCI_LOG_PORT_FLOW_DIFF_SERV pstflowdiffservdata ;
    ATG_DCI_LOG_PORT_TRAFFIC_FILTER psttrafficfilterdata ;
    ATG_DCI_LOG_PORT_INCLASSIFY_QOS pstinclassifyqosdata;
    NBB_UINT logic_port_info_cb_vp_idx_temp = 0;
    NBB_ULONG intf_pos_id_temp = 0; 

    NBB_TRC_ENTRY("spm_vpws_add_vp_uni");

    if (pstUniData == NULL)
    {
        NBB_TRC_DETAIL((NBB_FORMAT "  ***ERROR***:spm_vpn_add_vp_uni(pstUniData==NULL)"));

        OS_PRINTF("***ERROR***:spm_vpn_add_vp_uni(pstUniData==NULL)\n");

        OS_SPRINTF(ucMessage, "***ERROR***:spm_vpn_add_vp_uni(pstUniData==NULL)\n");
        BMU_SLOG(BMU_INFO, SPM_L2_LOG_DIR, ucMessage);

        NBB_EXCEPTION((PCT_SPM | VPWS_PD, 0, "ld d s s", usVpnId,
                FUNC_IN_PARAM_IS_NULL,
                "FUNC_IN_PARAM_IS_NULL",
                ucMessage));
                
        ret = ERROR;
        goto EXIT_LABEL;
    }

    //初始化结构t_vport_uni todo
    OS_MEMSET(&stUniVport, 0, sizeof(VPORT_T));
    OS_MEMSET(&stPortInfo, 0, sizeof(SPM_PORT_INFO_CB));
    OS_MEMSET(&stMspBackPortInfo, 0, sizeof(SPM_PORT_INFO_CB));
    OS_MEMSET(&stSubPort, 0, sizeof(SUB_PORT));
    OS_MEMSET(&stqosflowkey, 0, sizeof(SPM_QOS_LOGIC_FLOW_KEY));
    OS_MEMSET(&stunivp, 0, sizeof(SPM_QOS_LOGIC_UNIVP));
    OS_MEMSET(&pstflowdiffservdata, 0, sizeof(ATG_DCI_LOG_PORT_FLOW_DIFF_SERV));
    OS_MEMSET(&psttrafficfilterdata, 0, sizeof(ATG_DCI_LOG_PORT_TRAFFIC_FILTER));
    OS_MEMSET(&pstinclassifyqosdata, 0, sizeof(ATG_DCI_LOG_PORT_INCLASSIFY_QOS));  

    if (ucVpnType == L2VPN_VPWS)
    {
        pstVpwsUni = (ATG_DCI_VPWS_UNI_DATA *)pstUniData;

        ulLogicalPortIndex = pstVpwsUni->port_index;
        
        //ulLogicalPortIndexBack = pstVpwsUni->slave_port_index;
        //ulMspId = pstVpwsUni->msp_id;
        stUniVport.vpIdx = pstVpwsUni->uni_no;
        iVpId = pstVpwsUni->uni_no;
    }
    else if (ucVpnType == L2VPN_VPLS)
    {
        pstVplsUni = (ATG_DCI_VPLS_UNI_DATA *)pstUniData;

        ulLogicalPortIndex = pstVplsUni->port_index;
//        ulLogicalPortIndexBack = pstVplsUni->slave_port_index;
//        ulMspId = pstVplsUni->msp_id;
        stUniVport.vpIdx = pstVplsUni->uni_no;
        iVpId = pstVplsUni->uni_no;
    }

	//如果UNI_NO为0，直接报错返回
    if (iVpId == 0)
    {
        NBB_TRC_DETAIL((NBB_FORMAT "  ***ERROR***: VPN_ID=%d ucVpnType=%d iVpId=%d ADD UNI", usVpnId, ucVpnType, iVpId));

        OS_PRINTF("***ERROR***: VPN_ID=%d ucVpnType=%d iVpId=%d ADD UNI\n", usVpnId, ucVpnType, iVpId);

        OS_SPRINTF(ucMessage, "***ERROR***: VPN_ID=%d ucVpnType=%d iVpId=%d ADD UNI\n", usVpnId, ucVpnType, iVpId);
        BMU_SLOG(BMU_INFO, SPM_L2_LOG_DIR, ucMessage);

        NBB_EXCEPTION((PCT_SPM | VPWS_PD, 0, "ld d s s", usVpnId,
                BASIC_CONFIG_NOT_EXIST,
                "BASIC_CONFIG_NOT_EXIST",
                ucMessage));
                
        ret = ERROR;
        goto EXIT_LABEL;
    }

    stUniVport.mcId = usVsiMcId;

    pstLogicalPort = AVLL_FIND(SHARED.logical_port_tree, &ulLogicalPortIndex);

    //如果未找到逻辑口配置，退出
    if (pstLogicalPort == NULL)
    {
        NBB_TRC_DETAIL((NBB_FORMAT "  ***ERROR***:PORT_INDEX=%ld 的逻辑端口未找到", ulLogicalPortIndex));

        OS_PRINTF("***ERROR***:PORT_INDEX=%ld 的逻辑端口未找到!\n", ulLogicalPortIndex);

        OS_SPRINTF(ucMessage, "***ERROR***:PORT_INDEX=%ld 的逻辑端口未找到!\n", ulLogicalPortIndex);
        BMU_SLOG(BMU_INFO, SPM_L2_LOG_DIR, ucMessage);

        NBB_EXCEPTION((PCT_SPM | VPWS_PD, 0, "ld d s s", usVpnId,
                LOGICAL_PORT_NOT_EXIST,
                "LOGICAL_PORT_NOT_EXIST",
                ucMessage));
                
        ret = ERROR;
        goto EXIT_LABEL;
    }

    //如果逻辑接口的 基本配置 物理配置 或 逻辑配置L2不存在，直接退出
    if ((pstLogicalPort->basic_cfg_cb == NULL)
        || (pstLogicalPort->phy_cfg_cb == NULL)
        || (pstLogicalPort->logic_l2_cfg_cb == NULL))
    {
        NBB_TRC_DETAIL((NBB_FORMAT "  ***ERROR***:逻辑接口[%ld]的基本配置、物理配置或逻辑配置L2不存在",
                ulLogicalPortIndex));

        OS_PRINTF("***ERROR***:逻辑接口[%ld]的基本配置、物理配置或逻辑配置L2不存在\n", ulLogicalPortIndex);

        OS_SPRINTF(ucMessage, "***ERROR***:逻辑接口[%ld]的基本配置、物理配置或逻辑配置L2不存在\n", ulLogicalPortIndex);
        BMU_SLOG(BMU_INFO, SPM_L2_LOG_DIR, ucMessage);

        NBB_EXCEPTION((PCT_SPM | VPWS_PD, 0, "ld d s s", usVpnId,
                BASIC_CONFIG_NOT_EXIST,
                "BASIC_CONFIG_NOT_EXIST",
                ucMessage));
                
        ret = ERROR;
        goto EXIT_LABEL;
    }

    //物理接口 或 子接口
    if ((pstLogicalPort->basic_cfg_cb->port_sub_type == ATG_DCI_SUB_INTFACE)
        || (pstLogicalPort->basic_cfg_cb->port_sub_type == ATG_DCI_INTFACE))
    {
        //通过逻辑口找物理口
        pstPhysicalPort = AVLL_FIND(SHARED.physical_port_tree, &pstLogicalPort->phy_cfg_cb->phy_port_index);

        //如果未找到物理口配置，退出
        if (pstPhysicalPort == NULL)
        {
            NBB_TRC_DETAIL((NBB_FORMAT "  ***ERROR***:PORT_INDEX=%ld 的物理端口未找到\n",
                    pstLogicalPort->phy_cfg_cb->phy_port_index));

            OS_PRINTF("***ERROR***:PORT_INDEX=%ld 的物理端口未找到!\n", pstLogicalPort->phy_cfg_cb->phy_port_index);

            OS_SPRINTF(ucMessage,
                "***ERROR***:PORT_INDEX=%ld 的物理端口未找到!\n",
                pstLogicalPort->phy_cfg_cb->phy_port_index);
            BMU_SLOG(BMU_INFO, SPM_L2_LOG_DIR, ucMessage);

            NBB_EXCEPTION((PCT_SPM | VPWS_PD, 0, "ld d s s", usVpnId,
                    PHYSICAL_PORT_NOT_EXIST,
                    "PHYSICAL_PORT_NOT_EXIST",
                    ucMessage));
                    
            ret = ERROR;
            goto EXIT_LABEL;
        }
        
        if (ucVpnType == L2VPN_VPWS)
        {
        
 #ifdef SPU  
            spm_get_uni_ces_mspinfo(pstPhysicalPort,&ulMspId,&stMspBackPortInfo,&backininderectPhykey);

            //用于打印显示所绑定的mspid
            pstVpwsUni->msp_id = ulMspId;
            pstVpwsUni->slave_port_index = backininderectPhykey;
            
            //传递MSP保护配置给保护模块
            //spm_set_aps_msp_prot_group(ulMspId);

            //每次添加新业务时调用一次，重新进行drop状态的初始化
            //aps_set_lmsp_drop_state (ulMspId);
            
  #endif
  
        }
        
        spm_get_portid_from_physical_port_index(pstLogicalPort->phy_cfg_cb->phy_port_index,
            &stPortInfo NBB_CCXT);
    }

    //虚拟以太网接口
    else if (pstLogicalPort->basic_cfg_cb->port_sub_type == ATG_DCI_VE_PORT)
    {
        stPortInfo.port_id = pstLogicalPort->phy_cfg_cb->ve_group_id; //todo
        stPortInfo.slot_id = pstLogicalPort->phy_cfg_cb->ve_slot;
        stUniVport.tNextHop.flags |= L2_NEXT_HOP_VEPORT;
    }

    //LAG
    else if (pstLogicalPort->basic_cfg_cb->port_sub_type == ATG_DCI_LAG)
    {
        //spm_get_portid_from_logical_port_index(ulLogicalPortIndex, &stPortInfoTmp);
        stPortInfo.port_id = pstLogicalPort->phy_cfg_cb->lag_id + ATG_DCI_LAG_OFFSET;
        //stPortInfo.lag_slot_id = stPortInfoTmp.lag_slot_id;
    }

    //VLAN 发送TAG行为
    switch (pstLogicalPort->logic_l2_cfg_cb->send_tag_action)
    {
        case ATG_DCI_ADD_VID_PRI:
            stUniVport.tNextHop.eEgrPtagAction = EGR_ENCAP;
            break;
        case ATG_DCI_DEL_VID_PRI:
            stUniVport.tNextHop.eEgrPtagAction = EGR_NO_ENCAP;
            break;
        default:
        	break;
    }

    stUniVport.tNextHop.egrPtagVlan = pstLogicalPort->logic_l2_cfg_cb->send_vlan_id;
    stUniVport.tNextHop.egrPtagPri = pstLogicalPort->logic_l2_cfg_cb->send_vlan_pri;

    if (pstLogicalPort->logic_l2_cfg_cb->tagtype == 0x8100)
    {
        stUniVport.tNextHop.eEgrPtagTpidType = TPID_0X8100;
    }
    else if (pstLogicalPort->logic_l2_cfg_cb->tagtype == 0x88a8)
    {
        stUniVport.tNextHop.eEgrPtagTpidType = TPID_0X88A8;
    }

    stUniVport.tNextHop.tTxPort.port = stPortInfo.port_id;
    stUniVport.tNextHop.tTxPort.slot = stPortInfo.slot_id;  //todo

    //如果UNI口为CES类型
    if (pstLogicalPort->basic_cfg_cb->port_flag == ATG_DCI_CES)
    {
        stUniVport.eVpType = VP_CES;
        stUniVport.matchVcLabel = pstLogicalPort->phy_cfg_cb->phy_port_index;
        stUniVport.tNextHop.tPwLabel.label_un.tlabel.label = pstLogicalPort->phy_cfg_cb->phy_port_index;
        stUniVport.tNextHop.tPwLabel.label_un.tlabel.bottom = 1;
        stUniVport.tNextHop.tPwLabel.label_un.tlabel.ttl = 255; //协议里面需要定义 todo
        stUniVport.tNextHop.flags |= L2_NEXT_HOP_CES;
        stUniVport.tNextHop.eCwMode = EGR_CW_ORIGINAL;

		//如果备用端口不为0，且msp_id不为0，配置msp保护
       // if ((ulLogicalPortIndexBack != 0) && (ulMspId != 0))
       //coverity[dead_error_condition]
        if (ulMspId != 0) 
        {
                  /*  
                  pstLogicalPortBack = AVLL_FIND(SHARED.logical_port_tree, &ulLogicalPortIndexBack);

		   
		    if ((pstLogicalPortBack == NULL) 
		     || (pstLogicalPortBack->phy_cfg_cb == NULL) 
		     || (pstLogicalPortBack->logic_l2_cfg_cb == NULL))
		    {
		        NBB_TRC_DETAIL((NBB_FORMAT "  ***ERROR***:备用PORT_INDEX=%ld 的逻辑端口未找到", ulLogicalPortIndexBack));

		        OS_PRINTF("***ERROR***:备用PORT_INDEX=%ld 的逻辑端口未找到!\n", ulLogicalPortIndexBack);

		        OS_SPRINTF(ucMessage, "***ERROR***:备用PORT_INDEX=%ld 的逻辑端口未找到!\n", ulLogicalPortIndexBack);
		        BMU_SLOG(BMU_INFO, SPM_L2_LOG_DIR, ucMessage);

		        NBB_EXCEPTION((PCT_SPM | VPWS_PD, 0, "ld d s s", usVpnId,
		                LOGICAL_PORT_NOT_EXIST,
		                "LOGICAL_PORT_NOT_EXIST",
		                ucMessage));
		                
		        ret = ERROR;
		        goto EXIT_LABEL;
		    }

	        spm_get_portid_from_physical_port_index(pstLogicalPortBack->phy_cfg_cb->phy_port_index,
	            &stMspBackPortInfo NBB_CCXT);*/

		    if (pstLogicalPort->logic_port_info_cb.p_next_hop_id != 0)
		    {
		    	stUniVport.tNextHop_p.nhIdx = pstLogicalPort->logic_port_info_cb.p_next_hop_id;
		    }
		    else
		    {
		    	spm_alloc_vc_nhi_id(&iNhiId NBB_CCXT);
		    	stUniVport.tNextHop_p.nhIdx = iNhiId;
                  
		    }
    
		 //备用CES
		 //stUniVport.tNextHop_p.nhIdx = iNhiId;
               stUniVport.matchVcLabel_p = backininderectPhykey;
	        stUniVport.tNextHop_p.tPwLabel.label_un.tlabel.label = backininderectPhykey;
	        stUniVport.tNextHop_p.tPwLabel.label_un.tlabel.bottom = 1;
	        stUniVport.tNextHop_p.tPwLabel.label_un.tlabel.ttl = 255; //协议里面需要定义 todo
	        stUniVport.tNextHop_p.flags |= L2_NEXT_HOP_CES;
	        stUniVport.tNextHop_p.eCwMode = EGR_CW_ORIGINAL;

		    //备用VLAN 发送TAG行为
		    /*switch (pstLogicalPortBack->logic_l2_cfg_cb->send_tag_action)
		    {
		        case ATG_DCI_ADD_VID_PRI:
		            stUniVport.tNextHop_p.eEgrPtagAction = EGR_ENCAP;
		            break;
		        case ATG_DCI_DEL_VID_PRI:
		            stUniVport.tNextHop_p.eEgrPtagAction = EGR_NO_ENCAP;
		            break;
		        default:
		        	break;
		    }*/
                  stUniVport.tNextHop_p.eEgrPtagAction = stUniVport.tNextHop.eEgrPtagAction;
		    stUniVport.tNextHop_p.egrPtagVlan = pstLogicalPort->logic_l2_cfg_cb->send_vlan_id;
		    stUniVport.tNextHop_p.egrPtagPri = pstLogicalPort->logic_l2_cfg_cb->send_vlan_pri;
            
                  /*
		    if (pstLogicalPortBack->logic_l2_cfg_cb->tagtype == 0x8100)
		    {
		        stUniVport.tNextHop_p.eEgrPtagTpidType = TPID_0X8100;
		    }
		    else if (pstLogicalPortBack->logic_l2_cfg_cb->tagtype == 0x88a8)
		    {
		        stUniVport.tNextHop_p.eEgrPtagTpidType = TPID_0X88A8;
		    }*/
                  stUniVport.tNextHop_p.eEgrPtagTpidType = stUniVport.tNextHop.eEgrPtagTpidType;

		    stUniVport.tNextHop_p.tTxPort.port = stMspBackPortInfo.port_id;
		    stUniVport.tNextHop_p.tTxPort.slot = stMspBackPortInfo.slot_id;  //todo
    
			//传入申请好的固定group_id
	        stUniVport.frrGroupId = SHARED.msp_frr_group_id[ulMspId - 1];

	        //如果MSP配置已配，给出保护类型，如果未配置，设为FRR保护，后续在配置MSP时反刷保护类型
	        pstMsp = AVLL_FIND(SHARED.msp_tree, &ulMspId);

	        if ((pstMsp != NULL) && (pstMsp->basic_cfg_cb != NULL))
	        {
	        	//msp 1+1
	        	if ((pstMsp->basic_cfg_cb->prot_type == ATG_DCI_MSP_UNI_LINK_1J1_PROT)
	        	 || (pstMsp->basic_cfg_cb->prot_type == ATG_DCI_MSP_BI_LINK_1J1_PROT))
	        	{
	        		stUniVport.eProtType = VP_NHI_1PLUS1;
	        	}
	        	//msp 1:1
	        	else if ((pstMsp->basic_cfg_cb->prot_type == ATG_DCI_MSP_UNI_LINK_1B1_PROT)
	        	 	  || (pstMsp->basic_cfg_cb->prot_type == ATG_DCI_MSP_BI_LINK_1B1_PROT))
	        	{
	        		stUniVport.eProtType = VP_NHI_FRR;
	        	}
	        	else
	        	{
	        		stUniVport.eProtType = VP_NHI_GROUP;
	        	}
	        }
	        else
	        {
	        	stUniVport.eProtType = VP_NHI_GROUP;
	        }
        }
    }
    else
    {
        stUniVport.eVpType = VP_UNI;

        //如果是VE口，要置VE标致位
        if (pstLogicalPort->basic_cfg_cb->port_sub_type == ATG_DCI_VE_PORT)
        {
            stUniVport.tNextHop.flags |= L2_NEXT_HOP_VEPORT;
        }
        else
        {
            stUniVport.tNextHop.flags |= L2_NEXT_HOP_INTF;
        }
    }

    //如果是VPLS业务，需要配置MCA学习和水平分割
    if (ucVpnType == L2VPN_VPLS)
    {
        //MAC学习开关
        if (pstLogicalPort->logic_l2_cfg_cb->mac_learning_enable == DISABLE)
        {
            stUniVport.flags |= VPORT_LEARN_DISABLE;
        }

        //水平分割开关
        if (pstLogicalPort->logic_l2_cfg_cb->split_horizon_enable == ENABLE)
        {
            stUniVport.flags |= VPORT_NETWORK;
        }
    }

    if (pstLogicalPort->logic_port_info_cb.next_hop_id != 0)
    {
    	stUniVport.tNextHop.nhIdx = pstLogicalPort->logic_port_info_cb.next_hop_id;
    }
    else
    {
    	spm_alloc_vc_nhi_id(&iNhiId NBB_CCXT);
    	stUniVport.tNextHop.nhIdx = iNhiId;
    }

    ret = SUCCESS;

	//新建UNI
    if (pstVpnPortInfo->vp_idx == 0)
    {

#ifdef SPU
        //调用API函数进行配置
        for (ucC3Unit = 0; ucC3Unit < SHARED.c3_num; ucC3Unit++)
        {
            ret += ApiC3AddMplsPortToVpn(ucC3Unit, ucVpnType, usVpnId, &stUniVport);
            NBB_TRC_DETAIL((NBB_FORMAT "  ApiAddMplsPortToVpn[UNI]:  ret=%d", ret));
        }


        if (ret == SUCCESS)
        {
            usVpPosId = stUniVport.vpIdx;
            pstLogicalPort->logic_port_info_cb.vp_idx = stUniVport.vpIdx;

            pstLogicalPort->logic_port_info_cb.next_hop_counter_id = stUniVport.tNextHop.counterIdx;
            pstLogicalPort->logic_port_info_cb.vpn_type = ucVpnType;
            pstLogicalPort->logic_port_info_cb.vpn_id = usVpnId;
            pstLogicalPort->logic_port_info_cb.next_hop_id = stUniVport.tNextHop.nhIdx;

            pstVpnPortInfo->vp_idx = stUniVport.vpIdx;
            pstVpnPortInfo->port_index = ulLogicalPortIndex;

            if (stPortInfo.port_type == ATG_DCI_LAG)
            {
            	pstVpnPortInfo->slot_id = stPortInfo.lag_slot_id;
            }
            else
            {
            	pstVpnPortInfo->slot_id = stPortInfo.slot_id;
            }

			/*if (pstLogicalPortBack != NULL)
			{
	            pstLogicalPortBack->logic_port_info_cb.vp_idx = stUniVport.vpIdx;

	            pstLogicalPortBack->logic_port_info_cb.next_hop_counter_id = stUniVport.tNextHop_p.counterIdx;
	            pstLogicalPortBack->logic_port_info_cb.vpn_type = ucVpnType;
	            pstLogicalPortBack->logic_port_info_cb.vpn_id = usVpnId;
	            pstLogicalPortBack->logic_port_info_cb.next_hop_id = stUniVport.tNextHop_p.nhIdx;
			}*/
            NBB_TRC_DETAIL((NBB_FORMAT "  vp_idx=%d  vpn_type=%d  vpn_id=%d",
                    pstLogicalPort->logic_port_info_cb.vp_idx,
                    pstLogicalPort->logic_port_info_cb.vpn_type,
                    pstLogicalPort->logic_port_info_cb.vpn_id));
        }
        else
        {
            NBB_TRC_DETAIL((NBB_FORMAT "  ***ERROR***:ApiC3AddMplsPortToVpn:  ret=%d PortIndex=%u", ret,ulLogicalPortIndex));

            OS_PRINTF("***ERROR***:ApiC3AddMplsPortToVpn:  ret=%d PortIndex=%u\n", ret,ulLogicalPortIndex);

            OS_SPRINTF(ucMessage, "***ERROR***:ApiC3AddMplsPortToVpn:  ret=%d PortIndex=%u\n", ret,ulLogicalPortIndex);
            BMU_SLOG(BMU_INFO, SPM_L2_LOG_DIR, ucMessage);

            NBB_EXCEPTION((PCT_SPM | VPWS_PD, 0, "ld d s s", usVpnId,
                    ret,
                    "CALL_C3_FUNC_ERROR",
                    ucMessage));

			if (stUniVport.tNextHop.nhIdx != 0)
			{
				spm_free_vc_nhi_id(stUniVport.tNextHop.nhIdx NBB_CCXT);
			}

			if (stUniVport.tNextHop_p.nhIdx != 0)
			{
				spm_free_vc_nhi_id(stUniVport.tNextHop_p.nhIdx NBB_CCXT);
			}
			
            goto EXIT_LABEL;
        }
#endif

#ifdef SPU

        //如果不是仿真业务才建流，仿真业务不建流
        if (pstLogicalPort->basic_cfg_cb->port_flag != ATG_DCI_CES)
        {
            /**************************************************************************/
            /*                               增加intf flow                            */
            /**************************************************************************/

            //获取本槽位号
            spm_hardw_getslot(&ucLocalSlot);
            NBB_TRC_DETAIL((NBB_FORMAT "  UNI口所在槽位=%d 本地槽位=%d", stPortInfo.slot_id, ucLocalSlot));

		    for (pstTerminalIfCb = (SPM_TERMINAL_IF_CB*) AVLL_FIRST(pstLogicalPort->terminal_if_tree);
		         pstTerminalIfCb != NULL;
		         pstTerminalIfCb = (SPM_TERMINAL_IF_CB*) AVLL_NEXT(pstLogicalPort->terminal_if_tree,
		                       pstTerminalIfCb->spm_terminal_if_node))
		    {
                //1、流配置不存在不建；或
                //2、远端节点不创建流；且
                //3、端口类型不为LAG；且
                //4、端口类型不为VE；
                if ((pstLogicalPort->basic_cfg_cb->port_sub_type != ATG_DCI_LAG)
                        && (pstLogicalPort->basic_cfg_cb->port_sub_type != ATG_DCI_VE_PORT)
                        && (ucLocalSlot != stPortInfo.slot_id))
                {
                    continue;
                }
                else
	            {
	                //初始化结构
	                ApiC3InitIntfStruct(&stIntfFlow);

                    //流类型 :基于端口
                    if ((pstTerminalIfCb->terminal_if_cfg.svlan_id == 0) && (pstTerminalIfCb->terminal_if_cfg.cvlan_id == 0))
                    {
						if (pstLogicalPort->basic_cfg_cb->port_sub_type == ATG_DCI_VE_PORT)    //虚拟以太网口
	                    {
	                        stIntfFlow.mIntfMatchType = INTF_MATCH_L2_VE_PORT;
	                    }
	                    else
	                    {
	                    	stIntfFlow.mIntfMatchType = INTF_MATCH_PORT;
	                    }
                        
                        stIntfFlow.mOvid = 0;
                        stIntfFlow.mIvid = 0;
                    }

                    //基于端口+VLAN（Trunk）
                    else if ((pstTerminalIfCb->terminal_if_cfg.svlan_id != 0) && (pstTerminalIfCb->terminal_if_cfg.cvlan_id == 0))
                    {
						if (pstLogicalPort->basic_cfg_cb->port_sub_type == ATG_DCI_VE_PORT)    //虚拟以太网口
	                    {
	                        stIntfFlow.mIntfMatchType = INTF_MATCH_L2_VE_PORT_OVID;
	                    }
	                    else
	                    {
	                    	stIntfFlow.mIntfMatchType = INTF_MATCH_PORT_OVID;
	                    }
                        
                        stIntfFlow.mOvid = pstTerminalIfCb->terminal_if_cfg.svlan_id;
                        stIntfFlow.mIvid = 0;
                    }

                    //基于端口+QINQ
                    else if ((pstTerminalIfCb->terminal_if_cfg.svlan_id != 0) && (pstTerminalIfCb->terminal_if_cfg.cvlan_id != 0))
                    {
						if (pstLogicalPort->basic_cfg_cb->port_sub_type == ATG_DCI_VE_PORT)    //虚拟以太网口
	                    {
	                        stIntfFlow.mIntfMatchType = INTF_MATCH_L2_VE_PORT_OVID_IVID;
	                    }
	                    else
	                    {
	                    	stIntfFlow.mIntfMatchType = INTF_MATCH_PORT_OVID_IVID;
	                    }
                        
                        stIntfFlow.mOvid = pstTerminalIfCb->terminal_if_cfg.svlan_id;
                        stIntfFlow.mIvid = pstTerminalIfCb->terminal_if_cfg.cvlan_id;
                    }
                    else
                    {
                        OS_PRINTF("***WARNNING***: PORT_INDEX=%ld 只配置了CVlan，未配置SVlan\n", ulLogicalPortIndex);
                    }


				    //VLAN 接收识别动作
				    if (pstLogicalPort->logic_l2_cfg_cb->recv_action == ATG_DCI_TAGGED_VLAN)
				    {
				        stIntfFlow.flags |= INTF_PTAG_IDENTIFY_ENABLE;
				    }

					stIntfFlow.mCardPort = stPortInfo.port_id;
	                stIntfFlow.eIntfType = INTF_TYPE_L2;
	                stIntfFlow.bindId = usVpPosId;
	                //stIntfFlow.flags |= INTF_COUNTER_ON;  //todo

	                //调用API  函数
                       ret = ApiC3AddIntf(pstLogicalPort->unit_id, &stIntfFlow);
                       intf_pos_id_temp = stIntfFlow.posId;
                       stIntfFlow.posId = 0;
                       
                       if((2 == SHARED.c3_num) && 
                            ((stPortInfo.port_type == ATG_DCI_LAG) || (stPortInfo.port_type == ATG_DCI_VE_PORT)))
                       {
                            
                            ret += ApiC3AddIntf(1, &stIntfFlow);
                       } 

	                if (ret == SUCCESS)
	                {
                            pstTerminalIfCb->intf_pos_id = intf_pos_id_temp;
                            pstTerminalIfCb->intf2_pos_id = stIntfFlow.posId;

	                    almpm_addcfg_intf_onePos(ulLogicalPortIndex, pstTerminalIfCb->intf_pos_id);
	                }
	                else
	                {
	                    NBB_TRC_DETAIL((NBB_FORMAT "  ***ERROR***:ApiC3AddIntf() ret=%d UNI svlan=%d cvlan=%d PortIndex=%u", ret,
	                            pstTerminalIfCb->terminal_if_cfg.svlan_id,
	                            pstTerminalIfCb->terminal_if_cfg.cvlan_id,ulLogicalPortIndex));

	                    OS_PRINTF("***ERROR***:ApiC3AddIntf() ret=%d UNI svlan=%d cvlan=%d PortIndex=%u\n", ret,
	                            pstTerminalIfCb->terminal_if_cfg.svlan_id,
	                            pstTerminalIfCb->terminal_if_cfg.cvlan_id,ulLogicalPortIndex);

	                    OS_SPRINTF(ucMessage, "***ERROR***:ApiC3AddIntf() ret=%d UNI svlan=%d cvlan=%d PortIndex=%u\n", ret,
	                            pstTerminalIfCb->terminal_if_cfg.svlan_id,
	                            pstTerminalIfCb->terminal_if_cfg.cvlan_id,ulLogicalPortIndex);
	                    BMU_SLOG(BMU_INFO, SPM_L2_LOG_DIR, ucMessage);

	                    NBB_EXCEPTION((PCT_SPM | VPWS_PD, 0, "ld d s s", usVpnId,
	                            ret,
	                            "CALL_C3_FUNC_ERROR",
	                            ucMessage));
	                            
	                    continue;
	                }
	            }
                
                    //INTF上已有业务和QOS的情况下，发生删除并重建业务的操作时，驱动会在删除
                    //UNI侧vp的同时把INTF也对应删除(于是INTF上的QOS也自动失效)，当再建该业务时，
                    //虽然驱动会重新添加INTF，但主控上仍有对应的QOS并不会重新下QOS配置，故而
                    //重建业务上INTF上对应原有的QOS功能会失效
                    //解决方案,删除UNI侧业务时，调用接口删除对应的INTF上的QOS，重建业务时，对
                    //应刷新逻辑端口配置，把配置还存在但功能已失效的QOS配置重新添加一次
                    //        //add by fansongbo 2015.3.12
                    if(0 != pstTerminalIfCb->intf_pos_id)
                    {
                        stSubPort.unit = stPortInfo.unit_id;
                        stSubPort.port = stPortInfo.port_id;
                        stSubPort.slot = stPortInfo.slot_id;
                        stSubPort.ivlan = stPortInfo.cvlan;
                        stSubPort.ovlan = stPortInfo.svlan;
                        stSubPort.posid = pstTerminalIfCb->intf_pos_id;
                        
                        /*printf("    3321 %d %d %d %d %d %d  %d %d\n",
                                ulLogicalPortIndex,
                                stSubPort.ovlan,
                                stSubPort.ivlan,
                                stSubPort.unit,
                                stSubPort.slot,
                                stSubPort.port,
                                stSubPort.slot,
                                stSubPort.posid);
                        */ 
                        
                        pstflowdiffservdata.svlan = pstTerminalIfCb->terminal_if_cfg.svlan_id;
                        pstflowdiffservdata.cvlan = pstTerminalIfCb->terminal_if_cfg.cvlan_id;
                        
                        //pstflowdiffservcb = 
                            //AVLL_FIND(pstLogicalPort->flow_diff_serv_tree, &pstTerminalIfCb->terminal_if_cfg);

                        pstflowdiffservcb = 
                            AVLL_FIND(pstLogicalPort->flow_diff_serv_tree, &pstflowdiffservdata);
                        
                        //如果找到，说明之前INTF上绑定了QOS，
                        //删除UNI侧VP时被驱动删除，需要重新添
                        if (NULL != pstflowdiffservcb)
                        {
                            /* 配置处理，todo */
                            stqosflowkey.index = ulLogicalPortIndex;
                            stqosflowkey.svlan = pstTerminalIfCb->terminal_if_cfg.svlan_id;
                            stqosflowkey.cvlan = pstTerminalIfCb->terminal_if_cfg.cvlan_id;

                            ret = SUCCESS;
                            ret = spm_ds_add_logic_flow_node(&stSubPort,
                            &stqosflowkey,
                            &pstflowdiffservcb->flow_diff_serv_cfg
                            NBB_CCXT);

                            if((2 == SHARED.c3_num) && 
                                ((stPortInfo.port_type == ATG_DCI_LAG) || (stPortInfo.port_type == ATG_DCI_VE_PORT)))
                            {
                                stSubPort.unit = 1;
                                stSubPort.posid = pstTerminalIfCb->intf2_pos_id;
                                ret += spm_ds_add_logic_flow_node(&stSubPort,
                                &stqosflowkey,
                                &pstflowdiffservcb->flow_diff_serv_cfg
                                NBB_CCXT);                              
                            }                            

                            if (ret != SUCCESS)
                            {
                                NBB_TRC_DETAIL((NBB_FORMAT
                                "  ***ERROR***:port_index=%ld, spm_ds_add_logic_flow_node() ret=%d"
                                "重新增加 SVlan=%d CVlan=%d 的流相关Diff-Serv配置失败",
                                ulLogicalPortIndex, 
                                ret,
                                pstTerminalIfCb->terminal_if_cfg.svlan_id, 
                                pstTerminalIfCb->terminal_if_cfg.cvlan_id));

                                OS_PRINTF("***ERROR***:port_index=%ld, spm_ds_add_logic_flow_node() ret=%d"
                                    "重新增加 SVlan=%d CVlan=%d 的流相关Diff-Serv配置失败\n",
                                ulLogicalPortIndex, 
                                ret,
                                pstTerminalIfCb->terminal_if_cfg.svlan_id, 
                                pstTerminalIfCb->terminal_if_cfg.cvlan_id);

                                //NBB_EXCEPTION((PCT_SPM | LOGICAL_PORT_PD, 0, "ld d s s", ulPortIndexKey, ret,
                                //"CALL_FUNC_ERROR", ucMessage));

                                OS_SPRINTF(ucMessage,
                                "***ERROR***:port_index=%ld, spm_ds_add_logic_flow_node() ret=%d"
                                "重新增加 SVlan=%d CVlan=%d 的流相关Diff-Serv配置失败\n",
                                ulLogicalPortIndex, 
                                ret,
                                pstTerminalIfCb->terminal_if_cfg.svlan_id, 
                                pstTerminalIfCb->terminal_if_cfg.cvlan_id);
                                BMU_SLOG(BMU_INFO, SPM_L2_LOG_DIR, ucMessage);

                                //pstSetLogicalPort->flow_diff_serv_return_code = ATG_DCI_RC_UNSUCCESSFUL;
                                
                            }
                        }
                        
                        stSubPort.unit = stPortInfo.unit_id;
                        stSubPort.port = stPortInfo.port_id;
                        stSubPort.slot = stPortInfo.slot_id;
                        stSubPort.ivlan = stPortInfo.cvlan;
                        stSubPort.ovlan = stPortInfo.svlan;
                        stSubPort.posid = pstTerminalIfCb->intf_pos_id; 
                        
                        pstinclassifyqosdata.svlan = pstTerminalIfCb->terminal_if_cfg.svlan_id;
                        pstinclassifyqosdata.cvlan = pstTerminalIfCb->terminal_if_cfg.cvlan_id;
                        
                        //pstinclassifyqoscb = 
                            //AVLL_FIND(pstLogicalPort->inclassify_qos_tree, &pstTerminalIfCb->terminal_if_cfg);
                        pstinclassifyqoscb = 
                            AVLL_FIND(pstLogicalPort->inclassify_qos_tree, &pstinclassifyqosdata);                        
                        
                        //如果找到，说明之前INTF上绑定了QOS，
                        //删除UNI侧VP时被驱动删除，需要重新添
                        if (NULL != pstinclassifyqoscb)
                        {                                
                            ret = SUCCESS;
                            ret = spm_add_logic_flow_classify_node(ulLogicalPortIndex,
                            &pstinclassifyqoscb->inclassify_qos_cfg,
                            &stSubPort
                            NBB_CCXT);
                            
                            if((2 == SHARED.c3_num) && 
                                ((stPortInfo.port_type == ATG_DCI_LAG) || (stPortInfo.port_type == ATG_DCI_VE_PORT)))
                            {
                                stSubPort.unit = 1;
                                stSubPort.posid = pstTerminalIfCb->intf2_pos_id;
                                ret += spm_add_logic_flow_classify_node(ulLogicalPortIndex,
                                &pstinclassifyqoscb->inclassify_qos_cfg,
                                &stSubPort
                                NBB_CCXT);                             
                            }
                            
                            if (ret != SUCCESS)
                            {
                                //pstSetLogicalPort->inclassify_qos_return_code = ATG_DCI_RC_UNSUCCESSFUL;
                                NBB_TRC_DETAIL((NBB_FORMAT
                                "  ***ERROR***:port_index=%ld spm_add_logic_flow_classify_node() ret=%d"
                                "重新增加 SVlan=%d CVlan=%d 的上话复杂流分类QOS策略配置失败!\n",
                                ulLogicalPortIndex, 
                                ret,
                                pstTerminalIfCb->terminal_if_cfg.svlan_id, 
                                pstTerminalIfCb->terminal_if_cfg.cvlan_id));

                                OS_PRINTF("***ERROR***:port_index=%ld spm_add_logic_flow_classify_node() ret=%d"
                                "重新增加 SVlan=%d CVlan=%d 的上话复杂流分类QOS策略配置失败!\n",
                                ulLogicalPortIndex, 
                                ret,
                                pstTerminalIfCb->terminal_if_cfg.svlan_id, 
                                pstTerminalIfCb->terminal_if_cfg.cvlan_id);

                                OS_SPRINTF(ucMessage,
                                "***ERROR***:port_index=%ld spm_add_logic_flow_classify_node() ret=%d"
                                "重新增加 SVlan=%d CVlan=%d 的上话复杂流分类QOS策略配置失败!\n",
                                ulLogicalPortIndex, 
                                ret,
                                pstTerminalIfCb->terminal_if_cfg.svlan_id, 
                                pstTerminalIfCb->terminal_if_cfg.cvlan_id);
                                BMU_SLOG(BMU_INFO, SPM_L2_LOG_DIR, ucMessage);

                                //NBB_EXCEPTION((PCT_SPM | LOGICAL_PORT_PD, 0, "ld d s s", ulPortIndexKey, ret,
                                //"CALL_FUNC_ERROR", ucMessage));
                            }
                        }
                        
                        stSubPort.unit = stPortInfo.unit_id;
                        stSubPort.port = stPortInfo.port_id;
                        stSubPort.slot = stPortInfo.slot_id;
                        stSubPort.ivlan = stPortInfo.cvlan;
                        stSubPort.ovlan = stPortInfo.svlan;
                        stSubPort.posid = pstTerminalIfCb->intf_pos_id; 

                        psttrafficfilterdata.svlan = pstTerminalIfCb->terminal_if_cfg.svlan_id;
                        psttrafficfilterdata.cvlan = pstTerminalIfCb->terminal_if_cfg.cvlan_id;
                        
                        //pstinclassifyqoscb = 
                            //AVLL_FIND(pstLogicalPort->inclassify_qos_tree, &pstTerminalIfCb->terminal_if_cfg);
                        psttrafficfiltercb = 
                            AVLL_FIND(pstLogicalPort->traffic_filter_tree, &psttrafficfilterdata);  
                        
                        //printf("    pstTerminalIfCb->intf_pos_id)= %ld\n", pstTerminalIfCb->intf_pos_id);
                        
                        //如果找到，说明之前INTF上绑定了QOS，
                        //删除UNI侧VP时被驱动删除，需要重新添加
                        if (NULL != psttrafficfiltercb)
                        {       
                            //printf("    psttrafficfiltercb\n");
                            ret = SUCCESS;
                            ret = spm_add_logic_acl_node(ulLogicalPortIndex,
                            &psttrafficfiltercb->traffic_filter_cfg,
                            &stSubPort
                            NBB_CCXT);
                            
                            if((2 == SHARED.c3_num) && 
                                ((stPortInfo.port_type == ATG_DCI_LAG) || (stPortInfo.port_type == ATG_DCI_VE_PORT)))
                            {
                                stSubPort.unit = 1;
                                stSubPort.posid = pstTerminalIfCb->intf2_pos_id;
                                ret += spm_add_logic_acl_node(ulLogicalPortIndex,
                                &psttrafficfiltercb->traffic_filter_cfg,
                                &stSubPort
                                NBB_CCXT);                           
                            }
                            
                            /*printf(
                            "    psttrafficfiltercb  spm_add_logic_acl_node %d %d %d %d %d %d  %d %d %d %d %d %d %d\n",
                                ulLogicalPortIndex,
                                psttrafficfiltercb->traffic_filter_cfg.svlan,
                                psttrafficfiltercb->traffic_filter_cfg.cvlan,
                                psttrafficfiltercb->traffic_filter_cfg.acl_id,
                                psttrafficfiltercb->traffic_filter_cfg.direction,
                                psttrafficfiltercb->traffic_filter_cfg.classify_id,
                                stSubPort.ovlan,
                                stSubPort.ivlan,
                                stSubPort.unit,
                                stSubPort.slot,
                                stSubPort.port,
                                stSubPort.slot,
                                stSubPort.posid);
                             */   
                            
                            if (ret != SUCCESS)
                            {
                                //pstSetLogicalPort->traffic_filter_return_code = ATG_DCI_RC_UNSUCCESSFUL;

                                NBB_TRC_DETAIL((NBB_FORMAT 
                                "  ***ERROR***:port_index=%ld, spm_add_logic_acl_node() ret=%d"
                                    "重新增加SVlan=%d CVlan=%d 的包过滤器traffic_filter L2配置失败!\n",
                                ulLogicalPortIndex, 
                                ret,
                                pstTerminalIfCb->terminal_if_cfg.svlan_id, 
                                pstTerminalIfCb->terminal_if_cfg.cvlan_id));

                                OS_PRINTF("***ERROR***:port_index=%ld, spm_add_logic_acl_node() ret=%d"
                                    "重新增加SVlan=%d CVlan=%d 的包过滤器traffic_filter L2配置失败!\n",
                                ulLogicalPortIndex,
                                ret,
                                pstTerminalIfCb->terminal_if_cfg.svlan_id,
                                pstTerminalIfCb->terminal_if_cfg.cvlan_id);

                                OS_SPRINTF(ucMessage,
                                "***ERROR***:port_index=%ld,spm_add_logic_acl_node() ret=%d"
                                "    重新增加SVlan=%d CVlan=%d 的包过滤器traffic_filter L2配置失败!\n",
                                ulLogicalPortIndex,
                                ret,
                                pstTerminalIfCb->terminal_if_cfg.svlan_id,
                                pstTerminalIfCb->terminal_if_cfg.cvlan_id);
                                BMU_SLOG(BMU_INFO, SPM_L2_LOG_DIR, ucMessage);

                                //NBB_EXCEPTION((PCT_SPM | LOGICAL_PORT_PD, 0, "ld d s s", ulPortIndexKey, ret,
                                //"CALL_FUNC_ERROR", ucMessage));
                                
                            }                      
                        }
                    }
            }
        }
        
        //INTF上已有业务和QOS的情况下，发生删除并重建业务的操作时，驱动会在删除
        //UNI侧vp的同时把INTF也对应删除(于是INTF上的QOS也自动失效)，当再建该业务时，
        //虽然驱动会重新添加INTF，但主控上仍有对应的QOS并不会重新下QOS配置，故而
        //重建业务上INTF上对应原有的QOS功能会失效
        //解决方案,删除UNI侧业务时，调用接口删除对应的INTF上的QOS，重建业务时，对
        //应刷新逻辑端口配置，把配置还存在但功能已失效的QOS配置重新添加一次
        //add by fansongbo 2015.3.6
        stunivp.vpn_id = pstLogicalPort->logic_port_info_cb.vpn_id;
        stunivp.vp_type = pstLogicalPort->logic_port_info_cb.vpn_type;
        stunivp.vp_posid = pstLogicalPort->logic_port_info_cb.vp_idx;
        
        if (NULL != pstLogicalPort->ds_l2_cfg_cb)
        {
            ret = spm_ds_add_logic_univp_node(ulLogicalPortIndex,
            &stunivp,
            pstLogicalPort->ds_l2_cfg_cb
            NBB_CCXT);

            if (ret != SUCCESS)
            {
                //pstSetLogicalPort->ds_l2_return_code = ATG_DCI_RC_UNSUCCESSFUL;
                NBB_TRC_DETAIL((NBB_FORMAT 
                "  ***ERROR***:port_index=%ld spm_ds_add_logic_univp_node() ret=%d,重新添加Diff-Serv配置L2（VP下话UNI侧）失败",
                ulLogicalPortIndex));

                OS_PRINTF(
                "***ERROR***:port_index=%ld spm_ds_add_logic_univp_node() ret=%d,重新添加Diff-Serv配置L2（VP下话UNI侧）失败\n",
                ulLogicalPortIndex,
                ret);

                OS_SPRINTF(ucMessage,
                "***ERROR***:port_index=%ld spm_ds_add_logic_univp_node() ret=%d,重新添加Diff-Serv配置L2（VP下话UNI侧）失败\n",
                ulLogicalPortIndex,
                ret);
                BMU_SLOG(BMU_INFO, SPM_L2_LOG_DIR, ucMessage);

                //NBB_EXCEPTION((PCT_SPM | LOGICAL_PORT_PD, 0, "ld d s s", ulPortIndexKey, ret,
                //"CALL_FUNC_ERROR", ucMessage));

            }
        }
#endif        
    }
    else
    {
        //调用API函数进行配置，更新VP
        stUniVport.vpIdx = pstVpnPortInfo->vp_idx;
        logic_port_info_cb_vp_idx_temp = pstLogicalPort->logic_port_info_cb.vp_idx;
        
#ifdef SPU
        for (ucC3Unit = 0; ucC3Unit < SHARED.c3_num; ucC3Unit++)
        {
            ret += ApiC3ModVp(ucC3Unit, &stUniVport);
            NBB_TRC_DETAIL((NBB_FORMAT "  ApiC3ModVp[UNI]:  ret=%d", ret));
        }


        if (ret == SUCCESS)
        {
            usVpPosId = stUniVport.vpIdx;
            
            pstLogicalPort->logic_port_info_cb.vp_idx = stUniVport.vpIdx;

            pstLogicalPort->logic_port_info_cb.next_hop_counter_id = stUniVport.tNextHop.counterIdx;
            pstLogicalPort->logic_port_info_cb.vpn_type = ucVpnType;
            pstLogicalPort->logic_port_info_cb.vpn_id = usVpnId;
            pstLogicalPort->logic_port_info_cb.next_hop_id = stUniVport.tNextHop.nhIdx;

            pstVpnPortInfo->vp_idx = stUniVport.vpIdx;
            pstVpnPortInfo->port_index = ulLogicalPortIndex;

            if (stPortInfo.port_type == ATG_DCI_LAG)
            {
            	pstVpnPortInfo->slot_id = stPortInfo.lag_slot_id;
            }
            else
            {
            	pstVpnPortInfo->slot_id = stPortInfo.slot_id;
            }

			/*if (pstLogicalPortBack != NULL)
			{
	            pstLogicalPortBack->logic_port_info_cb.vp_idx = stUniVport.vpIdx;

	            pstLogicalPortBack->logic_port_info_cb.next_hop_counter_id = stUniVport.tNextHop_p.counterIdx;
	            pstLogicalPortBack->logic_port_info_cb.vpn_type = ucVpnType;
	            pstLogicalPortBack->logic_port_info_cb.vpn_id = usVpnId;
	            pstLogicalPortBack->logic_port_info_cb.next_hop_id = stUniVport.tNextHop_p.nhIdx;
			}*/
			
            NBB_TRC_DETAIL((NBB_FORMAT "  vp_idx=%d  vpn_type=%d  vpn_id=%d",
                    pstLogicalPort->logic_port_info_cb.vp_idx,
                    pstLogicalPort->logic_port_info_cb.vpn_type,
                    pstLogicalPort->logic_port_info_cb.vpn_id));
        }
        else
        {
        	//coverity[dead_error_begin]
            NBB_TRC_DETAIL((NBB_FORMAT "  ***ERROR***:ApiC3ModVp[UNI]:  ret=%d PortIndex=%u", ret,ulLogicalPortIndex));

            OS_PRINTF("***ERROR***:ApiC3ModVp[UNI]:  ret=%d PortIndex=%u\n", ret,ulLogicalPortIndex);

            OS_SPRINTF(ucMessage, "***ERROR***:ApiC3ModVp[UNI]:  ret=%d PortIndex=%u\n", ret,ulLogicalPortIndex);
            BMU_SLOG(BMU_INFO, SPM_L2_LOG_DIR, ucMessage);

            NBB_EXCEPTION((PCT_SPM | VPWS_PD, 0, "ld d s s", usVpnId,
                    ret,
                    "CALL_C3_FUNC_ERROR",
                    ucMessage));
                    
            goto EXIT_LABEL;
        }
#endif   

#ifdef SPU

        //业务没改变，但是逻辑端口经过了重新删建后再mod vp的场景，解决mantis83960
        if(0 == logic_port_info_cb_vp_idx_temp)
        {
            //如果不是仿真业务才建流，仿真业务不建流
            if (pstLogicalPort->basic_cfg_cb->port_flag != ATG_DCI_CES)
            {
            
                /**************************************************************************/
                /*                               增加intf flow                            */
                /**************************************************************************/

                //获取本槽位号
                spm_hardw_getslot(&ucLocalSlot);
                NBB_TRC_DETAIL((NBB_FORMAT "  UNI口所在槽位=%d 本地槽位=%d", stPortInfo.slot_id, ucLocalSlot));

    		    for (pstTerminalIfCb = (SPM_TERMINAL_IF_CB*) AVLL_FIRST(pstLogicalPort->terminal_if_tree);
    		         pstTerminalIfCb != NULL;
    		         pstTerminalIfCb = (SPM_TERMINAL_IF_CB*) AVLL_NEXT(pstLogicalPort->terminal_if_tree,
    		                       pstTerminalIfCb->spm_terminal_if_node))
    		    {
    		    
                    //1、流配置不存在不建；或
                    //2、远端节点不创建流；且
                    //3、端口类型不为LAG；且
                    //4、端口类型不为VE；
                    if ((pstLogicalPort->basic_cfg_cb->port_sub_type != ATG_DCI_LAG)
                            && (pstLogicalPort->basic_cfg_cb->port_sub_type != ATG_DCI_VE_PORT)
                            && (ucLocalSlot != stPortInfo.slot_id))
                    {
                        continue;
                    }
                    else
    	            {
    	                //初始化结构
    	                ApiC3InitIntfStruct(&stIntfFlow);

                        //流类型 :基于端口
                        if ((pstTerminalIfCb->terminal_if_cfg.svlan_id == 0) && 
                            (pstTerminalIfCb->terminal_if_cfg.cvlan_id == 0))
                        {
    						if (pstLogicalPort->basic_cfg_cb->port_sub_type == ATG_DCI_VE_PORT)    //虚拟以太网口
    	                    {
    	                        stIntfFlow.mIntfMatchType = INTF_MATCH_L2_VE_PORT;
    	                    }
    	                    else
    	                    {
    	                    	stIntfFlow.mIntfMatchType = INTF_MATCH_PORT;
    	                    }
                            
                            stIntfFlow.mOvid = 0;
                            stIntfFlow.mIvid = 0;
                        }

                        //基于端口+VLAN（Trunk）
                        else if ((pstTerminalIfCb->terminal_if_cfg.svlan_id != 0) && 
                            (pstTerminalIfCb->terminal_if_cfg.cvlan_id == 0))
                        {
    						if (pstLogicalPort->basic_cfg_cb->port_sub_type == ATG_DCI_VE_PORT)    //虚拟以太网口
    	                    {
    	                        stIntfFlow.mIntfMatchType = INTF_MATCH_L2_VE_PORT_OVID;
    	                    }
    	                    else
    	                    {
    	                    	stIntfFlow.mIntfMatchType = INTF_MATCH_PORT_OVID;
    	                    }
                            
                            stIntfFlow.mOvid = pstTerminalIfCb->terminal_if_cfg.svlan_id;
                            stIntfFlow.mIvid = 0;
                        }

                        //基于端口+QINQ
                        else if ((pstTerminalIfCb->terminal_if_cfg.svlan_id != 0) && 
                            (pstTerminalIfCb->terminal_if_cfg.cvlan_id != 0))
                        {
    						if (pstLogicalPort->basic_cfg_cb->port_sub_type == ATG_DCI_VE_PORT)    //虚拟以太网口
    	                    {
    	                        stIntfFlow.mIntfMatchType = INTF_MATCH_L2_VE_PORT_OVID_IVID;
    	                    }
    	                    else
    	                    {
    	                    	stIntfFlow.mIntfMatchType = INTF_MATCH_PORT_OVID_IVID;
    	                    }
                            
                            stIntfFlow.mOvid = pstTerminalIfCb->terminal_if_cfg.svlan_id;
                            stIntfFlow.mIvid = pstTerminalIfCb->terminal_if_cfg.cvlan_id;
                        }
                        else
                        {
                            OS_PRINTF("***WARNNING***: PORT_INDEX=%ld 只配置了CVlan，未配置SVlan\n", ulLogicalPortIndex);
                        }


    				    //VLAN 接收识别动作
    				    if (pstLogicalPort->logic_l2_cfg_cb->recv_action == ATG_DCI_TAGGED_VLAN)
    				    {
    				        stIntfFlow.flags |= INTF_PTAG_IDENTIFY_ENABLE;
    				    }

    					stIntfFlow.mCardPort = stPortInfo.port_id;
    	                stIntfFlow.eIntfType = INTF_TYPE_L2;
    	                stIntfFlow.bindId = usVpPosId;
                        
    	                //stIntfFlow.flags |= INTF_COUNTER_ON;  //todo

    	                //调用API  函数
                       ret = ApiC3AddIntf(pstLogicalPort->unit_id, &stIntfFlow);
                       intf_pos_id_temp = stIntfFlow.posId;
                       stIntfFlow.posId = 0;
                       
                       if((2 == SHARED.c3_num) && 
                            ((stPortInfo.port_type == ATG_DCI_LAG) || 
                            (stPortInfo.port_type == ATG_DCI_VE_PORT)))
                       {
                            
                            ret += ApiC3AddIntf(1, &stIntfFlow);
                       } 

	                if (ret == SUCCESS)
	                {
                            pstTerminalIfCb->intf_pos_id = intf_pos_id_temp;
                            pstTerminalIfCb->intf2_pos_id = stIntfFlow.posId;

	                    almpm_addcfg_intf_onePos(ulLogicalPortIndex, pstTerminalIfCb->intf_pos_id);
	                }
    	                else
    	                {
    	                    NBB_TRC_DETAIL((NBB_FORMAT 
                                   "  ***ERROR***:ApiC3AddIntf() ret=%d UNI svlan=%d cvlan=%d PortIndex=%u", ret,
    	                            pstTerminalIfCb->terminal_if_cfg.svlan_id,
    	                            pstTerminalIfCb->terminal_if_cfg.cvlan_id,ulLogicalPortIndex));

    	                    OS_PRINTF("***ERROR***:ApiC3AddIntf() ret=%d UNI svlan=%d cvlan=%d PortIndex=%u\n", ret,
    	                            pstTerminalIfCb->terminal_if_cfg.svlan_id,
    	                            pstTerminalIfCb->terminal_if_cfg.cvlan_id,ulLogicalPortIndex);

    	                    OS_SPRINTF(ucMessage, 
                                   "***ERROR***:ApiC3AddIntf() ret=%d UNI svlan=%d cvlan=%d PortIndex=%u\n", ret,
    	                            pstTerminalIfCb->terminal_if_cfg.svlan_id,
    	                            pstTerminalIfCb->terminal_if_cfg.cvlan_id,ulLogicalPortIndex);
    	                    BMU_SLOG(BMU_INFO, SPM_L2_LOG_DIR, ucMessage);

    	                    NBB_EXCEPTION((PCT_SPM | VPWS_PD, 0, "ld d s s", usVpnId,
    	                            ret,
    	                            "CALL_C3_FUNC_ERROR",
    	                            ucMessage));
    	                            
    	                    continue;
    	                }
    	            }
                    
                        //INTF上已有业务和QOS的情况下，发生删除并重建业务的操作时，驱动会在删除
                        //UNI侧vp的同时把INTF也对应删除(于是INTF上的QOS也自动失效)，当再建该业务时，
                        //虽然驱动会重新添加INTF，但主控上仍有对应的QOS并不会重新下QOS配置，故而
                        //重建业务上INTF上对应原有的QOS功能会失效
                        //解决方案,删除UNI侧业务时，调用接口删除对应的INTF上的QOS，重建业务时，对
                        //应刷新逻辑端口配置，把配置还存在但功能已失效的QOS配置重新添加一次
                        //        //add by fansongbo 2015.3.12
                        if(0 != pstTerminalIfCb->intf_pos_id)
                        {
                            stSubPort.unit = stPortInfo.unit_id;
                            stSubPort.port = stPortInfo.port_id;
                            stSubPort.slot = stPortInfo.slot_id;
                            stSubPort.ivlan = stPortInfo.cvlan;
                            stSubPort.ovlan = stPortInfo.svlan;
                            stSubPort.posid = pstTerminalIfCb->intf_pos_id;
                            
                            /*printf("    3321 %d %d %d %d %d %d  %d %d\n",
                                    ulLogicalPortIndex,
                                    stSubPort.ovlan,
                                    stSubPort.ivlan,
                                    stSubPort.unit,
                                    stSubPort.slot,
                                    stSubPort.port,
                                    stSubPort.slot,
                                    stSubPort.posid);
                            */ 
                            
                            pstflowdiffservdata.svlan = pstTerminalIfCb->terminal_if_cfg.svlan_id;
                            pstflowdiffservdata.cvlan = pstTerminalIfCb->terminal_if_cfg.cvlan_id;
                            
                            //pstflowdiffservcb = 
                                //AVLL_FIND(pstLogicalPort->flow_diff_serv_tree, &pstTerminalIfCb->terminal_if_cfg);

                            pstflowdiffservcb = 
                                AVLL_FIND(pstLogicalPort->flow_diff_serv_tree, &pstflowdiffservdata);
                            
                            //如果找到，说明之前INTF上绑定了QOS，
                            //删除UNI侧VP时被驱动删除，需要重新添
                            if (NULL != pstflowdiffservcb)
                            {
                                /* 配置处理，todo */
                                stqosflowkey.index = ulLogicalPortIndex;
                                stqosflowkey.svlan = pstTerminalIfCb->terminal_if_cfg.svlan_id;
                                stqosflowkey.cvlan = pstTerminalIfCb->terminal_if_cfg.cvlan_id;

                                ret = SUCCESS;
                                ret = spm_ds_add_logic_flow_node(&stSubPort,
                                &stqosflowkey,
                                &pstflowdiffservcb->flow_diff_serv_cfg
                                NBB_CCXT);

                                if((2 == SHARED.c3_num) && 
                                    ((stPortInfo.port_type == ATG_DCI_LAG) || 
                                    (stPortInfo.port_type == ATG_DCI_VE_PORT)))
                                {
                                    stSubPort.unit = 1;
                                    stSubPort.posid = pstTerminalIfCb->intf2_pos_id;
                                    ret += spm_ds_add_logic_flow_node(&stSubPort,
                                    &stqosflowkey,
                                    &pstflowdiffservcb->flow_diff_serv_cfg
                                    NBB_CCXT);                              
                                }   

                                if (ret != SUCCESS)
                                {
                                    NBB_TRC_DETAIL((NBB_FORMAT
                                    "  ***ERROR***:port_index=%ld, spm_ds_add_logic_flow_node() ret=%d"
                                    "重新增加 SVlan=%d CVlan=%d 的流相关Diff-Serv配置失败",
                                    ulLogicalPortIndex, 
                                    ret,
                                    pstTerminalIfCb->terminal_if_cfg.svlan_id, 
                                    pstTerminalIfCb->terminal_if_cfg.cvlan_id));

                                    OS_PRINTF("***ERROR***:port_index=%ld, spm_ds_add_logic_flow_node() ret=%d"
                                        "重新增加 SVlan=%d CVlan=%d 的流相关Diff-Serv配置失败\n",
                                    ulLogicalPortIndex, 
                                    ret,
                                    pstTerminalIfCb->terminal_if_cfg.svlan_id, 
                                    pstTerminalIfCb->terminal_if_cfg.cvlan_id);

                                    //NBB_EXCEPTION((PCT_SPM | LOGICAL_PORT_PD, 0, "ld d s s", ulPortIndexKey, ret,
                                    //"CALL_FUNC_ERROR", ucMessage));

                                    OS_SPRINTF(ucMessage,
                                    "***ERROR***:port_index=%ld, spm_ds_add_logic_flow_node() ret=%d"
                                    "重新增加 SVlan=%d CVlan=%d 的流相关Diff-Serv配置失败\n",
                                    ulLogicalPortIndex, 
                                    ret,
                                    pstTerminalIfCb->terminal_if_cfg.svlan_id, 
                                    pstTerminalIfCb->terminal_if_cfg.cvlan_id);
                                    BMU_SLOG(BMU_INFO, SPM_L2_LOG_DIR, ucMessage);

                                    //pstSetLogicalPort->flow_diff_serv_return_code = ATG_DCI_RC_UNSUCCESSFUL;
                                    
                                }
                            }
                            
                            stSubPort.unit = stPortInfo.unit_id;
                            stSubPort.port = stPortInfo.port_id;
                            stSubPort.slot = stPortInfo.slot_id;
                            stSubPort.ivlan = stPortInfo.cvlan;
                            stSubPort.ovlan = stPortInfo.svlan;
                            stSubPort.posid = pstTerminalIfCb->intf_pos_id; 
                            
                            pstinclassifyqosdata.svlan = pstTerminalIfCb->terminal_if_cfg.svlan_id;
                            pstinclassifyqosdata.cvlan = pstTerminalIfCb->terminal_if_cfg.cvlan_id;
                            
                            //pstinclassifyqoscb = 
                                //AVLL_FIND(pstLogicalPort->inclassify_qos_tree, &pstTerminalIfCb->terminal_if_cfg);
                            pstinclassifyqoscb = 
                                AVLL_FIND(pstLogicalPort->inclassify_qos_tree, &pstinclassifyqosdata);
                            
                            //如果找到，说明之前INTF上绑定了QOS，
                            //删除UNI侧VP时被驱动删除，需要重新添
                            if (NULL != pstinclassifyqoscb)
                            {                                
                                ret = SUCCESS;
                                ret = spm_add_logic_flow_classify_node(ulLogicalPortIndex,
                                &pstinclassifyqoscb->inclassify_qos_cfg,
                                &stSubPort
                                NBB_CCXT);
                                
                                if((2 == SHARED.c3_num) && 
                                    ((stPortInfo.port_type == ATG_DCI_LAG) || 
                                    (stPortInfo.port_type == ATG_DCI_VE_PORT)))
                                {
                                    stSubPort.unit = 1;
                                    stSubPort.posid = pstTerminalIfCb->intf2_pos_id;
                                    ret += spm_add_logic_flow_classify_node(ulLogicalPortIndex,
                                    &pstinclassifyqoscb->inclassify_qos_cfg,
                                    &stSubPort
                                    NBB_CCXT);                             
                                }

                                if (ret != SUCCESS)
                                {
                                    //pstSetLogicalPort->inclassify_qos_return_code = ATG_DCI_RC_UNSUCCESSFUL;
                                    NBB_TRC_DETAIL((NBB_FORMAT
                                    "  ***ERROR***:port_index=%ld spm_add_logic_flow_classify_node() ret=%d"
                                    "重新增加 SVlan=%d CVlan=%d 的上话复杂流分类QOS策略配置失败!\n",
                                    ulLogicalPortIndex, 
                                    ret,
                                    pstTerminalIfCb->terminal_if_cfg.svlan_id, 
                                    pstTerminalIfCb->terminal_if_cfg.cvlan_id));

                                    OS_PRINTF("***ERROR***:port_index=%ld spm_add_logic_flow_classify_node() ret=%d"
                                    "重新增加 SVlan=%d CVlan=%d 的上话复杂流分类QOS策略配置失败!\n",
                                    ulLogicalPortIndex, 
                                    ret,
                                    pstTerminalIfCb->terminal_if_cfg.svlan_id, 
                                    pstTerminalIfCb->terminal_if_cfg.cvlan_id);

                                    OS_SPRINTF(ucMessage,
                                    "***ERROR***:port_index=%ld spm_add_logic_flow_classify_node() ret=%d"
                                    "重新增加 SVlan=%d CVlan=%d 的上话复杂流分类QOS策略配置失败!\n",
                                    ulLogicalPortIndex, 
                                    ret,
                                    pstTerminalIfCb->terminal_if_cfg.svlan_id, 
                                    pstTerminalIfCb->terminal_if_cfg.cvlan_id);
                                    BMU_SLOG(BMU_INFO, SPM_L2_LOG_DIR, ucMessage);

                                    //NBB_EXCEPTION((PCT_SPM | LOGICAL_PORT_PD, 0, "ld d s s", ulPortIndexKey, ret,
                                    //"CALL_FUNC_ERROR", ucMessage));
                                }
                            }
                            
                            stSubPort.unit = stPortInfo.unit_id;
                            stSubPort.port = stPortInfo.port_id;
                            stSubPort.slot = stPortInfo.slot_id;
                            stSubPort.ivlan = stPortInfo.cvlan;
                            stSubPort.ovlan = stPortInfo.svlan;
                            stSubPort.posid = pstTerminalIfCb->intf_pos_id; 

                            psttrafficfilterdata.svlan = pstTerminalIfCb->terminal_if_cfg.svlan_id;
                            psttrafficfilterdata.cvlan = pstTerminalIfCb->terminal_if_cfg.cvlan_id;
                            
                            //pstinclassifyqoscb = 
                                //AVLL_FIND(pstLogicalPort->inclassify_qos_tree, &pstTerminalIfCb->terminal_if_cfg);
                            psttrafficfiltercb = 
                                AVLL_FIND(pstLogicalPort->traffic_filter_tree, &psttrafficfilterdata);  
                            
                            //printf("    pstTerminalIfCb->intf_pos_id)= %ld\n", pstTerminalIfCb->intf_pos_id);
                            
                            //如果找到，说明之前INTF上绑定了QOS，
                            //删除UNI侧VP时被驱动删除，需要重新添加
                            if (NULL != psttrafficfiltercb)
                            {       
                                //printf("    psttrafficfiltercb\n");
                                ret = SUCCESS;
                                ret = spm_add_logic_acl_node(ulLogicalPortIndex,
                                &psttrafficfiltercb->traffic_filter_cfg,
                                &stSubPort
                                NBB_CCXT);

                                if((2 == SHARED.c3_num) && 
                                    ((stPortInfo.port_type == ATG_DCI_LAG) || 
                                    (stPortInfo.port_type == ATG_DCI_VE_PORT)))
                                {
                                    stSubPort.unit = 1;
                                    stSubPort.posid = pstTerminalIfCb->intf2_pos_id;
                                    ret += spm_add_logic_acl_node(ulLogicalPortIndex,
                                    &psttrafficfiltercb->traffic_filter_cfg,
                                    &stSubPort
                                    NBB_CCXT);                           
                                }
                                
                                /*printf(
                                "psttrafficfiltercb  spm_add_logic_acl_node %d %d %d %d %d %d  %d %d %d %d %d %d %d\n",
                                    ulLogicalPortIndex,
                                    psttrafficfiltercb->traffic_filter_cfg.svlan,
                                    psttrafficfiltercb->traffic_filter_cfg.cvlan,
                                    psttrafficfiltercb->traffic_filter_cfg.acl_id,
                                    psttrafficfiltercb->traffic_filter_cfg.direction,
                                    psttrafficfiltercb->traffic_filter_cfg.classify_id,
                                    stSubPort.ovlan,
                                    stSubPort.ivlan,
                                    stSubPort.unit,
                                    stSubPort.slot,
                                    stSubPort.port,
                                    stSubPort.slot,
                                    stSubPort.posid);
                                 */   
                                
                                if (ret != SUCCESS)
                                {
                                    //pstSetLogicalPort->traffic_filter_return_code = ATG_DCI_RC_UNSUCCESSFUL;

                                    NBB_TRC_DETAIL((NBB_FORMAT 
                                    "  ***ERROR***:port_index=%ld, spm_add_logic_acl_node() ret=%d"
                                        "重新增加SVlan=%d CVlan=%d 的包过滤器traffic_filter L2配置失败!\n",
                                    ulLogicalPortIndex, 
                                    ret,
                                    pstTerminalIfCb->terminal_if_cfg.svlan_id, 
                                    pstTerminalIfCb->terminal_if_cfg.cvlan_id));

                                    OS_PRINTF("***ERROR***:port_index=%ld, spm_add_logic_acl_node() ret=%d"
                                        "重新增加SVlan=%d CVlan=%d 的包过滤器traffic_filter L2配置失败!\n",
                                    ulLogicalPortIndex,
                                    ret,
                                    pstTerminalIfCb->terminal_if_cfg.svlan_id,
                                    pstTerminalIfCb->terminal_if_cfg.cvlan_id);

                                    OS_SPRINTF(ucMessage,
                                    "***ERROR***:port_index=%ld,spm_add_logic_acl_node() ret=%d"
                                    "    重新增加SVlan=%d CVlan=%d 的包过滤器traffic_filter L2配置失败!\n",
                                    ulLogicalPortIndex,
                                    ret,
                                    pstTerminalIfCb->terminal_if_cfg.svlan_id,
                                    pstTerminalIfCb->terminal_if_cfg.cvlan_id);
                                    BMU_SLOG(BMU_INFO, SPM_L2_LOG_DIR, ucMessage);

                                    //NBB_EXCEPTION((PCT_SPM | LOGICAL_PORT_PD, 0, "ld d s s", ulPortIndexKey, ret,
                                    //"CALL_FUNC_ERROR", ucMessage));
                                    
                                }                      
                            }
                        }
                }
            }
            
            //INTF上已有业务和QOS的情况下，发生删除并重建业务的操作时，驱动会在删除
            //UNI侧vp的同时把INTF也对应删除(于是INTF上的QOS也自动失效)，当再建该业务时，
            //虽然驱动会重新添加INTF，但主控上仍有对应的QOS并不会重新下QOS配置，故而
            //重建业务上INTF上对应原有的QOS功能会失效
            //解决方案,删除UNI侧业务时，调用接口删除对应的INTF上的QOS，重建业务时，对
            //应刷新逻辑端口配置，把配置还存在但功能已失效的QOS配置重新添加一次
            //add by fansongbo 2015.3.6
            stunivp.vpn_id = pstLogicalPort->logic_port_info_cb.vpn_id;
            stunivp.vp_type = pstLogicalPort->logic_port_info_cb.vpn_type;
            stunivp.vp_posid = pstLogicalPort->logic_port_info_cb.vp_idx;
            
            if (NULL != pstLogicalPort->ds_l2_cfg_cb)
            {
                ret = spm_ds_add_logic_univp_node(ulLogicalPortIndex,
                &stunivp,
                pstLogicalPort->ds_l2_cfg_cb
                NBB_CCXT);

                if (ret != SUCCESS)
                {
                    //pstSetLogicalPort->ds_l2_return_code = ATG_DCI_RC_UNSUCCESSFUL;
                    NBB_TRC_DETAIL((NBB_FORMAT 
                    "  ***ERROR***:port_index=%ld spm_ds_add_logic_univp_node() ret=%d,重新添加Diff-Serv配置L2（VP下话UNI侧）失败",
                    ulLogicalPortIndex));

                    OS_PRINTF(
                    "***ERROR***:port_index=%ld spm_ds_add_logic_univp_node() ret=%d,重新添加Diff-Serv配置L2（VP下话UNI侧）失败\n",
                    ulLogicalPortIndex,
                    ret);

                    OS_SPRINTF(ucMessage,
                    "***ERROR***:port_index=%ld spm_ds_add_logic_univp_node() ret=%d,重新添加Diff-Serv配置L2（VP下话UNI侧）失败\n",
                    ulLogicalPortIndex,
                    ret);
                    BMU_SLOG(BMU_INFO, SPM_L2_LOG_DIR, ucMessage);

                    //NBB_EXCEPTION((PCT_SPM | LOGICAL_PORT_PD, 0, "ld d s s", ulPortIndexKey, ret,
                    //"CALL_FUNC_ERROR", ucMessage));

                }
            }
            
        }
        
#endif 

    }

    if (ucVpnType == L2VPN_VPWS)
    {

#ifdef SPU  

        //每次添加新业务时调用一次，重新进行drop状态的初始化
        aps_set_lmsp_drop_state (ulMspId);

#endif

    }

EXIT_LABEL: NBB_TRC_EXIT();

    return ret;
}

/*****************************************************************************
   函 数 名  : spm_vpn_add_protvc_nni
   功能描述  : 主用VC存在,只增加备用VC
   输入参数  : NBB_BYTE ucVpnType
             NBB_USHORT usVpnId
             NBB_VOID* pstNniData
   输出参数  : 无
   返 回 值  :
   调用函数  :
   被调函数  :

   修改历史      :
   1.日    期   : 2013年4月16日
    作    者   : xiaoxiang
    修改内容   : 新生成函数

*****************************************************************************/
NBB_INT spm_vpn_add_protvc_nni(NBB_BYTE ucVpnType, NBB_USHORT usVpnId, NBB_VOID *pstNniData NBB_CCXT_T NBB_CXT)
{
    NBB_CHAR ucMessage[SPM_MSG_INFO_LEN];

    VPORT_T stNniVport;

    //NBB_INT              i =0;
    NBB_INT ret = SUCCESS;
    NBB_BYTE ucC3Unit = 0;
    SPM_VC_CB *pstVcMain = NULL;
    SPM_VC_CB *pstVcBack = NULL;
    ATG_DCI_VC_KEY stVcKeyMain;
    ATG_DCI_VC_KEY stVcKeyBack;
    CRTXLSP_KEY stCrLspKey;    //最新的用这个接口
    FTN_KEY stFtnKey;

    NBB_ULONG ulTunnelIndexMaster = 0;
    NBB_ULONG ulTunnelIndexSlave = 0;
    NBB_ULONG ulPortIndexMaster = 0;
    NBB_ULONG ulPortIndexSlave = 0;

    //NBB_BYTE             ucSlot = 0;
    NBB_BYTE ucProtectFlag = 0;
    NBB_BYTE ucProtectType = 0;
    NBB_USHORT usFrrGroupId = 0;

    NBB_UINT iVpId = 0;
    NBB_UINT iNhiIdMain = 0;
    NBB_UINT iNhiIdBack = 0;

    ATG_DCI_VPWS_NNI_DATA *pstVpwsNni = NULL;
    ATG_DCI_VPLS_NNI_DATA *pstVplsNni = NULL;

    SPM_LINEAR_PROTECT_SWITCH stLps;
    SPM_PORT_INFO_CB stPortInfo;

    NBB_TRC_ENTRY("spm_vpn_add_protvc_nni");

    if (pstNniData == NULL)
    {
        NBB_TRC_DETAIL((NBB_FORMAT "  ***ERROR***:spm_vpn_add_protvc_nni(pstNniData==NULL)"));

        OS_PRINTF("***ERROR***:spm_vpn_add_protvc_nni(pstNniData==NULL)\n");

        OS_SPRINTF(ucMessage, "***ERROR***:spm_vpn_add_protvc_nni(pstNniData==NULL)\n");
        BMU_SLOG(BMU_INFO, SPM_L2_LOG_DIR, ucMessage);

        NBB_EXCEPTION((PCT_SPM | VPWS_PD, 0, "ld d s s", usVpnId,
                FUNC_IN_PARAM_IS_NULL,
                "FUNC_IN_PARAM_IS_NULL",
                ucMessage));
                
        ret = ERROR;
        goto EXIT_LABEL;
    }

    OS_MEMSET(&stNniVport, 0, sizeof(VPORT_T));
    OS_MEMSET(&stLps, 0, sizeof(SPM_LINEAR_PROTECT_SWITCH));

    if (ucVpnType == L2VPN_VPWS)
    {
        pstVpwsNni = (ATG_DCI_VPWS_NNI_DATA *)pstNniData;

        stVcKeyMain.vc_id = pstVpwsNni->vc_id;
        stVcKeyMain.peer_ip = pstVpwsNni->peer_ip;
        stVcKeyMain.vc_type = pstVpwsNni->vc_type;

        stVcKeyBack.vc_id = pstVpwsNni->vc_id_bak;
        stVcKeyBack.peer_ip = pstVpwsNni->peer_ip_bak;
        stVcKeyBack.vc_type = pstVpwsNni->vc_type_bak;

        iVpId = pstVpwsNni->nni_no;

        stNniVport.eVpType = VP_NNI;

        ucProtectFlag = pstVpwsNni->use_protect;
        ucProtectType = pstVpwsNni->prot_type;

        stLps.revertiveType = (SPM_LPS_REVERTIVE_TYPE_E)pstVpwsNni->if_return;
        stLps.holdOffTime = pstVpwsNni->holdoff_time;
        stLps.wtrTime = pstVpwsNni->restore_time;
    }
    else if (ucVpnType == L2VPN_VPLS)
    {
        pstVplsNni = (ATG_DCI_VPLS_NNI_DATA *)pstNniData;

        stVcKeyMain.vc_id = pstVplsNni->vc_id;
        stVcKeyMain.peer_ip = pstVplsNni->peer_ip;
        stVcKeyMain.vc_type = pstVplsNni->vc_type;

        stVcKeyBack.vc_id = pstVplsNni->vc_id_bak;
        stVcKeyBack.peer_ip = pstVplsNni->peer_ip_bak;
        stVcKeyBack.vc_type = pstVplsNni->vc_type_bak;

		iVpId = pstVplsNni->nni_no;

        stNniVport.eVpType = VP_NNI;

        ucProtectFlag = pstVplsNni->use_protect;
        ucProtectType = pstVplsNni->prot_type;

        stLps.revertiveType = (SPM_LPS_REVERTIVE_TYPE_E)pstVplsNni->if_return;
        stLps.holdOffTime = pstVplsNni->holdoff_time;
        stLps.wtrTime = pstVplsNni->restore_time;
    }
    else
    {
        NBB_TRC_DETAIL((NBB_FORMAT "  ***ERROR***: ucVpnType=%d 不存在", ucVpnType));

        OS_PRINTF("***ERROR***: ucVpnType=%d 不存在\n", ucVpnType);

        OS_SPRINTF(ucMessage, "***ERROR***: ucVpnType=%d 不存在\n", ucVpnType);
        BMU_SLOG(BMU_INFO, SPM_L2_LOG_DIR, ucMessage);

        NBB_EXCEPTION((PCT_SPM | VPWS_PD, 0, "ld d s s", usVpnId,
                VPN_NOT_VPWS_NOR_VPLS,
                "VPN_NOT_VPWS_NOR_VPLS",
                ucMessage));
                
        ret = ERROR;
        goto EXIT_LABEL;
    }

    /* 获取到VC表的配置 */
    pstVcMain = AVLL_FIND(SHARED.vc_tree, &stVcKeyMain);
    pstVcBack = AVLL_FIND(SHARED.vc_tree, &stVcKeyBack);

    if ((pstVcMain == NULL)
        || (pstVcMain->basic_cfg_cb == NULL)
        || (pstVcBack == NULL)
        || (pstVcBack->basic_cfg_cb == NULL)
        || (ucProtectFlag == 0))
    {
        NBB_TRC_DETAIL((NBB_FORMAT "  ***ERROR***: 主用/备用VC不存在，或未打开保护开关，无法单独添加备用VC！"));

        OS_PRINTF("***ERROR***: 主用/备用VC不存在，或未打开保护开关，无法单独添加备用VC！\n");

        OS_SPRINTF(ucMessage, "***ERROR***: 主用/备用VC不存在，或未打开保护开关，无法单独添加备用VC！\n");
        BMU_SLOG(BMU_INFO, SPM_L2_LOG_DIR, ucMessage);

        NBB_EXCEPTION((PCT_SPM | VPWS_PD, 0, "ld d s s", usVpnId,
                VC_NOT_MASTER_NOR_SLAVE,
                "VC_NOT_MASTER_NOR_SLAVE",
                ucMessage));
                
        ret = ERROR;
        goto EXIT_LABEL;
    }

    //如果存在，记录vpn_id等值，以便在VC表下更新配置时关联
    pstVcMain->vc_info_cb.vpn_id = usVpnId;
    pstVcMain->vc_info_cb.vpn_type = ucVpnType;
    pstVcMain->vc_info_cb.if_main = VC_MAIN;

    //如果存在，记录vpn_id等值，以便在VC表下更新配置时关联
    pstVcBack->vc_info_cb.vpn_id = usVpnId;
    pstVcBack->vc_info_cb.vpn_type = ucVpnType;
    pstVcBack->vc_info_cb.if_main = VC_BACK;

    //VLAN 接收TAG识别
    if (pstVcMain->basic_cfg_cb->recv_action == ATG_DCI_TAGGED_VLAN)
    {
    	stNniVport.flags |= VPORT_PTAG_IDENTIFY_ON;
    }

    //VLAN 发送TAG行为 主用
    switch (pstVcMain->basic_cfg_cb->send_tag_action)
    {
        case ATG_DCI_ADD_VID_PRI:
            stNniVport.tNextHop.eEgrPtagAction = EGR_ENCAP;
            break;
        case ATG_DCI_DEL_VID_PRI:
            stNniVport.tNextHop.eEgrPtagAction = EGR_NO_ENCAP;
            break;
        default:
            break;
    }

    stNniVport.vpIdx = iVpId;
    stNniVport.tNextHop.egrPtagVlan = pstVcMain->basic_cfg_cb->send_vlan_id;
    stNniVport.tNextHop.egrPtagPri = pstVcMain->basic_cfg_cb->send_vlan_pri;

    if (pstVcMain->basic_cfg_cb->tag_type == 0x8100)
    {
        stNniVport.tNextHop.eEgrPtagTpidType = TPID_0X8100;
    }
    else if (pstVcMain->basic_cfg_cb->tag_type == 0x88a8)
    {
        stNniVport.tNextHop.eEgrPtagTpidType = TPID_0X88A8;
    }

    //主用配置
    stNniVport.matchVcLabel = pstVcMain->basic_cfg_cb->pw_in_label;

    stNniVport.tNextHop.flags |= L2_NEXT_HOP_ENCAP_TUNNEL;
    stNniVport.tNextHop.tPwLabel.label_un.tlabel.label = pstVcMain->basic_cfg_cb->pw_out_label;
    stNniVport.tNextHop.tPwLabel.label_un.tlabel.bottom = 1;
    stNniVport.tNextHop.tPwLabel.label_un.tlabel.ttl = 255; //协议里面需要定义 todo

    //调用dk的接口获取TunnelIndex，因为这里只对备用VC进行操作，所以主用VP绑不到一个LSP也不退出
    if (pstVcMain->basic_cfg_cb->lsp_option == ATG_DCI_FTN)
    {
        stFtnKey.fec = pstVcMain->basic_cfg_cb->next_hop_ip;
        stFtnKey.mask = 32;
        stFtnKey.vrfid = 0;

        ret = spm_l3_ldpforoam(&stFtnKey, &ulPortIndexMaster, &ulTunnelIndexMaster NBB_CCXT);

        if (ret != SUCCESS)
        {
            NBB_TRC_DETAIL((NBB_FORMAT "  ***ERROR***: spm_l3_ldpforoam() error! ret=%d", ret));

            OS_PRINTF("***ERROR***: spm_l3_ldpforoam() ret=%d\n", ret);

            OS_SPRINTF(ucMessage, "***ERROR***: spm_l3_ldpforoam() ret=%d\n", ret);
            BMU_SLOG(BMU_INFO, SPM_L2_LOG_DIR, ucMessage);

            NBB_EXCEPTION((PCT_SPM | VPWS_PD, 0, "ld d s s", usVpnId,
                    ret,
                    "CALL_FUNC_ERROR",
                    ucMessage));
        }
    }
    else if (pstVcMain->basic_cfg_cb->lsp_option == ATG_DCI_CR_LSP)
    {
        stCrLspKey.ingress = pstVcMain->basic_cfg_cb->ingress;
        stCrLspKey.egress = pstVcMain->basic_cfg_cb->egress;
        stCrLspKey.tunnelid = pstVcMain->basic_cfg_cb->tunnel_id;
        stCrLspKey.lspid = 0;

        ret = spm_l3_rsvpforoam(&stCrLspKey, &ulPortIndexMaster, &ulTunnelIndexMaster NBB_CCXT);    //用新接口替代

        if (ret != SUCCESS)
        {
            NBB_TRC_DETAIL((NBB_FORMAT "  ***ERROR***: spm_l3_rsvpforoam() error! ret=%d", ret));

            OS_PRINTF("***ERROR***: spm_l3_rsvpforoam() ret=%d\n", ret);

            OS_SPRINTF(ucMessage, "***ERROR***: spm_l3_rsvpforoam() ret=%d\n", ret);
            BMU_SLOG(BMU_INFO, SPM_L2_LOG_DIR, ucMessage);

            NBB_EXCEPTION((PCT_SPM | VPWS_PD, 0, "ld d s s", usVpnId,
                    ret,
                    "CALL_FUNC_ERROR",
                    ucMessage));
        }
    }
    else
    {
        NBB_TRC_DETAIL((NBB_FORMAT "  ***ERROR***: 主用VC LSP选择 未配置"));

        OS_PRINTF("***ERROR***: 主用VC LSP选择 未配置\n");

        OS_SPRINTF(ucMessage, "***ERROR***: 主用VC LSP选择 未配置\n");
        BMU_SLOG(BMU_INFO, SPM_L2_LOG_DIR, ucMessage);

        NBB_EXCEPTION((PCT_SPM | VPWS_PD, 0, "ld d s s", usVpnId,
                BASIC_CONFIG_NOT_EXIST,
                "BASIC_CONFIG_NOT_EXIST",
                ucMessage));
    }

    pstVcMain->vc_info_cb.port_index = ulPortIndexMaster;
    stNniVport.tNextHop.tunnelIdx = ulTunnelIndexMaster;

    NBB_TRC_DETAIL((NBB_FORMAT "  ulFtnIndexMaster=%d ulPortIndexMaster=%d", ulTunnelIndexMaster, ulPortIndexMaster));

    //给主用保护配置
    OS_MEMSET(&stPortInfo, 0, sizeof(SPM_PORT_INFO_CB));
    spm_get_portid_from_logical_port_index(ulPortIndexMaster, &stPortInfo NBB_CCXT);
    stLps.workEntity.port = stPortInfo.port_id;
    stLps.workEntity.slot = stPortInfo.slot_id;
    stLps.workEntity.tpId = pstVcMain->basic_cfg_cb->tag_type;

    //备用配置
    if ((ucProtectFlag == 1) && (pstVcBack != NULL))
    {

        //VLAN 发送TAG行为 备用
        switch (pstVcBack->basic_cfg_cb->send_tag_action)
        {
            case ATG_DCI_ADD_VID_PRI:
                stNniVport.tNextHop_p.eEgrPtagAction = EGR_ENCAP;
                break;
            case ATG_DCI_DEL_VID_PRI:
                stNniVport.tNextHop_p.eEgrPtagAction = EGR_NO_ENCAP;
                break;
            //case ATG_DCI_REP_VID:
                //stNniVport.tNextHop_p.eEgrPtagAction = EGR_CTAG_ACTION_REPLACE_VID;
                //break;
            //case ATG_DCI_REP_VID_PRI:
                //stNniVport.tNextHop_p.eEgrPtagAction = EGR_CTAG_ACTION_REPLACE_VID_PRI;
                //break;
    		//case ATG_DCI_ADD_AFTER_RECOGNIZE:
                //stNniVport.tNextHop_p.eEgrPtagAction = EGR_CTAG_ACTION_CONDITION_ADD;
    			//break;
            //case ATG_DCI_NOP:
                //stNniVport.tNextHop_p.eEgrPtagAction = EGR_CTAG_ACTION_NO_ACTION;
                //break;
            default:
                break;
        }

        stNniVport.tNextHop_p.egrPtagVlan = pstVcBack->basic_cfg_cb->send_vlan_id;
        stNniVport.tNextHop_p.egrPtagPri = pstVcBack->basic_cfg_cb->send_vlan_pri;

        if (pstVcBack->basic_cfg_cb->tag_type == 0x8100)
        {
            stNniVport.tNextHop_p.eEgrPtagTpidType = TPID_0X8100;
        }
        else if (pstVcBack->basic_cfg_cb->tag_type == 0x88a8)
        {
            stNniVport.tNextHop_p.eEgrPtagTpidType = TPID_0X88A8;
        }

	    //VLAN 接收TAG识别
	    if (pstVcBack->basic_cfg_cb->recv_action == ATG_DCI_TAGGED_VLAN)
	    {
	    	stNniVport.flags |= VPORT_BACKUP_PTAG_IDENTIFY_ON;
	    }

        stNniVport.matchVcLabel_p = pstVcBack->basic_cfg_cb->pw_in_label;

        stNniVport.tNextHop_p.flags |= L2_NEXT_HOP_ENCAP_TUNNEL;

        //stNniVport.tNextHop_p.flags |= NEXT_HOP_NHI_TYPE_VP_PW;

        stNniVport.tNextHop_p.tPwLabel.label_un.tlabel.label = pstVcBack->basic_cfg_cb->pw_out_label;
        stNniVport.tNextHop_p.tPwLabel.label_un.tlabel.bottom = 1;
        stNniVport.tNextHop_p.tPwLabel.label_un.tlabel.ttl = 255;  //协议里面需要定义 todo

        if (pstVcBack->basic_cfg_cb->lsp_option == ATG_DCI_FTN)
        {
            stFtnKey.fec = pstVcBack->basic_cfg_cb->next_hop_ip;
            stFtnKey.mask = 32;
            stFtnKey.vrfid = 0;

            ret = spm_l3_ldpforoam(&stFtnKey, &ulPortIndexSlave, &ulTunnelIndexSlave NBB_CCXT);

            if (ret != SUCCESS)
            {
                NBB_TRC_DETAIL((NBB_FORMAT "  ***ERROR***: spm_l3_ldpforoam() error! ret=%d", ret));

                OS_PRINTF("***ERROR***: spm_l3_ldpforoam() ret=%d\n", ret);

                OS_SPRINTF(ucMessage, "***ERROR***: spm_l3_ldpforoam() ret=%d\n", ret);
                BMU_SLOG(BMU_INFO, SPM_L2_LOG_DIR, ucMessage);

                NBB_EXCEPTION((PCT_SPM | VPWS_PD, 0, "ld d s s", usVpnId,
                        ret,
                        "CALL_FUNC_ERROR",
                        ucMessage));
                        
                spm_vc_drvinfo_clear(&stVcKeyBack NBB_CCXT);

                goto EXIT_LABEL;
            }
        }
        else if (pstVcBack->basic_cfg_cb->lsp_option == ATG_DCI_CR_LSP)
        {
            //调用dk的接口获取ftn_index? todo
            stCrLspKey.ingress = pstVcBack->basic_cfg_cb->ingress;
            stCrLspKey.egress = pstVcBack->basic_cfg_cb->egress;
            stCrLspKey.tunnelid = pstVcBack->basic_cfg_cb->tunnel_id;
            stCrLspKey.lspid = 0;

            ret = spm_l3_rsvpforoam(&stCrLspKey, &ulPortIndexSlave, &ulTunnelIndexSlave NBB_CCXT);    //用新接口替代

            if (ret != SUCCESS)
            {
                NBB_TRC_DETAIL((NBB_FORMAT "  ***ERROR***: spm_l3_rsvpforoam() error! ret=%d", ret));

                OS_PRINTF("***ERROR***: spm_l3_rsvpforoam() ret=%d\n", ret);

                OS_SPRINTF(ucMessage, "***ERROR***: spm_l3_rsvpforoam() ret=%d\n", ret);
                BMU_SLOG(BMU_INFO, SPM_L2_LOG_DIR, ucMessage);

                NBB_EXCEPTION((PCT_SPM | VPWS_PD, 0, "ld d s s", usVpnId,
                        ret,
                        "CALL_FUNC_ERROR",
                        ucMessage));
                        
                spm_vc_drvinfo_clear(&stVcKeyBack NBB_CCXT);

                goto EXIT_LABEL;
            }
        }
        else
        {
            NBB_TRC_DETAIL((NBB_FORMAT "  ***ERROR***: 备用VC LSP选择 未配置"));

            OS_PRINTF("***ERROR***: 备用VC LSP选择 未配置\n");

            OS_SPRINTF(ucMessage, "***ERROR***: 备用VC LSP选择 未配置\n");
            BMU_SLOG(BMU_INFO, SPM_L2_LOG_DIR, ucMessage);

            NBB_EXCEPTION((PCT_SPM | VPWS_PD, 0, "ld d s s", usVpnId,
                    BASIC_CONFIG_NOT_EXIST,
                    "BASIC_CONFIG_NOT_EXIST",
                    ucMessage));
                    
            spm_vc_drvinfo_clear(&stVcKeyBack NBB_CCXT);

			ret = ERROR;
            goto EXIT_LABEL;
        }

        pstVcBack->vc_info_cb.port_index = ulPortIndexSlave;
        stNniVport.tNextHop_p.tunnelIdx = ulTunnelIndexSlave;

        NBB_TRC_DETAIL((NBB_FORMAT "  ulFtnIndexSlave=%d  ulPortIndexSlave=%d", ulTunnelIndexSlave, ulPortIndexSlave));

        //给备用保护配置
        OS_MEMSET(&stPortInfo, 0, sizeof(SPM_PORT_INFO_CB));
        spm_get_portid_from_logical_port_index(ulPortIndexSlave, &stPortInfo NBB_CCXT);
        stLps.protEntity.port = stPortInfo.port_id;
        stLps.protEntity.slot = stPortInfo.slot_id;
        stLps.protEntity.tpId = pstVcMain->basic_cfg_cb->tag_type;

        //如果配置PW冗余保护
        if (ucProtectType == ATG_DCI_PW_PROT_1B1)
        {
            stNniVport.eProtType = VP_NHI_FRR;
        }

        stNniVport.vpIdx = pstVcMain->vc_info_cb.vp_idx;

#ifdef SPU

        ret = SUCCESS;
        for (ucC3Unit = 0; ucC3Unit < SHARED.c3_num; ucC3Unit++)
        {
            ret += ApiC3CreateFrrGroup(ucC3Unit, &usFrrGroupId, 0, 0);
        }

        if (ret == SUCCESS)
        {
            stNniVport.frrGroupId = usFrrGroupId;
            NBB_TRC_DETAIL((NBB_FORMAT "usFrrGroupId=%d", stNniVport.frrGroupId));

            stLps.protType = FRR_TYPE;
            stLps.protGroupId = usFrrGroupId;
            stLps.lpsType = FRR_1B1;
        }
        else
        {
            NBB_TRC_DETAIL((NBB_FORMAT "***ERROR***: ApiC3CreateFrrGroup() error! ret=%d", ret));

			OS_SPRINTF(ucMessage, "***ERROR***: ApiC3CreateFrrGroup() ret=%d VPWS_ID=%d\n", ret, usVpnId);
            BMU_SLOG(BMU_INFO, SPM_L2_LOG_DIR, ucMessage);
            
            NBB_EXCEPTION((PCT_SPM | VPWS_PD, 0, "ld d s s", usVpnId,
                    ret,
                    "CALL_C3_FUNC_ERROR",
                    "ApiC3CreateFrrGroup()"));
        }
#endif
    }

    //如果是VPLS业务，需要配置MCA学习和水平分割
    if (ucVpnType == L2VPN_VPLS)
    {
        //MAC学习开关
        if (pstVcMain->basic_cfg_cb->mac_learning_enable == DISABLE)
        {
            stNniVport.flags |= VPORT_LEARN_DISABLE;
        }

        //水平分割开关
        if (pstVcMain->basic_cfg_cb->split_horizon_enable == ENABLE)
        {
            stNniVport.flags |= VPORT_NETWORK;
        }
    }

    //控制字使能。配置了保护，使能控制字？todo
    //if ((pstVcMain->basic_cfg_cb->control_word_enable == ENABLE) || (ucProtectFlag == 1))
    if (pstVcMain->basic_cfg_cb->control_word_enable == ENABLE)
    {
        stNniVport.flags |= VPORT_CW_SN;
        stNniVport.tNextHop.eCwMode = EGR_CW_SEQ;
        stNniVport.tNextHop_p.eCwMode = EGR_CW_SEQ;
    }

    //设置包计数等标志
    //stNniVport.flags            |= VPORT_COUNTER_ON;
    //stNniVport.tNextHop.flags   |= L2_NEXT_HOP_COUNTER_ON;
    //stNniVport.tNextHop_p.flags |= L2_NEXT_HOP_COUNTER_ON;

#ifdef SPU

    ret = SUCCESS;

    //调用API函数进行配置，将VP加入到VPN中
    for (ucC3Unit = 0; ucC3Unit < SHARED.c3_num; ucC3Unit++)
    {
        //        ret += ApiC3AddVpProt(ucC3Unit, &stNniVport);
        NBB_TRC_DETAIL((NBB_FORMAT "  ApiC3AddVpProt[NNI]:  ret=%d", ret));
    }

    if (ret == SUCCESS)
    {
        //iFailoverGroupId = stNniVport.frrGroupId;
        pstVcMain->vc_info_cb.vp_idx = stNniVport.vpIdx;

        pstVcMain->vc_info_cb.next_hop_counter_id = stNniVport.tNextHop.counterIdx;
        pstVcMain->vc_info_cb.next_hop_id = stNniVport.tNextHop.nhIdx;
        pstVcMain->vc_info_cb.frr_group_id = usFrrGroupId;

        if (pstVcBack != NULL)
        {
            pstVcBack->vc_info_cb.vp_idx = stNniVport.vpIdx;

            pstVcBack->vc_info_cb.next_hop_counter_id = stNniVport.tNextHop_p.counterIdx;
            pstVcBack->vc_info_cb.next_hop_id = stNniVport.tNextHop_p.nhIdx;
            pstVcBack->vc_info_cb.frr_group_id = usFrrGroupId;
        }

        //如果配置了保护
        if (ucProtectFlag == 1)
        {
            spm_lps_add_entity(&stLps);
        }
    }
    else
    {
        NBB_TRC_DETAIL((NBB_FORMAT "  ***ERROR***:ApiC3AddVpProt[NNI]:  ret=%d", ret));

        OS_PRINTF("***ERROR***:ApiC3AddVpProt[NNI]:  ret=%d\n", ret);

        OS_SPRINTF(ucMessage, "***ERROR***:ApiC3AddVpProt[NNI]:  ret=%d\n", ret);
        BMU_SLOG(BMU_INFO, SPM_L2_LOG_DIR, ucMessage);

        NBB_EXCEPTION((PCT_SPM | VPWS_PD, 0, "ld d s s", usVpnId,
                ret,
                "CALL_C3_FUNC_ERROR",
                ucMessage));
                
        goto EXIT_LABEL;
    }
#endif

#if 0

    /**************************************************************************/
    /*                             增加VC Diff-Serv                           */
    /**************************************************************************/
    if (pstVcMain->diff_serv_cfg_cb != NULL)
    {
        ret = spm_ds_add_vc_node(pstVcMain->diff_serv_cfg_cb->diff_serv_id,
            &stVcKeyMain,
            pstVcMain->vc_info_cb.vp_pos_id,
            pstVcMain->vc_info_cb.if_main);

        if (ret == SUCCESS)
        {
            pstVcMain->vc_info_cb.if_qos = ATG_DCI_USED;
        }
    }

    //如果备用存在，且QoS配置存在
    if ((pstVcBack != NULL) && (pstVcBack->diff_serv_cfg_cb != NULL))
    {
        ret = spm_ds_add_vc_node(pstVcBack->diff_serv_cfg_cb->diff_serv_id,
            &stVcKeyBack,
            pstVcBack->vc_info_cb.vp_pos_id,
            pstVcBack->vc_info_cb.if_main);

        if (ret == SUCCESS)
        {
            pstVcBack->vc_info_cb.if_qos = ATG_DCI_USED;
        }
    }
#endif

EXIT_LABEL: NBB_TRC_EXIT();

    return ret;
}

NBB_INT spm_vpn_del_protvc_nni(NBB_BYTE ucVpnType, NBB_USHORT usVpnId, NBB_VOID *pstNniData NBB_CCXT_T NBB_CXT)
{
    NBB_CHAR ucMessage[SPM_MSG_INFO_LEN];

    SPM_VC_CB *pstVcTbl = NULL;
    SPM_VC_CB *pstVcTblBack = NULL;
    ATG_DCI_VC_KEY stVcKey;
    ATG_DCI_VC_KEY stVcKeyBack;
    NBB_INT ret = SUCCESS;
    NBB_BYTE ucC3Unit = 0;

    ATG_DCI_VPWS_NNI_DATA *pstVpwsNni;
    ATG_DCI_VPLS_NNI_DATA *pstVplsNni;

    NBB_TRC_ENTRY("spm_vpn_del_protvc_nni");

    if (pstNniData == NULL)
    {
        ret = ERROR;

        NBB_TRC_DETAIL((NBB_FORMAT "  ***ERROR***: spm_vpn_del_protvc_nni(pstNniData=NULL)"));

        OS_PRINTF("***ERROR***: spm_vpn_del_protvc_nni(pstNniData=NULL)\n");

        OS_SPRINTF(ucMessage, "***ERROR***: spm_vpn_del_protvc_nni(pstNniData=NULL)\n");
        BMU_SLOG(BMU_INFO, SPM_L2_LOG_DIR, ucMessage);

        NBB_EXCEPTION((PCT_SPM | VPWS_PD, 0, "ld d s s", usVpnId,
                FUNC_IN_PARAM_IS_NULL,
                "FUNC_IN_PARAM_IS_NULL",
                ucMessage));
                
        goto EXIT_LABEL;
    }

    OS_MEMSET(&stVcKey, 0, sizeof(ATG_DCI_VC_KEY));
    OS_MEMSET(&stVcKeyBack, 0, sizeof(ATG_DCI_VC_KEY));

    if (ucVpnType == L2VPN_VPWS)
    {
        pstVpwsNni = (ATG_DCI_VPWS_NNI_DATA *)pstNniData;

        stVcKey.vc_id = pstVpwsNni->vc_id;
        stVcKey.vc_type = pstVpwsNni->vc_type;
        stVcKey.peer_ip = pstVpwsNni->peer_ip;

        stVcKeyBack.vc_id = pstVpwsNni->vc_id_bak;
        stVcKeyBack.vc_type = pstVpwsNni->vc_type_bak;
        stVcKeyBack.peer_ip = pstVpwsNni->peer_ip_bak;
    }
    else if (ucVpnType == L2VPN_VPLS)
    {
        pstVplsNni = (ATG_DCI_VPLS_NNI_DATA *)pstNniData;

        stVcKey.vc_id = pstVplsNni->vc_id;
        stVcKey.vc_type = pstVplsNni->vc_type;
        stVcKey.peer_ip = pstVplsNni->peer_ip;

        stVcKeyBack.vc_id = pstVplsNni->vc_id_bak;
        stVcKeyBack.vc_type = pstVplsNni->vc_type_bak;
        stVcKeyBack.peer_ip = pstVplsNni->peer_ip_bak;
    }

    pstVcTbl = AVLL_FIND(SHARED.vc_tree, &stVcKey);
    //coverity[returned_pointer]
    pstVcTblBack = AVLL_FIND(SHARED.vc_tree, &stVcKeyBack);

    //如果主用VC不存在，说明VP不存在，无法删除
    if (pstVcTbl == NULL)
    {
        NBB_TRC_DETAIL((NBB_FORMAT "  ***ERROR***:删除 VPNID=%d VPNTYPE=%d 的备用VC时，主用VC不存在!", usVpnId,
                ucVpnType));

        OS_PRINTF("***ERROR***:删除 VPNID=%d VPNTYPE=%d 的备用VC时，主用VC不存在!\n", usVpnId, ucVpnType);

        OS_SPRINTF(ucMessage, "***ERROR***:删除 VPNID=%d VPNTYPE=%d 的备用VC时，主用VC不存在!\n", usVpnId, ucVpnType);
        BMU_SLOG(BMU_INFO, SPM_L2_LOG_DIR, ucMessage);

        NBB_EXCEPTION((PCT_SPM | VPWS_PD, 0, "ld d s s", usVpnId,
                VC_NOT_MASTER_NOR_SLAVE,
                "VC_NOT_MASTER_NOR_SLAVE",
                ucMessage));
                
        ret = ERROR;
        goto EXIT_LABEL;
    }

#ifdef SPU

    ret = SUCCESS;

    for (ucC3Unit = 0; ucC3Unit < SHARED.c3_num; ucC3Unit++)
    {
        //        ret += ApiC3DelVpProt(ucC3Unit, pstVcTbl->vc_info_cb.vp_idx);
    }

    //如果成功，删除从驱动获取的各种备用VC信息
    if (ret == SUCCESS)
    {
        //OS_MEMSET(&pstVcTblBack->vc_info_cb, 0, sizeof(SPM_VC_INFO_CB));
        spm_lps_del_entity(FRR_TYPE, pstVcTbl->vc_info_cb.frr_group_id);
    }
    else
    {
        NBB_TRC_DETAIL((NBB_FORMAT "  ***ERROR***:ApiC3DelVpProt() ret=%d", ret));

        OS_PRINTF("***ERROR***:ApiC3DelVpProt() ret=%d\n", ret);

        OS_SPRINTF(ucMessage, "***ERROR***:ApiC3DelVpProt() ret=%d\n", ret);
        BMU_SLOG(BMU_INFO, SPM_L2_LOG_DIR, ucMessage);

        NBB_EXCEPTION((PCT_SPM | VPWS_PD, 0, "ld d s s", usVpnId,
                ret,
                "CALL_C3_FUNC_ERROR",
                ucMessage));
                
        goto EXIT_LABEL;
    }
#endif

EXIT_LABEL: NBB_TRC_EXIT();

    return ret;
}

/*****************************************************************************
   函 数 名  : spm_vpn_add_protvc_nni
   功能描述  : 主用VC存在,只增加备用VC
   输入参数  : NBB_BYTE ucVpnType
             NBB_USHORT usVpnId
             NBB_VOID* pstNniData
   输出参数  : 无
   返 回 值  :
   调用函数  :
   被调函数  :

   修改历史      :
   1.日    期   : 2013年4月16日
    作    者   : xiaoxiang
    修改内容   : 新生成函数

*****************************************************************************/
NBB_INT spm_vpn_add_vp_bypass(NBB_BYTE ucVpnType,
    NBB_USHORT usVpnId,
    NBB_USHORT usVsiMcId,
    ATG_DCI_VPWS_BYPASS_PW_DATA *pstBypassData,
    SPM_VPN_PORT_INFO_CB *pstVpnPortInfo NBB_CCXT_T NBB_CXT)
{
    NBB_CHAR ucMessage[SPM_MSG_INFO_LEN];

    VPORT_T stNniVport;
    NBB_INT ret = SUCCESS;
    NBB_BYTE ucC3Unit = 0;
    SPM_VC_CB *pstVcMain = NULL;
    ATG_DCI_VC_KEY stVcKeyMain;
    CRTXLSP_KEY stCrLspKey;    //最新的用这个接口
    LSPPROT_KEY st_lspprot_key;  //LSPPROT  key值
    FTN_KEY stFtnKey;
    SPM_VP_INFO_REFRESH_CB stVpInfoRefresh;

    NBB_ULONG ulTunnelIndexMaster = 0;
    NBB_ULONG ulPortIndexMaster = 0;
    NBB_BYTE ucProtectFlag = 0;
    NBB_USHORT usFrrGroupId = 0;

    NBB_UINT iVpId = 0;
    NBB_UINT iNhiIdMain = 0;
    NBB_UINT iNhiIdBack = 0;
    
    SPM_PORT_INFO_CB stPortInfoMaster;

    NBB_TRC_ENTRY("spm_vpn_add_vp_bypass");

    if (pstBypassData == NULL)
    {
        NBB_TRC_DETAIL((NBB_FORMAT "  ***ERROR***:spm_vpn_add_vp_bypass(pstBypassData==NULL)"));

        OS_PRINTF("***ERROR***:spm_vpn_add_vp_bypass(pstBypassData==NULL)\n");

        OS_SPRINTF(ucMessage, "***ERROR***:spm_vpn_add_vp_bypass(pstBypassData==NULL)\n");
        BMU_SLOG(BMU_INFO, SPM_L2_LOG_DIR, ucMessage);

        NBB_EXCEPTION((PCT_SPM | VPWS_PD, 0, "ld d s s", usVpnId,
                FUNC_IN_PARAM_IS_NULL,
                "FUNC_IN_PARAM_IS_NULL",
                ucMessage));
                
        ret = ERROR;
        goto EXIT_LABEL;
    }

    iVpId = pstBypassData->nni_no;

    if (iVpId == 0)
    {
        NBB_TRC_DETAIL((NBB_FORMAT "  ***ERROR***: VPN_ID=%d ucVpnType=%d iVpId=%d BYPASS", usVpnId, ucVpnType, iVpId));

        OS_PRINTF("***ERROR***: VPN_ID=%d ucVpnType=%d iVpId=%d BYPASS\n", usVpnId, ucVpnType, iVpId);

        OS_SPRINTF(ucMessage, "***ERROR***: VPN_ID=%d ucVpnType=%d iVpId=%d BYPASS\n", usVpnId, ucVpnType, iVpId);
        BMU_SLOG(BMU_INFO, SPM_L2_LOG_DIR, ucMessage);

        NBB_EXCEPTION((PCT_SPM | VPWS_PD, 0, "ld d s s", usVpnId,
                BASIC_CONFIG_NOT_EXIST,
                "BASIC_CONFIG_NOT_EXIST",
                ucMessage));
                
        ret = ERROR;
        goto EXIT_LABEL;
    }

    OS_MEMSET(&stNniVport, 0, sizeof(VPORT_T));
    OS_MEMSET(&stVcKeyMain, 0, sizeof(ATG_DCI_VC_KEY));
    OS_MEMSET(&stPortInfoMaster, 0, sizeof(SPM_PORT_INFO_CB));
    OS_MEMSET(&stCrLspKey, 0, sizeof(CRTXLSP_KEY));
    OS_MEMSET(&st_lspprot_key, 0, sizeof(LSPPROT_KEY));	
    OS_MEMSET(&stFtnKey, 0, sizeof(FTN_KEY));
	OS_MEMSET(&stVpInfoRefresh, 0, sizeof(SPM_VP_INFO_REFRESH_CB));

    stVpInfoRefresh.if_main = VC_MAIN;
    stVpInfoRefresh.vpn_type = L2VPN_VPWS;
    stVpInfoRefresh.vpn_id = usVpnId;
    stVpInfoRefresh.vc_key.vc_id = pstBypassData->vc_id;
    stVpInfoRefresh.vc_key.vc_type = pstBypassData->vc_type;
    stVpInfoRefresh.vc_key.peer_ip = pstBypassData->peer_ip;
    
    stVcKeyMain.vc_id = pstBypassData->vc_id;
    stVcKeyMain.peer_ip = pstBypassData->peer_ip;
    stVcKeyMain.vc_type = pstBypassData->vc_type;

	stNniVport.vpIdx = iVpId;
    stNniVport.eVpType = VP_NNI;
    stNniVport.mcId = usVsiMcId;

    /* 获取到VC表的配置 */
    pstVcMain = AVLL_FIND(SHARED.vc_tree, &stVcKeyMain);

    //pstVcBack = AVLL_FIND(SHARED.vc_tree, &stVcKeyBack);

    if ((pstVcMain == NULL) || (pstVcMain->basic_cfg_cb == NULL))
    {
        NBB_TRC_DETAIL((NBB_FORMAT "  ***ERROR***: Bypass PW VC不存在，Bypass PW VC基本配置不存在"));

        OS_PRINTF("***ERROR***: Bypass PW VC不存在，Bypass PW VC基本配置不存在！\n");

        OS_SPRINTF(ucMessage, "***ERROR***: Bypass PW VC不存在，Bypass PW VC基本配置不存在！\n");
        BMU_SLOG(BMU_INFO, SPM_L2_LOG_DIR, ucMessage);

        NBB_EXCEPTION((PCT_SPM | VPWS_PD, 0, "ld d s s", usVpnId,
                BASIC_CONFIG_NOT_EXIST,
                "BASIC_CONFIG_NOT_EXIST",
                ucMessage));
                
        ret = ERROR;
        goto EXIT_LABEL;
    }

    //VLAN 接收TAG识别
    if (pstVcMain->basic_cfg_cb->recv_action == ATG_DCI_TAGGED_VLAN)
    {
    	stNniVport.flags |= VPORT_PTAG_IDENTIFY_ON;
    }

    //VLAN 发送TAG行为 主用
    switch (pstVcMain->basic_cfg_cb->send_tag_action)
    {
        case ATG_DCI_ADD_VID_PRI:
            stNniVport.tNextHop.eEgrPtagAction = EGR_ENCAP;
            break;
        case ATG_DCI_DEL_VID_PRI:
            stNniVport.tNextHop.eEgrPtagAction = EGR_NO_ENCAP;
            break;
        default:
            break;
    }

    stNniVport.tNextHop.egrPtagVlan = pstVcMain->basic_cfg_cb->send_vlan_id;
    stNniVport.tNextHop.egrPtagPri = pstVcMain->basic_cfg_cb->send_vlan_pri;

    if (pstVcMain->basic_cfg_cb->tag_type == 0x8100)
    {
        stNniVport.tNextHop.eEgrPtagTpidType = TPID_0X8100;
    }
    else if (pstVcMain->basic_cfg_cb->tag_type == 0x88a8)
    {
        stNniVport.tNextHop.eEgrPtagTpidType = TPID_0X88A8;
    }

    //主用配置
    stNniVport.matchVcLabel = pstVcMain->basic_cfg_cb->pw_in_label;

    stNniVport.tNextHop.flags |= L2_NEXT_HOP_ENCAP_TUNNEL;
    stNniVport.tNextHop.tPwLabel.label_un.tlabel.label = pstVcMain->basic_cfg_cb->pw_out_label;
    stNniVport.tNextHop.tPwLabel.label_un.tlabel.bottom = 1;
    stNniVport.tNextHop.tPwLabel.label_un.tlabel.ttl = 255; //协议里面需要定义 todo

    if (pstVcMain->vc_info_cb.next_hop_id != 0)
    {
    	stNniVport.tNextHop.nhIdx = pstVcMain->vc_info_cb.next_hop_id;
    }
    else
    {
    	spm_alloc_vc_nhi_id(&iNhiIdMain NBB_CCXT);
    	stNniVport.tNextHop.nhIdx = iNhiIdMain;
    }

    //调用dk的接口获取ftnIndex
    if (pstVcMain->basic_cfg_cb->lsp_option == ATG_DCI_FTN)
    {
        stFtnKey.fec = pstVcMain->basic_cfg_cb->next_hop_ip;
        stFtnKey.mask = 32;
        stFtnKey.vrfid = 0;

        ret = spm_l3_ldpforoam(&stFtnKey, &ulPortIndexMaster, &ulTunnelIndexMaster NBB_CCXT);

        if (ret != SUCCESS)
        {
            NBB_TRC_DETAIL((NBB_FORMAT "  ***ERROR***: spm_l3_ldpforoam() error! ret=%d", ret));

            OS_PRINTF("***ERROR***: spm_l3_ldpforoam() bypass ret=%d\n", ret);

            OS_SPRINTF(ucMessage, "***ERROR***: spm_l3_ldpforoam() bypass ret=%d\n", ret);
            BMU_SLOG(BMU_INFO, SPM_L2_LOG_DIR, ucMessage);

            NBB_EXCEPTION((PCT_SPM | VPWS_PD, 0, "ld d s s", usVpnId,
                    ret,
                    "CALL_FUNC_ERROR",
                    ucMessage));
                    
            spm_vc_drvinfo_clear(&stVcKeyMain NBB_CCXT);

            goto EXIT_LABEL;
        }
    }
    else if (pstVcMain->basic_cfg_cb->lsp_option == ATG_DCI_CR_LSP)
    {
        stCrLspKey.ingress = pstVcMain->basic_cfg_cb->ingress;
        stCrLspKey.egress = pstVcMain->basic_cfg_cb->egress;
        stCrLspKey.tunnelid = pstVcMain->basic_cfg_cb->tunnel_id;
        stCrLspKey.lspid = 0;
	 st_lspprot_key.ingress  = pstVcMain->basic_cfg_cb->ingress;
	 st_lspprot_key.egress   = pstVcMain->basic_cfg_cb->egress;
	 st_lspprot_key.tunnelid = pstVcMain->basic_cfg_cb->tunnel_id;
        ret = spm_l3_rsvpforoam(&stCrLspKey, &ulPortIndexMaster, &ulTunnelIndexMaster NBB_CCXT);    //用新接口替代

        if (ret != SUCCESS)
        {
            NBB_TRC_DETAIL((NBB_FORMAT "  ***ERROR***: spm_l3_rsvpforoam() error! ret=%d", ret));

            OS_PRINTF("***ERROR***: spm_l3_rsvpforoam() bypass ret=%d\n", ret);

            OS_SPRINTF(ucMessage, "***ERROR***: spm_l3_rsvpforoam() bypass ret=%d\n", ret);
            BMU_SLOG(BMU_INFO, SPM_L2_LOG_DIR, ucMessage);

            NBB_EXCEPTION((PCT_SPM | VPWS_PD, 0, "ld d s s", usVpnId,
                    ret,
                    "CALL_FUNC_ERROR",
                    ucMessage));
                    
            spm_vc_drvinfo_clear(&stVcKeyMain NBB_CCXT);

            goto EXIT_LABEL;
        }
    }
    else
    {
        NBB_TRC_DETAIL((NBB_FORMAT "  ***ERROR***: 主用VC LSP选择 未配置"));

        OS_PRINTF("***ERROR***: 主用VC LSP选择 未配置\n");

        OS_SPRINTF(ucMessage, "***ERROR***: 主用VC LSP选择 未配置\n");
        BMU_SLOG(BMU_INFO, SPM_L2_LOG_DIR, ucMessage);

        NBB_EXCEPTION((PCT_SPM | VPWS_PD, 0, "ld d s s", usVpnId,
                BASIC_CONFIG_NOT_EXIST,
                "BASIC_CONFIG_NOT_EXIST",
                ucMessage));
                
        spm_vc_drvinfo_clear(&stVcKeyMain NBB_CCXT);

		ret = ERROR;
        goto EXIT_LABEL;
    }

    stNniVport.tNextHop.tunnelIdx = ulTunnelIndexMaster;

    NBB_TRC_DETAIL((NBB_FORMAT "  ulFtnIndexMaster=%d ulPortIndexMaster=%d", ulTunnelIndexMaster, ulPortIndexMaster));

    //给主用保护配置
    spm_get_portid_from_logical_port_index(ulPortIndexMaster, &stPortInfoMaster NBB_CCXT);

    //控制字使能。配置了保护，使能控制字？todo
    //if ((pstVcMain->basic_cfg_cb->control_word_enable == ENABLE) || (ucProtectFlag == 1))
    if (pstVcMain->basic_cfg_cb->control_word_enable == ENABLE)
    {
        stNniVport.flags |= VPORT_CW_SN;
        stNniVport.tNextHop.eCwMode = EGR_CW_SEQ;
        stNniVport.tNextHop_p.eCwMode = EGR_CW_SEQ;
    }

    //设置包计数等标志
    //stNniVport.flags |= VPORT_COUNTER_ON;
    //stNniVport.tNextHop.flags |= L2_NEXT_HOP_COUNTER_ON;

#ifdef SPU

    ret = SUCCESS;

    //调用API函数进行配置，将Bypass VP加入到VPN中
    for (ucC3Unit = 0; ucC3Unit < SHARED.c3_num; ucC3Unit++)
    {
        ret += ApiC3AddMplsPortToVpn(ucC3Unit, ucVpnType, usVpnId, &stNniVport);
        NBB_TRC_DETAIL((NBB_FORMAT "  ApiAddMplsPortToVpn[Bypass]:  ret=%d", ret));
    }

    if (ret == SUCCESS)
    {
        pstVcMain->vc_info_cb.vp_idx = stNniVport.vpIdx;

        pstVcMain->vc_info_cb.next_hop_counter_id = stNniVport.tNextHop.counterIdx;
        pstVcMain->vc_info_cb.next_hop_id = stNniVport.tNextHop.nhIdx;
        pstVcMain->vc_info_cb.frr_group_id = usFrrGroupId;
        pstVcMain->vc_info_cb.vpn_id = usVpnId;
        pstVcMain->vc_info_cb.vpn_type = ucVpnType;
        pstVcMain->vc_info_cb.if_main = VC_MAIN;
    	 pstVcMain->vc_info_cb.port_index = ulPortIndexMaster;
        pstVcMain->vc_info_cb.drv_tunnel_id = stNniVport.tNextHop.tunnelIdx;
        pstVcMain->vc_info_cb.lsp_option = pstVcMain->basic_cfg_cb->lsp_option;  
              
        pstVpnPortInfo->vp_idx = stNniVport.vpIdx;
        pstVpnPortInfo->next_hop_id = stNniVport.tNextHop.nhIdx;

        if (pstVcMain->basic_cfg_cb->lsp_option == ATG_DCI_FTN)
        {
            //调用dk接口，传vpid与tunnelid的对应关系
            spm_l3_addvpldp(&stVpInfoRefresh, stNniVport.vpIdx, 
                stNniVport.tNextHop.nhIdx, stNniVport.tNextHop.tunnelIdx NBB_CCXT);
        }
	else if (ATG_DCI_CR_LSP == pstVcMain->basic_cfg_cb->lsp_option)
	{
	    //20160104 调用dk接口，传vpid与tunnelid的对应关系
	    spm_l3_addvprsvp(&stVpInfoRefresh, stNniVport.vpIdx, 
	        stNniVport.tNextHop.nhIdx,&st_lspprot_key, 
	        stNniVport.tNextHop.tunnelIdx NBB_CCXT); 
	}
		if (ucVpnType == L2VPN_VPLS)
		{
        	spm_l3_add_mcid_ldp(usVpnId, usVsiMcId, ATG_DCI_FTN, stFtnKey, stCrLspKey, ulPortIndexMaster NBB_CCXT);
		}
    }
    else
    {
        NBB_TRC_DETAIL((NBB_FORMAT "  ***ERROR***:ApiAddMplsPortToVpn[Bypass]:  ret=%d", ret));

        OS_PRINTF("***ERROR***:ApiAddMplsPortToVpn[Bypass]:  ret=%d\n", ret);

        OS_SPRINTF(ucMessage, "***ERROR***:ApiAddMplsPortToVpn[Bypass]:  ret=%d\n", ret);
        BMU_SLOG(BMU_INFO, SPM_L2_LOG_DIR, ucMessage);

        NBB_EXCEPTION((PCT_SPM | VPWS_PD, 0, "ld d s s", usVpnId,
                ret,
                "CALL_C3_FUNC_ERROR",
                ucMessage));

		if (iNhiIdMain != 0)
		{
        	spm_free_vc_nhi_id(iNhiIdMain NBB_CCXT);
        }
        
        goto EXIT_LABEL;
    }
#endif

#if 0
    /**************************************************************************/
    /*                             增加VC Diff-Serv                           */
    /**************************************************************************/
    if (pstVcMain->diff_serv_cfg_cb != NULL)
    {
        ret = spm_ds_add_vc_node(pstVcMain->diff_serv_cfg_cb->diff_serv_id,
            &stVcKeyMain,
            pstVcMain->vc_info_cb.vp_idx,
            pstVcMain->vc_info_cb.if_main);

        if (ret == SUCCESS)
        {
            pstVcMain->vc_info_cb.if_qos = ATG_DCI_USED;
        }
    }

    /**************************************************************************/
    /*                          上话VPN QOS策略配置                           */
    /**************************************************************************/
    if (pstVcMain->up_vpn_cfg_cb != NULL)
    {
        stCrLspKey.ingress = pstVcMain->basic_cfg_cb->ingress;
        stCrLspKey.egress = pstVcMain->basic_cfg_cb->egress;
        stCrLspKey.tunnelid = pstVcMain->basic_cfg_cb->tunnel_id;
        stCrLspKey.lspid = 0;

        ret = spm_hqos_add_vc_node(stPortInfoMaster.slot_id,
            stPortInfoMaster.port_id,
            pstVcMain->vc_info_cb.vp_idx,
            pstVcMain->vc_info_cb.if_main,
            &stCrLspKey,
            &stVcKeyMain,
            pstVcMain->up_vpn_cfg_cb);

        if (ret == SUCCESS)
        {
            pstVcMain->vc_info_cb.if_qos = ATG_DCI_USED;
        }
    }
#endif

    EXIT_LABEL: NBB_TRC_EXIT();

    return ret;
}

/*****************************************************************************
 函 数 名  : spm_set_bypass_prot
 功能描述  : 双归保护配置传递
 输入参数  : SPM_VPWS_CB *pstVpws       
             NBB_USHORT usAssociatedId  
 输出参数  : 无
 返 回 值  : 
 调用函数  : 
 被调函数  : 
 
 修改历史      :
  1.日    期   : 2013年6月28日
    作    者   : xiaoxiang
    修改内容   : 新生成函数

*****************************************************************************/
NBB_INT spm_set_bypass_prot(SPM_VPWS_CB *pstVpws, NBB_USHORT usAssociatedId, NBB_USHORT usDhId NBB_CCXT_T NBB_CXT)
{
    NBB_INT i = 0;
    NBB_INT ret = SUCCESS;
    NBB_UINT iVpUniPosId = 0;
    NBB_UINT iVpNniPosId = 0;
    ATG_DCI_VC_KEY stVcKey;
    ST_BYPASS_VPWS_CFG stBypassProtCfg;
    SPM_VC_CB *pstVcTbl = NULL;
    NBB_CHAR ucMessage[SPM_MSG_INFO_LEN];

    NBB_TRC_ENTRY("spm_set_bypass_prot");

    if (pstVpws == NULL)
    {
    	ret = ERROR;
    	goto EXIT_LABEL;
    }
    
    OS_MEMSET(&stBypassProtCfg, 0, sizeof(ST_BYPASS_VPWS_CFG));
    OS_MEMSET(&stVcKey, 0, sizeof(ATG_DCI_VC_KEY));
    
    //主辅节点之间相互关联的bypass vpws的关联ID相同
    stBypassProtCfg.bypassVpwsId = pstVpws->vpws_id_key;
    stBypassProtCfg.vpwsAssociatedId = usAssociatedId;
    stBypassProtCfg.bypassDhId = usDhId;

    printf("stBypassProtCfg.vpwsAssociatedId = %d\n", stBypassProtCfg.vpwsAssociatedId);
    printf("stBypassProtCfg.bypassDhId = %d\n", stBypassProtCfg.bypassDhId);
            
    //找到 NNI
    for (i = 0; i < ATG_DCI_VPWS_NNI_NUM; i++)
    {
        if ((pstVpws->nni_info_cb[i].vp_idx != 0) && (pstVpws->nni_cfg_cb[i] != NULL))
        {
            stBypassProtCfg.nniVpPosId = pstVpws->nni_info_cb[i].vp_idx;

            stBypassProtCfg.nniVcKey.vc_id = pstVpws->nni_cfg_cb[i]->vc_id;
            stBypassProtCfg.nniVcKey.vc_type = pstVpws->nni_cfg_cb[i]->vc_type;
            stBypassProtCfg.nniVcKey.peer_ip = pstVpws->nni_cfg_cb[i]->peer_ip;

            stVcKey.vc_id = pstVpws->nni_cfg_cb[i]->vc_id;
            stVcKey.vc_type = pstVpws->nni_cfg_cb[i]->vc_type;
            stVcKey.peer_ip = pstVpws->nni_cfg_cb[i]->peer_ip;

            pstVcTbl = AVLL_FIND(SHARED.vc_tree, &stVcKey);
            
            if (pstVcTbl != NULL)       /* 如果条目不存在*/
            {
                stBypassProtCfg.nniPortIndex = pstVcTbl->vc_info_cb.port_index;
            }
            else
            {
                NBB_TRC_FLOW((NBB_FORMAT "  ***ERROR***:VPWS(ID=%d)传递保护配置NNI主用VC不存在!", pstVpws->vpws_id_key));

                OS_PRINTF("***ERROR***:VPWS(ID=%d)传递保护配置NNI主用VC不存在!\n", pstVpws->vpws_id_key);

                OS_SPRINTF(ucMessage, "***ERROR***:VPWS(ID=%d)传递保护配置NNI主用VC不存在!\n", pstVpws->vpws_id_key);
                BMU_SLOG(BMU_INFO, SPM_L2_LOG_DIR, ucMessage);

                NBB_EXCEPTION((PCT_SPM | VPWS_PD, 0, "ld d s s", pstVpws->vpws_id_key,
                        BASIC_CONFIG_NOT_EXIST,
                        "BASIC_CONFIG_NOT_EXIST",
                        ucMessage));
            }
            printf("stBypassProtCfg.nniVpPosId = %d\n", stBypassProtCfg.nniVpPosId);
            printf("stBypassProtCfg.nniPortIndex = %d\n", stBypassProtCfg.nniPortIndex);
            printf("stBypassProtCfg.nniVcKey.vc_id = %d\n", stBypassProtCfg.nniVcKey.vc_id);
            printf("stBypassProtCfg.nniVcKey.vc_type = %d\n", stBypassProtCfg.nniVcKey.vc_type);
            printf("stBypassProtCfg.nniVcKey.peer_ip = 0x%x\n", stBypassProtCfg.nniVcKey.peer_ip);
            
            break;
        }
    }

    //找到 UNI
    for (i = 0; i < ATG_DCI_VPWS_UNI_NUM; i++)
    {
        if ((pstVpws->uni_info_cb[i].vp_idx != 0) && (pstVpws->uni_cfg_cb[i] != NULL))
        {
            stBypassProtCfg.acVpPosId = pstVpws->uni_info_cb[i].vp_idx;
            stBypassProtCfg.acPortIndex = pstVpws->uni_cfg_cb[i]->port_index;

            printf("stBypassProtCfg.acVpPosId = %d\n", stBypassProtCfg.acVpPosId);
            printf("stBypassProtCfg.acPortIndex = %d\n", stBypassProtCfg.acPortIndex);
            
            break;
        }
    }

    //找到 Bypass    
    if (pstVpws->bypass_cfg_cb != NULL)
    {
        stBypassProtCfg.bypassVpPosId = pstVpws->bypass_info_cb.vp_idx;
        
        stBypassProtCfg.bypassVcKey.vc_id = pstVpws->bypass_cfg_cb->vc_id;
        stBypassProtCfg.bypassVcKey.vc_type = pstVpws->bypass_cfg_cb->vc_type;
        stBypassProtCfg.bypassVcKey.peer_ip = pstVpws->bypass_cfg_cb->peer_ip;

        stVcKey.vc_id = pstVpws->bypass_cfg_cb->vc_id;
        stVcKey.vc_type = pstVpws->bypass_cfg_cb->vc_type;
        stVcKey.peer_ip = pstVpws->bypass_cfg_cb->peer_ip;

        pstVcTbl = AVLL_FIND(SHARED.vc_tree, &stVcKey);
        
        if (pstVcTbl != NULL)       /* 如果条目不存在*/
        {
            stBypassProtCfg.bypassPortIndex = pstVcTbl->vc_info_cb.port_index;
        }
        else
        {
            NBB_TRC_FLOW((NBB_FORMAT "  ***ERROR***:VPWS(ID=%d)传递保护配置Bypass pw 的VC不存在!", pstVpws->vpws_id_key));

            OS_PRINTF("***ERROR***:VPWS(ID=%d)传递保护配置Bypass pw 的VC不存在!", pstVpws->vpws_id_key);

            OS_SPRINTF(ucMessage, "***ERROR***:VPWS(ID=%d)传递保护配置Bypass pw 的VC不存在!", pstVpws->vpws_id_key);
            BMU_SLOG(BMU_INFO, SPM_L2_LOG_DIR, ucMessage);

            NBB_EXCEPTION((PCT_SPM | VPWS_PD, 0, "ld d s s", pstVpws->vpws_id_key,
                    BASIC_CONFIG_NOT_EXIST,
                    "BASIC_CONFIG_NOT_EXIST",
                    ucMessage));
        }

        printf("stBypassProtCfg.bypassVpPosId = %d\n", stBypassProtCfg.bypassVpPosId);
        printf("stBypassProtCfg.bypassPortIndex = %d\n", stBypassProtCfg.bypassPortIndex);
        printf("stBypassProtCfg.bypassVcKey.vc_id = %d\n", stBypassProtCfg.bypassVcKey.vc_id);
        printf("stBypassProtCfg.bypassVcKey.vc_type = %d\n", stBypassProtCfg.bypassVcKey.vc_type);
        printf("stBypassProtCfg.bypassVcKey.peer_ip = 0x%x\n", stBypassProtCfg.bypassVcKey.peer_ip);
            
    }

    ret = aps_add_bypass_vpws(&stBypassProtCfg);

    EXIT_LABEL: NBB_TRC_EXIT();

    return ret;
}

/*****************************************************************************
   函 数 名  : spm_vpws_get_vp_num
   功能描述  : 获取VPWS中UNI和NNI的个数和
   输入参数  : NBB_USHORT usVpnId
             NBB_INT *piVpNum
   输出参数  : 无
   返 回 值  :
   调用函数  :
   被调函数  :

   修改历史      :
   1.日    期   : 2013年5月16日
    作    者   : xiaoxiang
    修改内容   : 新生成函数

*****************************************************************************/
NBB_INT spm_vpws_get_vp_num(NBB_USHORT usVpnId, NBB_INT *piVpNum NBB_CCXT_T NBB_CXT)
{
	NBB_CHAR ucMessage[SPM_MSG_INFO_LEN];
    NBB_INT ret = SUCCESS;
    SPM_VPWS_CB *pstVpws = NULL;

    NBB_TRC_ENTRY("spm_vpws_get_vp_num");

    pstVpws = AVLL_FIND(SHARED.vpws_tree, &usVpnId);

    if (pstVpws != NULL)
    {
        *piVpNum = pstVpws->nni_num + pstVpws->uni_num;
        NBB_TRC_DETAIL((NBB_FORMAT "  VPWS_ID=%d<NNI=%d UNI=%d UNI+NNI=%d>", usVpnId, pstVpws->nni_num,
                pstVpws->uni_num, *piVpNum));
    }
    else
    {
        *piVpNum = 0;
        NBB_TRC_DETAIL((NBB_FORMAT "  ***ERROR***: spm_vpws_get_vp_num() VPWS_ID=%d 的 VPWS 不存在", usVpnId));

        OS_SPRINTF(ucMessage, "***ERROR***: spm_vpws_get_vp_num() VPWS_ID=%d 的 VPWS 不存在", usVpnId);
        BMU_SLOG(BMU_INFO, SPM_L2_LOG_DIR, ucMessage);

        NBB_EXCEPTION((PCT_SPM | VPWS_PD, 0, "ld d s s", usVpnId,
                BASIC_CONFIG_NOT_EXIST,
                "BASIC_CONFIG_NOT_EXIST",
                ucMessage));
    }

EXIT_LABEL: NBB_TRC_EXIT();

    return ret;
}


/*****************************************************************************
 函 数 名  : spm_vpn_refresh_vc_nni_cfg
 功能描述  : LDP震荡时，刷新NNI和VC保存的出接口配置
 输入参数  : SPM_VP_INFO_REFRESH_CB stVpInfoRefresh
 			 NBB_ULONG ulPortIndexNew : 新的arad出口index
 输出参数  : 无
 返 回 值  : 
 调用函数  : 
 被调函数  : 
 
 修改历史      :
  1.日    期   : 2013年11月25日
    作    者   : xiaoxiang
    修改内容   : 新生成函数

*****************************************************************************/
NBB_INT spm_vpn_refresh_vc_nni_cfg(SPM_VP_INFO_REFRESH_CB* pstVpInfoRefresh,
										  NBB_ULONG ulPortIndexNew
										  NBB_CCXT_T NBB_CXT)
{
	NBB_CHAR ucMessage[SPM_MSG_INFO_LEN];
	NBB_INT ret = SUCCESS;
	NBB_INT i = 0;
	NBB_ULONG ulSwitchVcKey = 0;
	SPM_VPWS_CB *pstVpws = NULL;
	SPM_VPLS_CB *pstVpls = NULL;
	SPM_SWITCH_VC_CB *pstSwitchVc = NULL;
	SPM_VC_CB *pstVc = NULL;
	SPM_LOGICAL_PORT_CB *pstLogicalPort = NULL;
	SPM_PORT_INFO_CB stPortInfo;
	SPM_QOS_TUNNEL_KEY stQosTunKey;
	ATG_DCI_VC_UP_VPN_QOS_POLICY stVcUpVpnQosPolicy;

	OS_MEMSET(&stPortInfo, 0, sizeof(SPM_PORT_INFO_CB));
	OS_MEMSET(&stQosTunKey, 0, sizeof(SPM_QOS_TUNNEL_KEY));
	OS_MEMSET(&stVcUpVpnQosPolicy, 0, sizeof(ATG_DCI_VC_UP_VPN_QOS_POLICY));

	if (pstVpInfoRefresh == NULL)
	{
        NBB_TRC_DETAIL((NBB_FORMAT "  ***ERROR***: spm_vpn_refresh_vc_nni_cfg(pstVpInfoRefresh==NULL)"));
        OS_PRINTF("***ERROR***: spm_vpn_refresh_vc_nni_cfg(pstVpInfoRefresh==NULL)\n");

		OS_SPRINTF(ucMessage, "***ERROR***: spm_vpn_refresh_vc_nni_cfg(pstVpInfoRefresh==NULL)\n");
        BMU_SLOG(BMU_INFO, SPM_L2_LOG_DIR, ucMessage);
        
		NBB_EXCEPTION((PCT_SPM | PUB_FUN_PD, 0, "ld d s s", 0, BASIC_CONFIG_NOT_EXIST, "BASIC_CONFIG_NOT_EXIST", ucMessage));

        ret = ERROR;
        goto EXIT_LABEL;
    }
/*
	//VPWS或VPLS的ID为0，返回
	if (pstVpInfoRefresh->vpn_id == 0)
	{
        NBB_TRC_DETAIL((NBB_FORMAT "  ***ERROR***: spm_vpn_refresh_vc_nni_cfg(usVpnId==0)"));

        //OS_PRINTF("***ERROR***: spm_vpn_refresh_vc_nni_cfg(usVpnId==0)\n");

		OS_SPRINTF(ucMessage, "***ERROR***: spm_vpn_refresh_vc_nni_cfg(usVpnId==0)\n");
        BMU_SLOG(BMU_INFO, SPM_L2_LOG_DIR, ucMessage);
        
        NBB_EXCEPTION((PCT_SPM | VPWS_PD, 0, "ld d s s", 0, 
                                                         FUNC_IN_PARAM_IS_NULL, 
                                                         "FUNC_IN_PARAM_IS_NULL", 
                                                         ucMessage));
        ret = ERROR;
        goto EXIT_LABEL;
	}

	//VPN的类型为0，返回
	if (pstVpInfoRefresh->vpn_type == 0)
	{
        NBB_TRC_DETAIL((NBB_FORMAT "  ***ERROR***: spm_vpn_refresh_vc_nni_cfg(ucVpnType==0)"));

        //OS_PRINTF("***ERROR***: spm_vpn_refresh_vc_nni_cfg(ucVpnType==0)\n");

		OS_SPRINTF(ucMessage, "***ERROR***: spm_vpn_refresh_vc_nni_cfg(ucVpnType==0)\n");
        BMU_SLOG(BMU_INFO, SPM_L2_LOG_DIR, ucMessage);
        
        NBB_EXCEPTION((PCT_SPM | VPWS_PD, 0, "ld d s s", pstVpInfoRefresh->vpn_id, 
                                                         FUNC_IN_PARAM_IS_NULL, 
                                                         "FUNC_IN_PARAM_IS_NULL", 
                                                         ucMessage));
        ret = ERROR;
        goto EXIT_LABEL;
	}
*/
	//ulPortIndexNew为0，退出处理
	if (ulPortIndexNew == 0)
	{
        NBB_TRC_DETAIL((NBB_FORMAT "  ***ERROR***: spm_vpn_refresh_vc_nni_cfg(ulPortIndexNew==0)"));

        //OS_PRINTF("***ERROR***: spm_vpn_refresh_vc_nni_cfg(ulPortIndexNew==0)\n");

		OS_SPRINTF(ucMessage, "***ERROR***: spm_vpn_refresh_vc_nni_cfg(ulPortIndexNew==0)\n");
        BMU_SLOG(BMU_INFO, SPM_L2_LOG_DIR, ucMessage);
        
        NBB_EXCEPTION((PCT_SPM | VPWS_PD, 0, "ld d s s", pstVpInfoRefresh->vpn_id, 
                                                         FUNC_IN_PARAM_IS_NULL, 
                                                         "FUNC_IN_PARAM_IS_NULL", 
                                                         ucMessage));
        ret = ERROR;
        goto EXIT_LABEL;
	}

	//如果反刷的为VPWS
	if (pstVpInfoRefresh->vpn_type == L2VPN_VPWS)
	{
		//反刷的VC不存在，退出处理
		pstVc = AVLL_FIND(SHARED.vc_tree, &pstVpInfoRefresh->vc_key);

		if ((pstVc == NULL) || (pstVc->basic_cfg_cb == NULL))
		{
	        OS_PRINTF("***ERROR***:要反刷的VC_ID=%ld VC_TYPE=%d PEER_IP=%s 的VC表配置并不存在!\n", pstVpInfoRefresh->vc_key.vc_id, 
	                                                                                                pstVpInfoRefresh->vc_key.vc_type, 
	                                                                                                spm_set_ulong_to_ipv4(pstVpInfoRefresh->vc_key.peer_ip NBB_CCXT));

	        OS_SPRINTF(ucMessage, "***ERROR***:要反刷的VC_ID=%ld VC_TYPE=%d PEER_IP=%s 的VC表配置并不存在!\n", pstVpInfoRefresh->vc_key.vc_id, 
	                                                                                                pstVpInfoRefresh->vc_key.vc_type, 
	                                                                                                spm_set_ulong_to_ipv4(pstVpInfoRefresh->vc_key.peer_ip NBB_CCXT));
	        BMU_SLOG(BMU_INFO, SPM_L2_LOG_DIR, ucMessage);

	        NBB_EXCEPTION((PCT_SPM | VC_PD, 0, "ld d s d s s", pstVpInfoRefresh->vc_key.vc_id, 
	                                                         pstVpInfoRefresh->vc_key.vc_type, 
	                                                         spm_set_ulong_to_ipv4(pstVpInfoRefresh->vc_key.peer_ip NBB_CCXT), 
	                                                         DEL_UNEXIST_CONFIG_ERROR, 
	                                                         "DEL_UNEXIST_CONFIG_ERROR", 
	                                                         ucMessage));
	        ret = ERROR;
	        goto EXIT_LABEL;
	    }

    	stQosTunKey.flag   			= 1;
    	stQosTunKey.type   			= pstVc->basic_cfg_cb->lsp_option;                	
        stQosTunKey.tx_lsp.egress   = pstVc->basic_cfg_cb->egress;
        stQosTunKey.tx_lsp.ingress  = pstVc->basic_cfg_cb->ingress;
        stQosTunKey.tx_lsp.tunnelid = pstVc->basic_cfg_cb->tunnel_id;
        stQosTunKey.ftn.fec			= pstVc->basic_cfg_cb->next_hop_ip;
        stQosTunKey.ftn.mask        = 32;
        stQosTunKey.ftn.vrfid       = 0;

		pstVpws = AVLL_FIND(SHARED.vpws_tree, &pstVpInfoRefresh->vpn_id);

		if (pstVpws == NULL)
		{
	        NBB_TRC_FLOW((NBB_FORMAT "  ***ERROR***:要刷新 VPWS_ID=%d 的VPWS配置并不存在!\n", pstVpInfoRefresh->vpn_id));

	        //OS_PRINTF("***ERROR***:要刷新 VPWS_ID=%d 的VPWS配置并不存在!\n", stVpInfoRefresh.vpn_id);

	        OS_SPRINTF(ucMessage, "***ERROR***:要刷新 VPWS_ID=%d 的VPWS配置并不存在!\n", pstVpInfoRefresh->vpn_id);
	        BMU_SLOG(BMU_INFO, SPM_L2_LOG_DIR, ucMessage);

	        NBB_EXCEPTION((PCT_SPM | VPWS_PD, 0, "ld d s s", pstVpInfoRefresh->vpn_id, 
	                                                         DEL_UNEXIST_CONFIG_ERROR, 
	                                                         "DEL_UNEXIST_CONFIG_ERROR", 
	                                                         ucMessage));
	        ret = ERROR;            
	        goto EXIT_LABEL;
	    }

	    if (pstVpInfoRefresh->if_main == VC_MAIN)
	    {
	    	for (i=0; i<ATG_DCI_VPWS_NNI_NUM; i++)
		    {
		    	if ((pstVpws->nni_cfg_cb[i] != NULL)
		    	 && (pstVpws->nni_cfg_cb[i]->vc_id == pstVpInfoRefresh->vc_key.vc_id)
		    	 && (pstVpws->nni_cfg_cb[i]->vc_type == pstVpInfoRefresh->vc_key.vc_type)
		    	 && (pstVpws->nni_cfg_cb[i]->peer_ip == pstVpInfoRefresh->vc_key.peer_ip))
		    	{

	                //如果VC存在，且已经属于VP中，删除VPN QOS
	                if ((pstVc->vc_info_cb.vp_idx != 0) && (pstVc->up_vpn_cfg_cb != NULL))
	                {
	                	stVcUpVpnQosPolicy.node_index = pstVc->up_vpn_cfg_cb->node_index;
	                	
	                    ret = spm_hqos_add_vc_node(pstVc->vc_info_cb.slot_id, 
	                                               pstVc->vc_info_cb.port_id, 
	                                               pstVc->vc_info_cb.vp_idx, 
	                                               pstVc->vc_info_cb.if_main,
	                                               &stQosTunKey,
	                                               &pstVpInfoRefresh->vc_key,
	                                               &stVcUpVpnQosPolicy
	                                               NBB_CCXT);
	                }
	                
		    		pstVpws->nni_info_cb[i].port_index = ulPortIndexNew;

			        ret = spm_get_portid_from_logical_port_index(ulPortIndexNew, &stPortInfo NBB_CCXT);

			        if (ret == SUCCESS)
			        {
			        	pstVc->vc_info_cb.port_index = ulPortIndexNew;
			        	pstVc->vc_info_cb.port_id = stPortInfo.port_id;

			        	if (stPortInfo.port_type == ATG_DCI_LAG)
			        	{
			        		pstVc->vc_info_cb.slot_id = stPortInfo.lag_slot_id;
			        		pstVpws->nni_info_cb[i].slot_id = stPortInfo.lag_slot_id;
			        	}
			        	else
			        	{
			        		pstVc->vc_info_cb.slot_id = stPortInfo.slot_id;
			        		pstVpws->nni_info_cb[i].slot_id = stPortInfo.slot_id;
			        	}

						pstVpws->nni_info_cb[i].port_type = stPortInfo.port_type;
			        }

	                //如果VC存在，且已经属于VP中，更新VPN QOS
	                if ((pstVc->vc_info_cb.vp_idx != 0) && (pstVc->up_vpn_cfg_cb != NULL))
	                {	                    
	                    ret = spm_hqos_add_vc_node(pstVc->vc_info_cb.slot_id, 
	                                               pstVc->vc_info_cb.port_id, 
	                                               pstVc->vc_info_cb.vp_idx, 
	                                               pstVc->vc_info_cb.if_main,
	                                               &stQosTunKey,
	                                               &pstVpInfoRefresh->vc_key,
	                                               pstVc->up_vpn_cfg_cb
	                                               NBB_CCXT);

	                    if (ret != SUCCESS)
	                    {
					        OS_PRINTF("***ERROR***:要反刷的VC_ID=%ld VC_TYPE=%d PEER_IP=%s 的VC表配HQOS失败(VPWS VC_MAIN) vp_id=%ld !\n", pstVpInfoRefresh->vc_key.vc_id, 
					                                                                                                pstVpInfoRefresh->vc_key.vc_type, 
					                                                                                                spm_set_ulong_to_ipv4(pstVpInfoRefresh->vc_key.peer_ip),
					                                                                                                pstVc->vc_info_cb.vp_idx NBB_CCXT);

					        OS_SPRINTF(ucMessage, "***ERROR***:要反刷的VC_ID=%ld VC_TYPE=%d PEER_IP=%s 的VC表配HQOS失败(VPWS VC_MAIN) vp_id=%ld !\n", pstVpInfoRefresh->vc_key.vc_id, 
					                                                                                                pstVpInfoRefresh->vc_key.vc_type, 
					                                                                                                spm_set_ulong_to_ipv4(pstVpInfoRefresh->vc_key.peer_ip),
					                                                                                                pstVc->vc_info_cb.vp_idx NBB_CCXT);
					        BMU_SLOG(BMU_INFO, SPM_L2_LOG_DIR, ucMessage);

					        NBB_EXCEPTION((PCT_SPM | VC_PD, 0, "ld d s d s s", pstVpInfoRefresh->vc_key.vc_id, 
					                                                         pstVpInfoRefresh->vc_key.vc_type, 
					                                                         spm_set_ulong_to_ipv4(pstVpInfoRefresh->vc_key.peer_ip NBB_CCXT), 
					                                                         CALL_FUNC_ERROR, 
					                                                         "CALL_FUNC_ERROR", 
					                                                         ucMessage));
					        //ret = ERROR;
					        //goto EXIT_LABEL;
					    }
	                }

		    		break;
		    	}
		    }
		}
		else if (pstVpInfoRefresh->if_main == VC_BACK)
		{
			for (i=0; i<ATG_DCI_VPWS_NNI_NUM; i++)
		    {
		    	if ((pstVpws->nni_cfg_cb[i] != NULL)
		    	 && (pstVpws->nni_cfg_cb[i]->vc_id_bak == pstVpInfoRefresh->vc_key.vc_id)
		    	 && (pstVpws->nni_cfg_cb[i]->vc_type_bak == pstVpInfoRefresh->vc_key.vc_type)
		    	 && (pstVpws->nni_cfg_cb[i]->peer_ip_bak == pstVpInfoRefresh->vc_key.peer_ip))
		    	{
		    	
	                //如果VC存在，且已经属于VP中，删除VPN QOS
	                if ((pstVc->vc_info_cb.vp_idx != 0) && (pstVc->up_vpn_cfg_cb != NULL))
	                {
	                	stVcUpVpnQosPolicy.node_index = pstVc->up_vpn_cfg_cb->node_index;
	                	
	                    ret = spm_hqos_add_vc_node(pstVc->vc_info_cb.slot_id, 
	                                               pstVc->vc_info_cb.port_id, 
	                                               pstVc->vc_info_cb.vp_idx, 
	                                               pstVc->vc_info_cb.if_main,
	                                               &stQosTunKey,
	                                               &pstVpInfoRefresh->vc_key,
	                                               &stVcUpVpnQosPolicy
	                                               NBB_CCXT);
	                }
	                
		    		pstVpws->nni_info_cb[i].port_index = ulPortIndexNew;

			        ret = spm_get_portid_from_logical_port_index(ulPortIndexNew, &stPortInfo NBB_CCXT);

			        if (ret == SUCCESS)
			        {
			        	pstVc->vc_info_cb.port_index = ulPortIndexNew;
			        	pstVc->vc_info_cb.port_id = stPortInfo.port_id;

			        	if (stPortInfo.port_type == ATG_DCI_LAG)
			        	{
			        		pstVc->vc_info_cb.slot_id = stPortInfo.lag_slot_id;
			        		pstVpws->nni_info_cb[i].slot_id = stPortInfo.lag_slot_id;
			        	}
			        	else
			        	{
			        		pstVc->vc_info_cb.slot_id = stPortInfo.slot_id;
			        		pstVpws->nni_info_cb[i].slot_id = stPortInfo.slot_id;
			        	}

						pstVpws->nni_info_cb[i].port_type = stPortInfo.port_type;
			        }

	                //如果VC存在，且已经属于VP中，更新VPN QOS
	                if ((pstVc->vc_info_cb.vp_idx != 0) && (pstVc->up_vpn_cfg_cb != NULL))
	                {	                    
	                    ret = spm_hqos_add_vc_node(pstVc->vc_info_cb.slot_id, 
	                                               pstVc->vc_info_cb.port_id, 
	                                               pstVc->vc_info_cb.vp_idx, 
	                                               pstVc->vc_info_cb.if_main,
	                                               &stQosTunKey,
	                                               &pstVpInfoRefresh->vc_key,
	                                               pstVc->up_vpn_cfg_cb
	                                               NBB_CCXT);

	                    if (ret != SUCCESS)
	                    {
					        OS_PRINTF("***ERROR***:要反刷的VC_ID=%ld VC_TYPE=%d PEER_IP=%s 的VC表配HQOS失败(VPWS VC_BACK) vp_id=%ld !\n", pstVpInfoRefresh->vc_key.vc_id, 
					                                                                                                pstVpInfoRefresh->vc_key.vc_type, 
					                                                                                                spm_set_ulong_to_ipv4(pstVpInfoRefresh->vc_key.peer_ip),
					                                                                                                pstVc->vc_info_cb.vp_idx NBB_CCXT);

					        OS_SPRINTF(ucMessage, "***ERROR***:要反刷的VC_ID=%ld VC_TYPE=%d PEER_IP=%s 的VC表配HQOS失败(VPWS VC_BACK) vp_id=%ld !\n", pstVpInfoRefresh->vc_key.vc_id, 
					                                                                                                pstVpInfoRefresh->vc_key.vc_type, 
					                                                                                                spm_set_ulong_to_ipv4(pstVpInfoRefresh->vc_key.peer_ip),
					                                                                                                pstVc->vc_info_cb.vp_idx NBB_CCXT);
					        BMU_SLOG(BMU_INFO, SPM_L2_LOG_DIR, ucMessage);

					        NBB_EXCEPTION((PCT_SPM | VC_PD, 0, "ld d s d s s", pstVpInfoRefresh->vc_key.vc_id, 
					                                                         pstVpInfoRefresh->vc_key.vc_type, 
					                                                         spm_set_ulong_to_ipv4(pstVpInfoRefresh->vc_key.peer_ip NBB_CCXT), 
					                                                         CALL_FUNC_ERROR, 
					                                                         "CALL_FUNC_ERROR", 
					                                                         ucMessage));
					        //ret = ERROR;
					        //goto EXIT_LABEL;
					    }
	                }
	                
		    		break;
		    	}
		    }
		}
		else
		{
	        NBB_TRC_DETAIL((NBB_FORMAT "  ***ERROR***: spm_vpn_refresh_vc_nni_cfg(if_main==0)"));

	        //OS_PRINTF("***ERROR***: spm_vpn_refresh_vc_nni_cfg(if_main==0)\n");

			OS_SPRINTF(ucMessage, "***ERROR***: spm_vpn_refresh_vc_nni_cfg(if_main==0)\n");
	        BMU_SLOG(BMU_INFO, SPM_L2_LOG_DIR, ucMessage);
	        
	        NBB_EXCEPTION((PCT_SPM | VPWS_PD, 0, "ld d s s", pstVpInfoRefresh->vpn_id, 
	                                                         FUNC_IN_PARAM_IS_NULL, 
	                                                         "FUNC_IN_PARAM_IS_NULL", 
	                                                         ucMessage));
	        ret = ERROR;
	        goto EXIT_LABEL;
		}
	}
	else if (pstVpInfoRefresh->vpn_type == L2VPN_VPLS)
	{
		//反刷的VC不存在，退出处理
		pstVc = AVLL_FIND(SHARED.vc_tree, &pstVpInfoRefresh->vc_key);

		if ((pstVc == NULL) || (pstVc->basic_cfg_cb == NULL))
		{
	        OS_PRINTF("***ERROR***:要反刷的VC_ID=%ld VC_TYPE=%d PEER_IP=%s 的VC表配置并不存在!\n", pstVpInfoRefresh->vc_key.vc_id, 
	                                                                                                pstVpInfoRefresh->vc_key.vc_type, 
	                                                                                                spm_set_ulong_to_ipv4(pstVpInfoRefresh->vc_key.peer_ip NBB_CCXT));

	        OS_SPRINTF(ucMessage, "***ERROR***:要反刷的VC_ID=%ld VC_TYPE=%d PEER_IP=%s 的VC表配置并不存在!\n", pstVpInfoRefresh->vc_key.vc_id, 
	                                                                                                pstVpInfoRefresh->vc_key.vc_type, 
	                                                                                                spm_set_ulong_to_ipv4(pstVpInfoRefresh->vc_key.peer_ip NBB_CCXT));
	        BMU_SLOG(BMU_INFO, SPM_L2_LOG_DIR, ucMessage);

	        NBB_EXCEPTION((PCT_SPM | VC_PD, 0, "ld d s d s s", pstVpInfoRefresh->vc_key.vc_id, 
	                                                         pstVpInfoRefresh->vc_key.vc_type, 
	                                                         spm_set_ulong_to_ipv4(pstVpInfoRefresh->vc_key.peer_ip NBB_CCXT), 
	                                                         DEL_UNEXIST_CONFIG_ERROR, 
	                                                         "DEL_UNEXIST_CONFIG_ERROR", 
	                                                         ucMessage));
	        ret = ERROR;
	        goto EXIT_LABEL;
	    }

    	stQosTunKey.flag   			= 1;
    	stQosTunKey.type   			= pstVc->basic_cfg_cb->lsp_option;                	
        stQosTunKey.tx_lsp.egress   = pstVc->basic_cfg_cb->egress;
        stQosTunKey.tx_lsp.ingress  = pstVc->basic_cfg_cb->ingress;
        stQosTunKey.tx_lsp.tunnelid = pstVc->basic_cfg_cb->tunnel_id;
        stQosTunKey.ftn.fec			= pstVc->basic_cfg_cb->next_hop_ip;
        stQosTunKey.ftn.mask        = 32;
        stQosTunKey.ftn.vrfid       = 0;
        
		pstVpls = AVLL_FIND(SHARED.vpls_tree, &pstVpInfoRefresh->vpn_id);

		if (pstVpls == NULL)
		{
	        NBB_TRC_FLOW((NBB_FORMAT "  ***ERROR***:要刷新 VPLS_ID=%d 的VPLS配置并不存在!\n", pstVpInfoRefresh->vpn_id));

	        //OS_PRINTF("***ERROR***:要刷新 VPLS_ID=%d 的VPLS配置并不存在!\n", pstVpInfoRefresh->vpn_id);

	        OS_SPRINTF(ucMessage, "***ERROR***:要刷新 VPLS_ID=%d 的VPLS配置并不存在!\n", pstVpInfoRefresh->vpn_id);
	        BMU_SLOG(BMU_INFO, SPM_L2_LOG_DIR, ucMessage);

	        NBB_EXCEPTION((PCT_SPM | VPLS_PD, 0, "ld d s s", pstVpInfoRefresh->vpn_id, 
	                                                         DEL_UNEXIST_CONFIG_ERROR, 
	                                                         "DEL_UNEXIST_CONFIG_ERROR", 
	                                                         ucMessage));
	        ret = ERROR;            
	        goto EXIT_LABEL;
	    }

	    if (pstVpInfoRefresh->if_main == VC_MAIN)
	    {
	    	for (i=0; i<ATG_DCI_VPLS_NNI_NUM; i++)
		    {
		    	if ((pstVpls->nni_cfg_cb[i] != NULL)
		    	 && (pstVpls->nni_cfg_cb[i]->vc_id == pstVpInfoRefresh->vc_key.vc_id)
		    	 && (pstVpls->nni_cfg_cb[i]->vc_type == pstVpInfoRefresh->vc_key.vc_type)
		    	 && (pstVpls->nni_cfg_cb[i]->peer_ip == pstVpInfoRefresh->vc_key.peer_ip))
		    	{
	                //如果VC存在，且已经属于VP中，删除VPN QOS
	                if ((pstVc->vc_info_cb.vp_idx != 0) && (pstVc->up_vpn_cfg_cb != NULL))
	                {
	                	stVcUpVpnQosPolicy.node_index = pstVc->up_vpn_cfg_cb->node_index;
	                	
	                    ret = spm_hqos_add_vc_node(pstVc->vc_info_cb.slot_id, 
	                                               pstVc->vc_info_cb.port_id, 
	                                               pstVc->vc_info_cb.vp_idx, 
	                                               pstVc->vc_info_cb.if_main,
	                                               &stQosTunKey,
	                                               &pstVpInfoRefresh->vc_key,
	                                               &stVcUpVpnQosPolicy
	                                               NBB_CCXT);
	                }
	                
		    		pstVpls->nni_info_cb[i].port_index = ulPortIndexNew;

			        ret = spm_get_portid_from_logical_port_index(ulPortIndexNew, &stPortInfo NBB_CCXT);

			        if (ret == SUCCESS)
			        {
			        	pstVc->vc_info_cb.port_index = ulPortIndexNew;
			        	pstVc->vc_info_cb.port_id = stPortInfo.port_id;

			        	if (stPortInfo.port_type == ATG_DCI_LAG)
			        	{
			        		pstVc->vc_info_cb.slot_id = stPortInfo.lag_slot_id;
			        		pstVpls->nni_info_cb[i].slot_id = stPortInfo.lag_slot_id;
			        	}
			        	else
			        	{
			        		pstVc->vc_info_cb.slot_id = stPortInfo.slot_id;
			        		pstVpls->nni_info_cb[i].slot_id = stPortInfo.slot_id;
			        	}

						pstVpls->nni_info_cb[i].port_type = stPortInfo.port_type;
			        }

	                //如果VC存在，且已经属于VP中，更新VPN QOS
	                if ((pstVc->vc_info_cb.vp_idx != 0) && (pstVc->up_vpn_cfg_cb != NULL))
	                {	                    
	                    ret = spm_hqos_add_vc_node(pstVc->vc_info_cb.slot_id, 
	                                               pstVc->vc_info_cb.port_id, 
	                                               pstVc->vc_info_cb.vp_idx, 
	                                               pstVc->vc_info_cb.if_main,
	                                               &stQosTunKey,
	                                               &pstVpInfoRefresh->vc_key,
	                                               pstVc->up_vpn_cfg_cb
	                                               NBB_CCXT);

	                    if (ret != SUCCESS)
	                    {
					        OS_PRINTF("***ERROR***:要反刷的VC_ID=%ld VC_TYPE=%d PEER_IP=%s 的VC表配HQOS失败(VPLS VC_MAIN) vp_id=%ld !\n", pstVpInfoRefresh->vc_key.vc_id, 
					                                                                                                pstVpInfoRefresh->vc_key.vc_type, 
					                                                                                                spm_set_ulong_to_ipv4(pstVpInfoRefresh->vc_key.peer_ip),
					                                                                                                pstVc->vc_info_cb.vp_idx NBB_CCXT);

					        OS_SPRINTF(ucMessage, "***ERROR***:要反刷的VC_ID=%ld VC_TYPE=%d PEER_IP=%s 的VC表配HQOS失败(VPLS VC_MAIN) vp_id=%ld !\n", pstVpInfoRefresh->vc_key.vc_id, 
					                                                                                                pstVpInfoRefresh->vc_key.vc_type, 
					                                                                                                spm_set_ulong_to_ipv4(pstVpInfoRefresh->vc_key.peer_ip),
					                                                                                                pstVc->vc_info_cb.vp_idx NBB_CCXT);
					        BMU_SLOG(BMU_INFO, SPM_L2_LOG_DIR, ucMessage);

					        NBB_EXCEPTION((PCT_SPM | VC_PD, 0, "ld d s d s s", pstVpInfoRefresh->vc_key.vc_id, 
					                                                         pstVpInfoRefresh->vc_key.vc_type, 
					                                                         spm_set_ulong_to_ipv4(pstVpInfoRefresh->vc_key.peer_ip NBB_CCXT), 
					                                                         CALL_FUNC_ERROR, 
					                                                         "CALL_FUNC_ERROR", 
					                                                         ucMessage));
					        //ret = ERROR;
					        //goto EXIT_LABEL;
					    }
	                }
	                
		    		break;
		    	}
		    }
		}
		else if (pstVpInfoRefresh->if_main == VC_BACK)
		{
			for (i=0; i<ATG_DCI_VPLS_NNI_NUM; i++)
		    {
		    	if ((pstVpls->nni_cfg_cb[i] != NULL)
		    	 && (pstVpls->nni_cfg_cb[i]->vc_id_bak == pstVpInfoRefresh->vc_key.vc_id)
		    	 && (pstVpls->nni_cfg_cb[i]->vc_type_bak == pstVpInfoRefresh->vc_key.vc_type)
		    	 && (pstVpls->nni_cfg_cb[i]->peer_ip_bak == pstVpInfoRefresh->vc_key.peer_ip))
		    	{
	                //如果VC存在，且已经属于VP中，删除VPN QOS
	                if ((pstVc->vc_info_cb.vp_idx != 0) && (pstVc->up_vpn_cfg_cb != NULL))
	                {
	                	stVcUpVpnQosPolicy.node_index = pstVc->up_vpn_cfg_cb->node_index;
	                	
	                    ret = spm_hqos_add_vc_node(pstVc->vc_info_cb.slot_id, 
	                                               pstVc->vc_info_cb.port_id, 
	                                               pstVc->vc_info_cb.vp_idx, 
	                                               pstVc->vc_info_cb.if_main,
	                                               &stQosTunKey,
	                                               &pstVpInfoRefresh->vc_key,
	                                               &stVcUpVpnQosPolicy
	                                               NBB_CCXT);
	                }
	                
		    		pstVpls->nni_info_cb[i].port_index = ulPortIndexNew;

			        ret = spm_get_portid_from_logical_port_index(ulPortIndexNew, &stPortInfo NBB_CCXT);

			        if (ret == SUCCESS)
			        {
			        	pstVc->vc_info_cb.port_index = ulPortIndexNew;
			        	pstVc->vc_info_cb.port_id = stPortInfo.port_id;

			        	if (stPortInfo.port_type == ATG_DCI_LAG)
			        	{
			        		pstVc->vc_info_cb.slot_id = stPortInfo.lag_slot_id;
			        		pstVpls->nni_info_cb[i].slot_id = stPortInfo.lag_slot_id;
			        	}
			        	else
			        	{
			        		pstVc->vc_info_cb.slot_id = stPortInfo.slot_id;
			        		pstVpls->nni_info_cb[i].slot_id = stPortInfo.slot_id;
			        	}

						pstVpls->nni_info_cb[i].port_type = stPortInfo.port_type;
			        }

	                //如果VC存在，且已经属于VP中，更新VPN QOS
	                if ((pstVc->vc_info_cb.vp_idx != 0) && (pstVc->up_vpn_cfg_cb != NULL))
	                {	                    
	                    ret = spm_hqos_add_vc_node(pstVc->vc_info_cb.slot_id, 
	                                               pstVc->vc_info_cb.port_id, 
	                                               pstVc->vc_info_cb.vp_idx, 
	                                               pstVc->vc_info_cb.if_main,
	                                               &stQosTunKey,
	                                               &pstVpInfoRefresh->vc_key,
	                                               pstVc->up_vpn_cfg_cb
	                                               NBB_CCXT);

	                    if (ret != SUCCESS)
	                    {
					        OS_PRINTF("***ERROR***:要反刷的VC_ID=%ld VC_TYPE=%d PEER_IP=%s 的VC表配HQOS失败(VPLS VC_BACK) vp_id=%ld !\n", pstVpInfoRefresh->vc_key.vc_id, 
					                                                                                                pstVpInfoRefresh->vc_key.vc_type, 
					                                                                                                spm_set_ulong_to_ipv4(pstVpInfoRefresh->vc_key.peer_ip),
					                                                                                                pstVc->vc_info_cb.vp_idx NBB_CCXT);

					        OS_SPRINTF(ucMessage, "***ERROR***:要反刷的VC_ID=%ld VC_TYPE=%d PEER_IP=%s 的VC表配HQOS失败(VPLS VC_BACK) vp_id=%ld !\n", pstVpInfoRefresh->vc_key.vc_id, 
					                                                                                                pstVpInfoRefresh->vc_key.vc_type, 
					                                                                                                spm_set_ulong_to_ipv4(pstVpInfoRefresh->vc_key.peer_ip),
					                                                                                                pstVc->vc_info_cb.vp_idx NBB_CCXT);
					        BMU_SLOG(BMU_INFO, SPM_L2_LOG_DIR, ucMessage);

					        NBB_EXCEPTION((PCT_SPM | VC_PD, 0, "ld d s d s s", pstVpInfoRefresh->vc_key.vc_id, 
					                                                         pstVpInfoRefresh->vc_key.vc_type, 
					                                                         spm_set_ulong_to_ipv4(pstVpInfoRefresh->vc_key.peer_ip NBB_CCXT), 
					                                                         CALL_FUNC_ERROR, 
					                                                         "CALL_FUNC_ERROR", 
					                                                         ucMessage));
					        //ret = ERROR;
					        //goto EXIT_LABEL;
					    }
	                }
	                
		    		break;
		    	}
		    }
		}
		else
		{
	        NBB_TRC_DETAIL((NBB_FORMAT "  ***ERROR***: spm_vpn_refresh_vc_nni_cfg(if_main==0)"));

	        //OS_PRINTF("***ERROR***: spm_vpn_refresh_vc_nni_cfg(if_main==0)\n");

			OS_SPRINTF(ucMessage, "***ERROR***: spm_vpn_refresh_vc_nni_cfg(if_main==0)\n");
	        BMU_SLOG(BMU_INFO, SPM_L2_LOG_DIR, ucMessage);
	        
	        NBB_EXCEPTION((PCT_SPM | VPLS_PD, 0, "ld d s s", pstVpInfoRefresh->vpn_id, 
	                                                         FUNC_IN_PARAM_IS_NULL, 
	                                                         "FUNC_IN_PARAM_IS_NULL", 
	                                                         ucMessage));
	        ret = ERROR;
	        goto EXIT_LABEL;
		}
	}
	else if (pstVpInfoRefresh->vpn_type == L2VPN_MSPW)
	{
	
            //L2VPN_MSPW 业务可能不与VC表关联，所以能不能找到对应的VC表配置都正常
            //能找到，说明绑定了QOS，需要处理
            pstVc = AVLL_FIND(SHARED.vc_tree, &pstVpInfoRefresh->vc_key);

            if ((pstVc != NULL) && (pstVc->basic_cfg_cb != NULL))
            {
            
                /*
                pstVpInfoRefresh->vc_key.vc_type, 
                spm_set_ulong_to_ipv4(pstVpInfoRefresh->vc_key.peer_ip NBB_CCXT));
                BMU_SLOG(BMU_INFO, SPM_L2_LOG_DIR, ucMessage);

                NBB_EXCEPTION((PCT_SPM | VC_PD, 0, "ld d s d s s", pstVpInfoRefresh->vc_key.vc_id, 
                pstVpInfoRefresh->vc_key.vc_type, 
                spm_set_ulong_to_ipv4(pstVpInfoRefresh->vc_key.peer_ip NBB_CCXT), 
                DEL_UNEXIST_CONFIG_ERROR, 
                "DEL_UNEXIST_CONFIG_ERROR", 
                ucMessage));
                ret = ERROR;
                goto EXIT_LABEL;*/
                stQosTunKey.flag   			= 1;
                stQosTunKey.type   			= pstVc->basic_cfg_cb->lsp_option;                	
                stQosTunKey.tx_lsp.egress   = pstVc->basic_cfg_cb->egress;
                stQosTunKey.tx_lsp.ingress  = pstVc->basic_cfg_cb->ingress;
                stQosTunKey.tx_lsp.tunnelid = pstVc->basic_cfg_cb->tunnel_id;
                stQosTunKey.ftn.fec			= pstVc->basic_cfg_cb->next_hop_ip;
                stQosTunKey.ftn.mask        = 32;
                stQosTunKey.ftn.vrfid       = 0;

            }

		ulSwitchVcKey = (NBB_ULONG)pstVpInfoRefresh->vpn_id;
		
		pstSwitchVc = AVLL_FIND(SHARED.switch_vc_tree, &ulSwitchVcKey);

		if (pstSwitchVc == NULL)
		{
	        NBB_TRC_FLOW((NBB_FORMAT 
                    "  ***ERROR***:要刷新 SWITCH_ID=%ld 的SWITCH_VC配置并不存在!\n", ulSwitchVcKey));

	        //OS_PRINTF("***ERROR***:要刷新 VPWS_ID=%d 的VPWS配置并不存在!\n", stVpInfoRefresh.vpn_id);

	        OS_SPRINTF(ucMessage, 
	            "***ERROR***:要刷新 SWITCH_ID=%ld 的SWITCH_VC配置并不存在!\n", ulSwitchVcKey);
	        BMU_SLOG(BMU_INFO, SPM_L2_LOG_DIR, ucMessage);

	        NBB_EXCEPTION((PCT_SPM | SWITCH_VC_PD, 0, "ld d s s", ulSwitchVcKey, 
	                                                         DEL_UNEXIST_CONFIG_ERROR, 
	                                                         "DEL_UNEXIST_CONFIG_ERROR", 
	                                                         ucMessage));
	        ret = ERROR;            
	        goto EXIT_LABEL;
	    }

	    if (pstVpInfoRefresh->if_main == VC_MAIN)
	    {
	    
                if ((pstSwitchVc->vc1_cfg_cb != NULL)
                    && (pstSwitchVc->vc1_cfg_cb->vc_id == pstVpInfoRefresh->vc_key.vc_id)
                    && (pstSwitchVc->vc1_cfg_cb->vc_type == pstVpInfoRefresh->vc_key.vc_type)
                    && (pstSwitchVc->vc1_cfg_cb->peer_ip == pstVpInfoRefresh->vc_key.peer_ip))
                {

                    //如果VC存在，且已经属于VP中，删除VPN QOS
                    if ((pstVc != NULL) && (pstVc->basic_cfg_cb != NULL) 
                        && (pstVc->vc_info_cb.vp_idx != 0) && (pstVc->up_vpn_cfg_cb != NULL))
                    {
                        stVcUpVpnQosPolicy.node_index = pstVc->up_vpn_cfg_cb->node_index;

                        ret = spm_hqos_add_vc_node(pstVc->vc_info_cb.slot_id, 
                            pstVc->vc_info_cb.port_id, 
                            pstVc->vc_info_cb.vp_idx, 
                            pstVc->vc_info_cb.if_main,
                            &stQosTunKey,
                            &pstVpInfoRefresh->vc_key,
                            &stVcUpVpnQosPolicy
                            NBB_CCXT);
                    }

                    pstSwitchVc->vc1_info_cb.port_index = ulPortIndexNew;

                    ret = spm_get_portid_from_logical_port_index(ulPortIndexNew, &stPortInfo NBB_CCXT);

                    if (ret == SUCCESS)
                    {
                        pstSwitchVc->vc1_info_cb.port_type = stPortInfo.port_type;

                        if (stPortInfo.port_type == ATG_DCI_LAG)
                        {
                            pstSwitchVc->vc1_info_cb.slot_id = stPortInfo.lag_slot_id;
                        }
                        else
                        {
                            pstSwitchVc->vc1_info_cb.slot_id = stPortInfo.slot_id;
                        }

                        if((pstVc != NULL) && (pstVc->basic_cfg_cb != NULL))
                        {
                        
                            //不更新port_index，这样的话可以看到反刷之前的port_index，而反刷
                            //之后的port_index 可以在switch vc的驱动返回信息中看到。并且，如果
                            //发生了反刷，switch vc的驱动返回信息中会多出slo_idt和port_id。
                            //pstVc->vc_info_cb.port_index = ulPortIndexNew;
                            pstVc->vc_info_cb.port_id = stPortInfo.port_id;

                            if (stPortInfo.port_type == ATG_DCI_LAG)
                            {
                                pstVc->vc_info_cb.slot_id = stPortInfo.lag_slot_id;
                            }
                            else
                            {
                                pstVc->vc_info_cb.slot_id = stPortInfo.slot_id;
                            }
                        }
                    }

                    //如果VC存在，且已经属于VP中，更新VPN QOS
                    if ((pstVc != NULL) && (pstVc->basic_cfg_cb != NULL)  
                        && (pstVc->vc_info_cb.vp_idx != 0) && (pstVc->up_vpn_cfg_cb != NULL))
                    {	                    
                        ret = spm_hqos_add_vc_node(pstVc->vc_info_cb.slot_id, 
                            pstVc->vc_info_cb.port_id, 
                            pstVc->vc_info_cb.vp_idx, 
                            pstVc->vc_info_cb.if_main,
                            &stQosTunKey,
                            &pstVpInfoRefresh->vc_key,
                            pstVc->up_vpn_cfg_cb
                            NBB_CCXT);

                        if (ret != SUCCESS)
                        {
                            OS_PRINTF
                            ("***ERROR***:要反刷的VC_ID=%ld VC_TYPE=%d PEER_IP=%s 的VC表配HQOS失败(MSPW VC_MAIN) vp_id=%ld !\n", 
                                pstVpInfoRefresh->vc_key.vc_id, 
                                pstVpInfoRefresh->vc_key.vc_type, 
                                spm_set_ulong_to_ipv4(pstVpInfoRefresh->vc_key.peer_ip),
                                pstVc->vc_info_cb.vp_idx NBB_CCXT);

                            OS_SPRINTF(ucMessage, 
                            "***ERROR***:要反刷的VC_ID=%ld VC_TYPE=%d PEER_IP=%s 的VC表配HQOS失败(MSPW VC_MAIN) vp_id=%ld !\n", 
                                pstVpInfoRefresh->vc_key.vc_id, 
                                pstVpInfoRefresh->vc_key.vc_type, 
                                spm_set_ulong_to_ipv4(pstVpInfoRefresh->vc_key.peer_ip),
                                pstVc->vc_info_cb.vp_idx NBB_CCXT);
                            BMU_SLOG(BMU_INFO, SPM_L2_LOG_DIR, ucMessage);

                            NBB_EXCEPTION((PCT_SPM | VC_PD, 0, "ld d s d s s", pstVpInfoRefresh->vc_key.vc_id, 
                                pstVpInfoRefresh->vc_key.vc_type, 
                                spm_set_ulong_to_ipv4(pstVpInfoRefresh->vc_key.peer_ip NBB_CCXT), 
                                CALL_FUNC_ERROR, 
                                "CALL_FUNC_ERROR", 
                                ucMessage));
                            
                            //ret = ERROR;
                            //goto EXIT_LABEL;
                            
                        }
                    }	    		
                
	    	}
            
	    	else if ((pstSwitchVc->vc2_cfg_cb != NULL)
	    	 && (pstSwitchVc->vc2_cfg_cb->vc_id == pstVpInfoRefresh->vc_key.vc_id)
	    	 && (pstSwitchVc->vc2_cfg_cb->vc_type == pstVpInfoRefresh->vc_key.vc_type)
	    	 && (pstSwitchVc->vc2_cfg_cb->peer_ip == pstVpInfoRefresh->vc_key.peer_ip))
	    	{
                    //如果VC存在，且已经属于VP中，删除VPN QOS
                    if ((pstVc != NULL) && (pstVc->basic_cfg_cb != NULL) 
                        && (pstVc->vc_info_cb.vp_idx != 0) && (pstVc->up_vpn_cfg_cb != NULL))
                    {
                        stVcUpVpnQosPolicy.node_index = pstVc->up_vpn_cfg_cb->node_index;

                        ret = spm_hqos_add_vc_node(pstVc->vc_info_cb.slot_id, 
                            pstVc->vc_info_cb.port_id, 
                            pstVc->vc_info_cb.vp_idx, 
                            pstVc->vc_info_cb.if_main,
                            &stQosTunKey,
                            &pstVpInfoRefresh->vc_key,
                            &stVcUpVpnQosPolicy
                            NBB_CCXT);
                    }

                    pstSwitchVc->vc2_info_cb.port_index = ulPortIndexNew;

                    ret = spm_get_portid_from_logical_port_index(ulPortIndexNew, &stPortInfo NBB_CCXT);

                    if (ret == SUCCESS)
                    {
                        pstSwitchVc->vc2_info_cb.port_type = stPortInfo.port_type;

                        if (stPortInfo.port_type == ATG_DCI_LAG)
                        {
                            pstSwitchVc->vc2_info_cb.slot_id = stPortInfo.lag_slot_id;
                        }
                        else
                        {
                            pstSwitchVc->vc2_info_cb.slot_id = stPortInfo.slot_id;
                        }

                        if((pstVc != NULL) && (pstVc->basic_cfg_cb != NULL))
                        {
                        
                            //不更新port_index，这样的话可以看到反刷之前的port_index，而反刷
                            //之后的port_index 可以在switch vc的驱动返回信息中看到。并且，如果
                            //发生了反刷，switch vc的驱动返回信息中会多出slo_idt和port_id。                        
                            //pstVc->vc_info_cb.port_index = ulPortIndexNew;
                            pstVc->vc_info_cb.port_id = stPortInfo.port_id;

                            if (stPortInfo.port_type == ATG_DCI_LAG)
                            {
                                pstVc->vc_info_cb.slot_id = stPortInfo.lag_slot_id;
                            }
                            else
                            {
                                pstVc->vc_info_cb.slot_id = stPortInfo.slot_id;
                            }
                        }
                    }

                    //如果VC存在，且已经属于VP中，更新VPN QOS
                    if ((pstVc != NULL) && (pstVc->basic_cfg_cb != NULL)  
                        && (pstVc->vc_info_cb.vp_idx != 0) && (pstVc->up_vpn_cfg_cb != NULL))
                    {	                    
                        ret = spm_hqos_add_vc_node(pstVc->vc_info_cb.slot_id, 
                            pstVc->vc_info_cb.port_id, 
                            pstVc->vc_info_cb.vp_idx, 
                            pstVc->vc_info_cb.if_main,
                            &stQosTunKey,
                            &pstVpInfoRefresh->vc_key,
                            pstVc->up_vpn_cfg_cb
                            NBB_CCXT);

                        if (ret != SUCCESS)
                        {
                            OS_PRINTF
                            ("***ERROR***:要反刷的VC_ID=%ld VC_TYPE=%d PEER_IP=%s 的VC表配HQOS失败(MSPW VC_MAIN) vp_id=%ld !\n",
                                pstVpInfoRefresh->vc_key.vc_id, 
                                pstVpInfoRefresh->vc_key.vc_type, 
                                spm_set_ulong_to_ipv4(pstVpInfoRefresh->vc_key.peer_ip),
                                pstVc->vc_info_cb.vp_idx NBB_CCXT);

                            OS_SPRINTF(ucMessage,
                            "***ERROR***:要反刷的VC_ID=%ld VC_TYPE=%d PEER_IP=%s 的VC表配HQOS失败(MSPW VC_MAIN) vp_id=%ld !\n",
                                pstVpInfoRefresh->vc_key.vc_id, 
                                pstVpInfoRefresh->vc_key.vc_type, 
                                spm_set_ulong_to_ipv4(pstVpInfoRefresh->vc_key.peer_ip),
                                pstVc->vc_info_cb.vp_idx NBB_CCXT);
                            BMU_SLOG(BMU_INFO, SPM_L2_LOG_DIR, ucMessage);

                            NBB_EXCEPTION((PCT_SPM | VC_PD, 0, "ld d s d s s", pstVpInfoRefresh->vc_key.vc_id, 
                                pstVpInfoRefresh->vc_key.vc_type, 
                                spm_set_ulong_to_ipv4(pstVpInfoRefresh->vc_key.peer_ip NBB_CCXT), 
                                CALL_FUNC_ERROR, 
                                "CALL_FUNC_ERROR", 
                                ucMessage));
                            
                            //ret = ERROR;
                            //goto EXIT_LABEL;
                            
                        }
                    }	    		

	    	}
		}
		else
		{
	        NBB_TRC_DETAIL((NBB_FORMAT "  ***ERROR***: spm_vpn_refresh_vc_nni_cfg(if_main==0)"));

	        //OS_PRINTF("***ERROR***: spm_vpn_refresh_vc_nni_cfg(if_main==0)\n");

			OS_SPRINTF(ucMessage, "***ERROR***: spm_vpn_refresh_vc_nni_cfg(if_main==0)\n");
	        BMU_SLOG(BMU_INFO, SPM_L2_LOG_DIR, ucMessage);
	        
	        NBB_EXCEPTION((PCT_SPM | VPWS_PD, 0, "ld d s s", pstVpInfoRefresh->vpn_id, 
	                                                         FUNC_IN_PARAM_IS_NULL, 
	                                                         "FUNC_IN_PARAM_IS_NULL", 
	                                                         ucMessage));
	        ret = ERROR;
	        goto EXIT_LABEL;
		}
	}
	else
	{
        NBB_TRC_DETAIL((NBB_FORMAT "  ***ERROR***: spm_vpn_refresh_vc_nni_cfg(ucVpnType==0)"));

        //OS_PRINTF("***ERROR***: spm_vpn_refresh_vc_nni_cfg(ucVpnType==0)\n");

		OS_SPRINTF(ucMessage, "***ERROR***: spm_vpn_refresh_vc_nni_cfg(ucVpnType==0)\n");
        BMU_SLOG(BMU_INFO, SPM_L2_LOG_DIR, ucMessage);
        
        NBB_EXCEPTION((PCT_SPM | VPWS_PD, 0, "ld d s s", pstVpInfoRefresh->vpn_id, 
                                                         FUNC_IN_PARAM_IS_NULL, 
                                                         "FUNC_IN_PARAM_IS_NULL", 
                                                         ucMessage));
        ret = ERROR;
        goto EXIT_LABEL;
	}

EXIT_LABEL :

	return ret;
}


/*****************************************************************************
   函 数 名  : spm_alloc_msp_group_id
   功能描述  : 为MSP保护预申请64个frr group id
   输入参数  : 无
   输出参数  : 无
   返 回 值  :
   调用函数  :
   被调函数  :
   修改历史      :
   1.日    期   : 2014年4月14日
    作    者   : xiaoxiang
    修改内容   : 新生成函数

*****************************************************************************/
NBB_VOID spm_alloc_msp_group_id(NBB_CXT_T NBB_CXT)
{
	NBB_INT i = 0;
	NBB_INT ret = 0;
	NBB_BYTE ucC3Unit = 0;
    NBB_USHORT usFrrGroupId = 0;

    NBB_TRC_ENTRY("spm_alloc_msp_group_id");

#ifdef SPU
	for (i=0; i<ATG_DCI_MSP_NUM; i++)
	{
        for (ucC3Unit = 0; ucC3Unit < SHARED.c3_num; ucC3Unit++)
        {
        	usFrrGroupId = 0;
            ret += ApiC3CreateFrrGroup(ucC3Unit, &usFrrGroupId, 0, 0);
        }

        SHARED.msp_frr_group_id[i] = usFrrGroupId;
	}
#endif

    NBB_TRC_EXIT();
}

/*****************************************************************************
   函 数 名  : spm_init_vpws_tree
   功能描述  : 初始化存储VPWS配置的树
   输入参数  : 无
   输出参数  : 无
   返 回 值  :
   调用函数  :
   被调函数  :

   修改历史      :
   1.日    期   : 2012年11月24日
    作    者   : xiaoxiang
    修改内容   : 新生成函数

*****************************************************************************/
NBB_VOID spm_init_vpws_tree(NBB_CXT_T NBB_CXT)
{
    NBB_BUF_SIZE avll_key_offset;

    NBB_TRC_ENTRY("spm_init_vpws_tree");

    avll_key_offset = NBB_OFFSETOF(SPM_VPWS_CB, vpws_id_key);/*lint !e413 */

    //NBB_TRC_DETAIL((NBB_FORMAT "Key offset set to %ld", avll_key_offset));

    AVLL_INIT_TREE(SHARED.vpws_tree, compare_ushort,
        (NBB_USHORT)avll_key_offset,
        (NBB_USHORT)NBB_OFFSETOF(SPM_VPWS_CB, spm_vpws_node));

    NBB_TRC_EXIT();
}

/*****************************************************************************
   函 数 名  : spm_alloc_vpws_cb
   功能描述  : VPWS结构内存空间分配
   输入参数  : NBB_CCXT_T NBB_CXT
   输出参数  : 无
   返 回 值  : SPM_VPWS_CB
   调用函数  :
   被调函数  :

   修改历史      :
   1.日    期   : 2012年10月12日
    作    者   : xiaoxiang
    修改内容   : 新生成函数

*****************************************************************************/
SPM_VPWS_CB *spm_alloc_vpws_cb(NBB_CXT_T NBB_CXT)
{
    NBB_INT i = 0;
    SPM_VPWS_CB *pstVpws = NULL;

    NBB_TRC_ENTRY("spm_alloc_vpws_cb");

    /* 分配一个新的VPWS配置条目。*/
    pstVpws = (SPM_VPWS_CB *)NBB_MM_ALLOC(sizeof(SPM_VPWS_CB), NBB_NORETRY_ACT, MEM_SPM_VPWS_CB);
    if (pstVpws == NULL)
    {
        NBB_TRC_FLOW((NBB_FORMAT "  ***ERROR***:申请VPWS条目空间为NULL!"));
        goto EXIT_LABEL;
    }

    /* 初始化VPWS配置条目 */
    OS_MEMSET(pstVpws, 0, sizeof(SPM_VPWS_CB));
    pstVpws->basic_cfg_cb = NULL;

    for (i = 0; i < 2; i++)
    {
        pstVpws->nni_cfg_cb[i] = NULL;
        pstVpws->uni_cfg_cb[i] = NULL;
    }

    /* 建立用于该VC表配置条目的句柄，作为异步消息交换的相关器。*/
    pstVpws->spm_vpws_handle = NBB_CREATE_HANDLE(pstVpws, HDL_SPM_VPWS_CB);

    /* 成功分配一个新的接口物理配置条目。*/
    NBB_TRC_DETAIL((NBB_FORMAT "SPM_VPWS_CB allocated at %p with handle %#lx",
            pstVpws, pstVpws->spm_vpws_handle));

    /* Initialize the AVLL node. */
    AVLL_INIT_NODE(pstVpws->spm_vpws_node);

EXIT_LABEL: NBB_TRC_EXIT();

    return(pstVpws);
}

/*****************************************************************************
   函 数 名  : spm_free_vpws_cb
   功能描述  : 释放VPWS结构体的内存
   输入参数  : SPM_VPWS_CB *pstVpws NBB_CCXT_T NBB_CXT
   输出参数  : 无
   返 回 值  :
   调用函数  :
   被调函数  :

   修改历史      :
   1.日    期   : 2012年11月8日
    作    者   : xiaoxiang
    修改内容   : 新生成函数

*****************************************************************************/
NBB_VOID spm_free_vpws_cb(SPM_VPWS_CB *pstVpws NBB_CCXT_T NBB_CXT)
{
    /***************************************************************************/
    /* Local Variables                                                         */
    /***************************************************************************/
    NBB_INT i = 0;

    NBB_TRC_ENTRY("spm_free_vpws_cb");
    
    /***************************************************************************/
    /* 检查控制块的正确性。                                                    */
    /***************************************************************************/
    NBB_ASSERT_MEMORY(pstVpws, sizeof(SPM_VPWS_CB), MEM_SPM_VPWS_CB);

    if (pstVpws == NULL)
    {
    	goto EXIT_LABEL;
    }
    
    /***************************************************************************/
    /* 删除单盘信息控制块。                                                    */
    /***************************************************************************/

    //NBB_TRC_FLOW((NBB_FORMAT "Free vpws cb at %p", pstVpws));
    NBB_TRC_FLOW((NBB_FORMAT "Free vpws_id %d", pstVpws->vpws_id_key));

    /***************************************************************************/
    /* 释放基本配置数据块。                                                */
    /***************************************************************************/
    if (pstVpws->basic_cfg_cb != NULL)
    {
        NBB_MM_FREE(pstVpws->basic_cfg_cb, MEM_SPM_VPWS_BASIC_CB);
        pstVpws->basic_cfg_cb = NULL;
    }

    /***************************************************************************/
    /* 释放NNI和UNI数据块。                                                */
    /***************************************************************************/
    for (i = 0; i < ATG_DCI_VPWS_NNI_NUM; i++)
    {
        if (pstVpws->nni_cfg_cb[i] != NULL)
        {
            NBB_MM_FREE(pstVpws->nni_cfg_cb[i], MEM_SPM_VPWS_NNI_CB);
            pstVpws->nni_cfg_cb[i] = NULL;
        }
    }

    for (i = 0; i < ATG_DCI_VPWS_UNI_NUM; i++)
    {
        if (pstVpws->uni_cfg_cb[i] != NULL)
        {
            NBB_MM_FREE(pstVpws->uni_cfg_cb[i], MEM_SPM_VPWS_UNI_CB);
            pstVpws->uni_cfg_cb[i] = NULL;
        }
    }

    /***************************************************************************/
    /* 释放Bypass PW配置数据块。                                                */
    /***************************************************************************/
    if (pstVpws->bypass_cfg_cb != NULL)
    {
        NBB_MM_FREE(pstVpws->bypass_cfg_cb, MEM_SPM_VPWS_BYPASS_CB);
        pstVpws->bypass_cfg_cb = NULL;
    }

    /***************************************************************************/
    /* 删除控制块的句柄。                                                      */
    /***************************************************************************/
    NBB_DESTROY_HANDLE(pstVpws->spm_vpws_handle, HDL_SPM_VPWS_CB);

    /***************************************************************************/
    /* 现在释放单盘信息控制块。                                                */
    /***************************************************************************/
    NBB_MM_FREE(pstVpws, MEM_SPM_VPWS_CB);
    pstVpws = NULL;

    EXIT_LABEL: NBB_TRC_EXIT();

    return;
}

/*****************************************************************************
   函 数 名  : spm_if_vpn_nni_exist
   功能描述  : 根据NNI_NO判断在VPWS中是否存在,返回存储位置
   输入参数  : NBB_BYTE ucVpnType
			   NBB_USHORT usNniVpNo
	           NBB_VOID *pstVpn
   输出参数  : 无
   返 回 值  : 0 ：不存在
             n ：存在的位置
   调用函数  :
   被调函数  :
   修改历史      :
   1.日    期   : 2013年5月8日
    作    者   : xiaoxiang
    修改内容   : 新生成函数
   2.日    期   : 2014年2月17日
    作    者   : xiaoxiang
    修改内容   : 传入备用VC key值
   3.日    期   : 2014年2月24日
    作    者   : xiaoxiang
    修改内容   : 根据NNI_NO判断
*****************************************************************************/
NBB_INT spm_if_vpn_nni_exist(NBB_BYTE ucVpnType, 
									NBB_USHORT usNniVpNo,
                                    NBB_VOID *pstVpn NBB_CCXT_T NBB_CXT)
{
    NBB_CHAR ucMessage[SPM_MSG_INFO_LEN];

    NBB_INT i = 0;
    NBB_INT ret = SUCCESS;

    SPM_VPWS_CB *pstVpws = NULL;
    SPM_VPLS_CB *pstVpls = NULL;

    //如果VPN配置都不存在，那么NNI肯定不存在
    if (pstVpn == NULL)
    {
        return 0;
    }

    if (ucVpnType == L2VPN_VPWS)
    {
        pstVpws = (SPM_VPWS_CB *)pstVpn;

        //在NNI的数组中找一个存储位置
        for (i = 0; i < ATG_DCI_VPWS_NNI_NUM; i++)
        {
            //如果为NULL，说明这个位置为无数据
            if (pstVpws->nni_cfg_cb[i] == NULL)
            {
                continue;
            }

            if (pstVpws->nni_cfg_cb[i]->nni_no == usNniVpNo)
            {
                ret = i + 1;
                break;
            }
        }
    }
    else if (ucVpnType == L2VPN_VPLS)
    {
        pstVpls = (SPM_VPLS_CB *)pstVpn;

        //在NNI的数组中找一个存储位置
        for (i = 0; i < ATG_DCI_VPLS_NNI_NUM; i++)
        {
            //如果为NULL，说明这个位置为无数据
            if (pstVpls->nni_cfg_cb[i] == NULL)
            {
                continue;
            }

            if (pstVpls->nni_cfg_cb[i]->nni_no == usNniVpNo)
            {
                ret = i + 1;
                break;
            }
        }
    }
    else
    {
        NBB_TRC_DETAIL((NBB_FORMAT "  ***ERROR***: spm_if_vpn_nni_exist() VPN_TYPE=%d NNI_NO=%d 的 NNI 不存在!", 
        				ucVpnType, usNniVpNo));

        OS_PRINTF("***ERROR***: spm_if_vpn_nni_exist() VPN_TYPE=%d NNI_NO=%d 的 NNI 不存在!\n", 
        				ucVpnType, usNniVpNo);

        OS_SPRINTF(ucMessage, "***ERROR***: spm_if_vpn_nni_exist() VPN_TYPE=%d NNI_NO=%d 的 NNI 不存在!\n", 
        				ucVpnType, usNniVpNo);
        BMU_SLOG(BMU_INFO, SPM_L2_LOG_DIR, ucMessage);

        NBB_EXCEPTION((PCT_SPM | VPWS_PD, 0, "ld d s s", 0,
                VPN_NOT_VPWS_NOR_VPLS,
                "VPN_NOT_VPWS_NOR_VPLS",
                ucMessage));
    }

    return ret;
}

/*****************************************************************************
   函 数 名  : spm_if_vpn_uni_exist
   功能描述  : 根据port_index值判断在VPWS/VPLS中是否存在,返回存储位置
   输入参数  : NBB_BYTE ucVpnType
             NBB_ULONG ulPortIndex
             NBB_VOID *pstVpn
   输出参数  : 无
   返 回 值  :
   调用函数  :
   被调函数  :

   修改历史      :
   1.日    期   : 2013年5月31日
    作    者   : xiaoxiang
    修改内容   : 新生成函数

*****************************************************************************/
NBB_INT spm_if_vpn_uni_exist(NBB_BYTE ucVpnType, NBB_ULONG ulPortIndex, NBB_VOID *pstVpn NBB_CCXT_T NBB_CXT)
{
    NBB_CHAR ucMessage[SPM_MSG_INFO_LEN];

    NBB_INT i = 0;
    NBB_INT ret = SUCCESS;

    SPM_VPWS_CB *pstVpws = NULL;
    SPM_VPLS_CB *pstVpls = NULL;

    //如果VPN配置都不存在，那么NNI肯定不存在
    if (pstVpn == NULL)
    {
        return 0;
    }

    if (ucVpnType == L2VPN_VPWS)
    {
        pstVpws = (SPM_VPWS_CB *)pstVpn;

        //在NNI的数组中找一个存储位置
        for (i = 0; i < ATG_DCI_VPWS_UNI_NUM; i++)
        {
            //如果为NULL，说明这个位置为无数据
            if (pstVpws->uni_cfg_cb[i] == NULL)
            {
                continue;
            }

            if (pstVpws->uni_cfg_cb[i]->port_index == ulPortIndex)
            {
                ret = i + 1;
                break;
            }
        }
    }
    else if (ucVpnType == L2VPN_VPLS)
    {
        pstVpls = (SPM_VPLS_CB *)pstVpn;

        //在NNI的数组中找一个存储位置
        for (i = 0; i < ATG_DCI_VPLS_UNI_NUM; i++)
        {
            //如果为NULL，说明这个位置为无数据
            if (pstVpls->uni_cfg_cb[i] == NULL)
            {
                continue;
            }

            if (pstVpls->uni_cfg_cb[i]->port_index == ulPortIndex)
            {
                ret = i + 1;
                break;
            }
        }
    }
    else
    {
        NBB_TRC_DETAIL((NBB_FORMAT "  ***ERROR***: spm_if_vpn_uni_exist() VPN_TYPE=%d PORT_INDEX=%ld 的 UNI 不存在!", ucVpnType, ulPortIndex));

        OS_PRINTF("***ERROR***: spm_if_vpn_uni_exist() VPN_TYPE=%d PORT_INDEX=%ld 的 UNI 不存在!\n", ucVpnType, ulPortIndex);

        OS_SPRINTF(ucMessage, "***ERROR***: spm_if_vpn_uni_exist() VPN_TYPE=%d PORT_INDEX=%ld 的 UNI 不存在!\n", ucVpnType, ulPortIndex);
        BMU_SLOG(BMU_INFO, SPM_L2_LOG_DIR, ucMessage);

        NBB_EXCEPTION((PCT_SPM | VPWS_PD, 0, "ld d s s", 0,
                VPN_NOT_VPWS_NOR_VPLS,
                "VPN_NOT_VPWS_NOR_VPLS",
                ucMessage));
    }

    return ret;
}

/*****************************************************************************
   函 数 名  : spm_free_all_vpws_cb
   功能描述  : 释放vpws配置所有的内存空间
   输入参数  : 无
   输出参数  : 无
   返 回 值  :
   调用函数  :
   被调函数  :

   修改历史      :
   1.日    期   : 2013年11月6日
    作    者   : zhangzhm
    修改内容   : 新生成函数

*****************************************************************************/

NBB_VOID spm_free_all_vpws_cb(NBB_CXT_T NBB_CXT)
{
	SPM_VPWS_CB *pstVpws = NULL;
	
    for (pstVpws = (SPM_VPWS_CB*) AVLL_FIRST(SHARED.vpws_tree);
         pstVpws != NULL;
         pstVpws = (SPM_VPWS_CB*) AVLL_FIRST(SHARED.vpws_tree))
    {
    	
		AVLL_DELETE(SHARED.vpws_tree, pstVpws->spm_vpws_node);     	
    	spm_free_vpws_cb(pstVpws NBB_CCXT);
    }
}

/*****************************************************************************
   函 数 名  : spm_get_uni_ces_mspinfo
   功能描述  : 获取仿真业务MSP保护相关信息
   输入参数  : 1，pstPhysicalPort     二级物理接口
   输出参数  : 1，ulMspId      绑定的MSP保护ID
                             2，stBackPortInfo  MSP保护的备用端口信息
   返 回 值  :
   调用函数  :
   被调函数  :

   修改历史      :
   1.日    期   : 2014年12月18日
    作    者   : fansongbo
    修改内容   : 新生成函数

*****************************************************************************/
NBB_INT spm_get_uni_ces_mspinfo(SPM_PHYSICAL_PORT_CB *pstPhysicalPort,
    NBB_ULONG *ulMspId,SPM_PORT_INFO_CB *stBackPortInfo,NBB_ULONG *backininderectPhykey )
{
    NBB_INT ret = SUCCESS;
    NBB_CHAR ucMessage[SPM_MSG_INFO_LEN];

    SPM_MSP_CB *pstMspCb = NULL;
    SPM_MSP_CB *psttempMspCb = NULL;

    //主用直连物理端口
    SPM_PHYSICAL_PORT_CB *pstderectPhysicalPort = NULL;

    //主用一级从属物理端口
    SPM_PHYSICAL_PORT_CB *pstinderectPhysicalPort = NULL;

    //备用二级从属物理端口
    SPM_PHYSICAL_PORT_CB *pstBackininderectPhysicalPort = NULL;

    //备用直连物理端口
    SPM_PHYSICAL_PORT_CB *pstBackderectPhysicalPort = NULL;
    NBB_INT rev = 0;
    NBB_CHAR flag = 0;
    
    //主备用2M时隙编号
    NBB_INT maintunom = 0;
    NBB_INT baktunom = 0;

    NBB_ULONG tempbackininderectPhykey = 0;
      
    //NBB_TRC_ENTRY("spm_get_uni_ces_mspinfo");
    
    if(NULL == pstPhysicalPort)
    {
        //NBB_TRC_FLOW((NBB_FORMAT "  ***ERROR***:(%s:%d)pointer is NULL\n", __FILE__,__LINE__));

        OS_PRINTF(" ***ERROR***:(%s:%d)pstPhysicalPort pointer is NULL\n", __FILE__,__LINE__);

        OS_SPRINTF(ucMessage, " ***ERROR***:(%s:%d)pstPhysicalPort pointer is NULL\n", __FILE__,__LINE__);
        BMU_SLOG(BMU_INFO, SPM_L2_LOG_DIR, ucMessage);

        NBB_EXCEPTION((PCT_SPM | VPWS_PD, 0, "ld d s s", pstPhysicalPort, 
        FUNC_IN_PARAM_IS_NULL, "ALLOC_MEMORY_ERROR", ucMessage));
        return ERROR;
    }

    if(NULL == stBackPortInfo)
    {
        //NBB_TRC_FLOW((NBB_FORMAT "  ***ERROR***:(%s:%d)pointer is NULL\n", __FILE__,__LINE__));

        OS_PRINTF(" ***ERROR***:(%s:%d)stBackPortInfo pointer is NULL\n", __FILE__,__LINE__);

        OS_SPRINTF(ucMessage, " ***ERROR***:(%s:%d)stBackPortInfo pointer is NULL\n", __FILE__,__LINE__);
        BMU_SLOG(BMU_INFO, SPM_L2_LOG_DIR, ucMessage);

        NBB_EXCEPTION((PCT_SPM | VPWS_PD, 0, "ld d s s", stBackPortInfo, 
        FUNC_IN_PARAM_IS_NULL, "ALLOC_MEMORY_ERROR", ucMessage));
        return ERROR;
    }

    if(NULL == ulMspId)
    {
        //NBB_TRC_FLOW((NBB_FORMAT "  ***ERROR***:(%s:%d)pointer is NULL\n", __FILE__,__LINE__));

        OS_PRINTF(" ***ERROR***:(%s:%d)ulMspId pointer is NULL\n", __FILE__,__LINE__);

        OS_SPRINTF(ucMessage, " ***ERROR***:(%s:%d)ulMspId pointer is NULL\n", __FILE__,__LINE__);
        BMU_SLOG(BMU_INFO, SPM_L2_LOG_DIR, ucMessage);

        NBB_EXCEPTION((PCT_SPM | VPWS_PD, 0, "ld d s s", ulMspId, 
        FUNC_IN_PARAM_IS_NULL, "ALLOC_MEMORY_ERROR", ucMessage));
        return ERROR;
    }

    if(NULL == backininderectPhykey)
    {
        //NBB_TRC_FLOW((NBB_FORMAT "  ***ERROR***:(%s:%d)pointer is NULL\n", __FILE__,__LINE__));

        OS_PRINTF(" ***ERROR***:(%s:%d)backininderectPhykey pointer is NULL\n", __FILE__,__LINE__);

        OS_SPRINTF(ucMessage, " ***ERROR***:(%s:%d)backininderectPhykey pointer is NULL\n", __FILE__,__LINE__);
        BMU_SLOG(BMU_INFO, SPM_L2_LOG_DIR, ucMessage);

        NBB_EXCEPTION((PCT_SPM | VPWS_PD, 0, "ld d s s", backininderectPhykey, 
        FUNC_IN_PARAM_IS_NULL, "ALLOC_MEMORY_ERROR", ucMessage));
        return ERROR;
    }

    OS_MEMSET(stBackPortInfo, 0, sizeof(SPM_PORT_INFO_CB));

    if (NULL == pstPhysicalPort->basic_cfg_cb )
    {
        //没有基本配置就退出
        NBB_TRC_DETAIL((NBB_FORMAT "  ***ERROR***二级从属物理接口[%ld]的基本配置不存在",
        pstPhysicalPort->port_index_key));

        OS_PRINTF("***ERROR***:二级从属物理接口[%ld]的基本配置不存在\n", pstPhysicalPort->port_index_key);

        OS_SPRINTF(ucMessage, "***ERROR***:二级从属物理接口[%ld]的基本配置不存在\n", 
        pstPhysicalPort->port_index_key);
        BMU_SLOG(BMU_INFO, SPM_L2_LOG_DIR, ucMessage);

        return ERROR;    
    }

    else if (ATG_DCI_INDERECT == pstPhysicalPort->basic_cfg_cb->port_attrib)
    {
        //找物理口
        pstinderectPhysicalPort = AVLL_FIND(SHARED.physical_port_tree, &pstPhysicalPort->basic_cfg_cb->senior_index);

        //如果未找到物理口配置，退出
        if (NULL == pstinderectPhysicalPort)
        {
            NBB_TRC_DETAIL((NBB_FORMAT "  ***ERROR***:PORT_INDEX=%ld 的一级从属物理端口未找到\n",
            pstPhysicalPort->basic_cfg_cb->senior_index));

            OS_PRINTF("***ERROR***:PORT_INDEX=%ld 的一级从属物理端口未找到!\n", 
            pstPhysicalPort->basic_cfg_cb->senior_index);

            OS_SPRINTF(ucMessage,
            "***ERROR***:PORT_INDEX=%ld 的一级从属物理端口未找到!\n", 
            pstPhysicalPort->basic_cfg_cb->senior_index);
            BMU_SLOG(BMU_INFO, SPM_L2_LOG_DIR, ucMessage);

            return ERROR;
        }

        //如果没有基本配置，退出
        else if (NULL == pstinderectPhysicalPort->basic_cfg_cb )
        {
            NBB_TRC_DETAIL((NBB_FORMAT "  ***ERROR***一级从属物理接口[%ld]的基本配置不存在",
            pstPhysicalPort->basic_cfg_cb->senior_index));

            OS_PRINTF("***ERROR***:一级从属物理接口[%ld]的基本配置不存在\n", 
            pstPhysicalPort->basic_cfg_cb->senior_index);

            OS_SPRINTF(ucMessage, "***ERROR***:一级从属物理接口[%ld]的基本配置不存在\n", 
            pstPhysicalPort->basic_cfg_cb->senior_index);
            BMU_SLOG(BMU_INFO, SPM_L2_LOG_DIR, ucMessage);

            return ERROR;    
        }

    }

    if ((NULL != pstinderectPhysicalPort) && (NULL != pstinderectPhysicalPort->basic_cfg_cb ) && 
            (ATG_DCI_INDERECT == pstinderectPhysicalPort->basic_cfg_cb->port_attrib))
    {
        //找物理口
        pstderectPhysicalPort = AVLL_FIND(SHARED.physical_port_tree, 
            &pstinderectPhysicalPort->basic_cfg_cb->senior_index);

        //如果未找到物理口配置，退出
        if (pstderectPhysicalPort == NULL)
        {
            NBB_TRC_DETAIL((NBB_FORMAT "  ***ERROR***:PORT_INDEX=%ld 的直连物理端口未找到\n",
            pstinderectPhysicalPort->basic_cfg_cb->senior_index));

            OS_PRINTF("***ERROR***:PORT_INDEX=%ld 的直连物理端口未找到!\n", 
            pstinderectPhysicalPort->basic_cfg_cb->senior_index);

            OS_SPRINTF(ucMessage,
            "***ERROR***:PORT_INDEX=%ld 的直连物理端口未找到!\n", 
            pstinderectPhysicalPort->basic_cfg_cb->senior_index);
            BMU_SLOG(BMU_INFO, SPM_L2_LOG_DIR, ucMessage);

            return ERROR;
        }

        //如果没有基本配置，退出
        else if (NULL == pstderectPhysicalPort->basic_cfg_cb )
        {
            NBB_TRC_DETAIL((NBB_FORMAT "  ***ERROR***直连物理接口[%ld]的基本配置不存在",
            pstinderectPhysicalPort->basic_cfg_cb->senior_index));

            OS_PRINTF("***ERROR***:直连物理接口[%ld]的基本配置不存在\n", 
            pstinderectPhysicalPort->basic_cfg_cb->senior_index);

            OS_SPRINTF(ucMessage, "***ERROR***:直连物理接口[%ld]的基本配置不存在\n", 
            pstinderectPhysicalPort->basic_cfg_cb->senior_index);
            BMU_SLOG(BMU_INFO, SPM_L2_LOG_DIR, ucMessage);

            return ERROR;    
        }        
        else
        {
            //遍历MSP保护配置块，找到其中主用端口与直连物理接口KEY值相同的配置块
            //获取MSPID及备用端口信息
            for (pstMspCb = (SPM_MSP_CB *)AVLL_FIRST(v_spm_shared->msp_tree);
                pstMspCb != NULL;
                pstMspCb = (SPM_MSP_CB *)AVLL_NEXT(v_spm_shared->msp_tree,
                pstMspCb->spm_msp_node))                                        
            {

                if((NULL != pstMspCb->basic_cfg_cb) && (0 != pstderectPhysicalPort->port_index_key) && 
                   (pstderectPhysicalPort->port_index_key == pstMspCb->basic_cfg_cb->master_port_index))
                {
                    psttempMspCb = pstMspCb;
                    break;
                }
            }
        }
    }

    if(NULL == psttempMspCb)
    {
        //NBB_TRC_DETAIL((NBB_FORMAT 
            //" ***ERROR***:(%s:%d)psttempMspCb pointer is NULL,未配置MSP保护或者未找到备用", __FILE__,__LINE__));

        //OS_PRINTF(" ***ERROR***:(%s:%d)psttempMspCb pointer is NULL\n", __FILE__,__LINE__);

        //OS_SPRINTF(ucMessage, 
            //" ***ERROR***:(%s:%d)psttempMspCb pointer is NULL,未配置MSP保护或者未找到备用\n", __FILE__,__LINE__);
        //BMU_SLOG(BMU_INFO, SPM_L2_LOG_DIR, ucMessage);

        return ERROR;
    }
     
    if((NULL != psttempMspCb) && (NULL != psttempMspCb->basic_cfg_cb))
    {
        //找物理口
        pstBackderectPhysicalPort = AVLL_FIND(SHARED.physical_port_tree, &psttempMspCb->basic_cfg_cb->slave_port_index);

    }
    
    //如果未找到物理口配置，退出
    if (NULL == pstBackderectPhysicalPort)
    {
        NBB_TRC_DETAIL((NBB_FORMAT "  ***ERROR***:PORT_INDEX=%ld 的备用直连物理端口未找到",
        psttempMspCb->basic_cfg_cb->slave_port_index));

        OS_PRINTF("***ERROR***:PORT_INDEX=%ld 的备用直连物理端口未找到!\n", 
        psttempMspCb->basic_cfg_cb->slave_port_index);

        OS_SPRINTF(ucMessage,
        "***ERROR***:PORT_INDEX=%ld 的备用直连物理端口未找到!\n", 
        psttempMspCb->basic_cfg_cb->slave_port_index);
        BMU_SLOG(BMU_INFO, SPM_L2_LOG_DIR, ucMessage);

        return ERROR;
    }

    //如果没有基本配置，退出
    else if (NULL == pstBackderectPhysicalPort->basic_cfg_cb )
    {
        NBB_TRC_DETAIL((NBB_FORMAT "  ***ERROR***备用直连物理接口[%ld]的基本配置不存在",
        psttempMspCb->basic_cfg_cb->slave_port_index));

        OS_PRINTF("***ERROR***:备用直连物理接口[%ld]的基本配置不存在\n", 
        psttempMspCb->basic_cfg_cb->slave_port_index);

        OS_SPRINTF(ucMessage, "***ERROR***:备用直连物理接口[%ld]的基本配置不存在\n", 
        psttempMspCb->basic_cfg_cb->slave_port_index);
        BMU_SLOG(BMU_INFO, SPM_L2_LOG_DIR, ucMessage);

        return ERROR;    
    }        


    //遍历接口物理配置块，找到备用的二级从属物理端口
    for (pstBackininderectPhysicalPort = (SPM_PHYSICAL_PORT_CB *)AVLL_FIRST(v_spm_shared->physical_port_tree);
        pstBackininderectPhysicalPort != NULL;
        pstBackininderectPhysicalPort = (SPM_PHYSICAL_PORT_CB *)AVLL_NEXT(v_spm_shared->physical_port_tree,
        pstBackininderectPhysicalPort->spm_physical_port_node))                                        
    {
        if(NULL != pstBackininderectPhysicalPort->basic_cfg_cb)
        {
            //比较前3项是否相等
            rev = NBB_MEMCMP(pstBackininderectPhysicalPort->basic_cfg_cb, pstPhysicalPort->basic_cfg_cb, 3);
            if(0 != rev)
            {
                continue;
            }
            else
            {
                flag++;
            }

            //比较从框号开始的3项是否相等
            rev = NBB_MEMCMP(&(pstBackininderectPhysicalPort->basic_cfg_cb->subrack), 
                &(pstBackderectPhysicalPort->basic_cfg_cb->subrack), 3);
            if(0 != rev)
            {
                continue;
            }
            else
            {
                flag++;
            }

            //比较从AU4开始的5项是否相等
            rev = NBB_MEMCMP(&(pstBackininderectPhysicalPort->basic_cfg_cb->au4_no), 
                &(pstPhysicalPort->basic_cfg_cb->au4_no), 5);
            if(0 != rev)
            {
                continue;
            }
            else
            {
                flag++;
            }

            //找到配置块，获取KEY值
            if(3 == flag)
            {
                tempbackininderectPhykey = pstBackininderectPhysicalPort->port_index_key;                      
                break;
            }
        }

    }   
        
    //(NULL != psttempMspCb) && (NULL != psttempMspCb->basic_cfg_cb) 找到了对应的保护配置
    //(0 != tempbackininderectPhykey)   找到了对应的备用CES端口
    if((NULL != psttempMspCb) && (NULL != psttempMspCb->basic_cfg_cb) && (0 != tempbackininderectPhykey))
    {
        if ((NULL != pstPhysicalPort) && (NULL != pstPhysicalPort->basic_cfg_cb))
        {
            maintunom = (pstPhysicalPort->basic_cfg_cb->au4_no - 1) * 63 +
                                                    (pstPhysicalPort->basic_cfg_cb->tug3_no - 1) * 21 +
                                                    (pstPhysicalPort->basic_cfg_cb->tug2_no - 1) * 3   +
                                                    (pstPhysicalPort->basic_cfg_cb->tu12_no - 1);
            if((maintunom < (63 * DERECT_PHY_PORT_RATE)) && 
                (pstPhysicalPort->basic_cfg_cb->au4_no > 0) &&
                (pstPhysicalPort->basic_cfg_cb->tug3_no > 0) &&
                (pstPhysicalPort->basic_cfg_cb->tug2_no > 0) &&
                (pstPhysicalPort->basic_cfg_cb->tu12_no > 0))
            {
                psttempMspCb->main_info[maintunom].if_prot = 1;
                psttempMspCb->main_info[maintunom].ces_key = pstPhysicalPort->port_index_key;
            }
            else
            {
                NBB_TRC_DETAIL((NBB_FORMAT 
                    "***ERROR***主用接口物理 [key = %d] AU4=%d tug3=%d tug2=%d tu12=%d 配置数据有错误",
                    pstPhysicalPort->port_index_key,
                    pstPhysicalPort->basic_cfg_cb->au4_no,
                    pstPhysicalPort->basic_cfg_cb->tug3_no,
                    pstPhysicalPort->basic_cfg_cb->tug2_no,
                    pstPhysicalPort->basic_cfg_cb->tu12_no));
                OS_SPRINTF(ucMessage, 
                    "***ERROR***主用接口物理 [key = %d] AU4=%d tug3=%d tug2=%d tu12=%d  配置数据有错误\n", 
                    pstPhysicalPort->port_index_key,
                    pstPhysicalPort->basic_cfg_cb->au4_no,
                    pstPhysicalPort->basic_cfg_cb->tug3_no,
                    pstPhysicalPort->basic_cfg_cb->tug2_no,
                    pstPhysicalPort->basic_cfg_cb->tu12_no);
                BMU_SLOG(BMU_INFO, SPM_L2_LOG_DIR, ucMessage);

                return ERROR; 
            }
            
        }
        
        if ((NULL != pstBackininderectPhysicalPort) && (NULL != pstBackininderectPhysicalPort->basic_cfg_cb))
        {
            baktunom = (pstBackininderectPhysicalPort->basic_cfg_cb->au4_no - 1) * 63 +
                                                    (pstBackininderectPhysicalPort->basic_cfg_cb->tug3_no - 1) * 21 +
                                                    (pstBackininderectPhysicalPort->basic_cfg_cb->tug2_no - 1) * 3   +
                                                    (pstBackininderectPhysicalPort->basic_cfg_cb->tu12_no - 1);
            if((baktunom < (63 * DERECT_PHY_PORT_RATE)) &&
                (pstBackininderectPhysicalPort->basic_cfg_cb->au4_no > 0) &&
                (pstBackininderectPhysicalPort->basic_cfg_cb->tug3_no > 0) &&
                (pstBackininderectPhysicalPort->basic_cfg_cb->tug2_no > 0) &&
                (pstBackininderectPhysicalPort->basic_cfg_cb->tu12_no > 0))
            {
                psttempMspCb->bak_info[baktunom].if_prot = 1;
                psttempMspCb->bak_info[baktunom].ces_key = pstBackininderectPhysicalPort->port_index_key;
            }
            else
            {
                NBB_TRC_DETAIL((NBB_FORMAT 
                    "***ERROR***备用接口物理 [key = %d] AU4=%d tug3=%d tug2=%d tu12=%d  配置数据有错误",
                    pstBackininderectPhysicalPort->port_index_key,
                    pstBackininderectPhysicalPort->basic_cfg_cb->au4_no,
                    pstBackininderectPhysicalPort->basic_cfg_cb->tug3_no,
                    pstBackininderectPhysicalPort->basic_cfg_cb->tug2_no,
                    pstBackininderectPhysicalPort->basic_cfg_cb->tu12_no));
                OS_SPRINTF(ucMessage, 
                    "***ERROR***备用接口物理 [key = %d] AU4=%d tug3=%d tug2=%d tu12=%d  配置数据有错误\n", 
                    pstBackininderectPhysicalPort->port_index_key,
                    pstBackininderectPhysicalPort->basic_cfg_cb->au4_no,
                    pstBackininderectPhysicalPort->basic_cfg_cb->tug3_no,
                    pstBackininderectPhysicalPort->basic_cfg_cb->tug2_no,
                    pstBackininderectPhysicalPort->basic_cfg_cb->tu12_no);               
                BMU_SLOG(BMU_INFO, SPM_L2_LOG_DIR, ucMessage);

                return ERROR; 
            }

        }

        *ulMspId = psttempMspCb->msp_key;
        spm_get_portid_from_physical_port_index(psttempMspCb->basic_cfg_cb->slave_port_index,
        stBackPortInfo NBB_CCXT);
        *backininderectPhykey = tempbackininderectPhykey;

    }
                      
    return SUCCESS;
    
}


#if 0


/*****************************************************************************
   函 数 名  : spm_if_vpn_nni_exist
   功能描述  : 根据VC表key值判断在VPWS中是否存在,返回存储位置
   输入参数  : NBB_BYTE ucVpnType
	           ATG_DCI_VC_KEY *pstVcKeyMain
	           ATG_DCI_VC_KEY *pstVcKeyBack
	           NBB_VOID *pstVpn
   输出参数  : 无
   返 回 值  : 0 ：不存在
             n ：存在的位置
   调用函数  :
   被调函数  :
   修改历史      :
   1.日    期   : 2013年5月8日
    作    者   : xiaoxiang
    修改内容   : 新生成函数
   2.日    期   : 2014年2月17日
    作    者   : xiaoxiang
    修改内容   : 传入备用VC key值
*****************************************************************************/
NBB_INT spm_if_vpn_nni_exist(NBB_BYTE ucVpnType, 
                                    ATG_DCI_VC_KEY *pstVcKeyMain, 
                                    ATG_DCI_VC_KEY *pstVcKeyBack, 
                                    NBB_VOID *pstVpn NBB_CCXT_T NBB_CXT)
{
    NBB_CHAR ucMessage[SPM_MSG_INFO_LEN];

    NBB_INT i = 0;
    NBB_INT ret = SUCCESS;

    SPM_VPWS_CB *pstVpws = NULL;
    SPM_VPLS_CB *pstVpls = NULL;

    //如果VPN配置都不存在，那么NNI肯定不存在
    if (pstVpn == NULL)
    {
        return 0;
    }

    if (ucVpnType == L2VPN_VPWS)
    {
        pstVpws = (SPM_VPWS_CB *)pstVpn;

        //在NNI的数组中找一个存储位置
        for (i = 0; i < pstVpws->nni_num; i++)
        {
            //如果为NULL，说明这个位置为无数据
            if (pstVpws->nni_cfg_cb[i] == NULL)
            {
                continue;
            }

            if (((pstVpws->nni_cfg_cb[i]->vc_id == pstVcKeyMain->vc_id)
                && (pstVpws->nni_cfg_cb[i]->vc_type == pstVcKeyMain->vc_type)
                && (pstVpws->nni_cfg_cb[i]->peer_ip == pstVcKeyMain->peer_ip))
                || ((pstVpws->nni_cfg_cb[i]->vc_id_bak == pstVcKeyBack->vc_id)
                && (pstVpws->nni_cfg_cb[i]->vc_type_bak == pstVcKeyBack->vc_type)
                && (pstVpws->nni_cfg_cb[i]->peer_ip_bak == pstVcKeyBack->peer_ip)))
            {
                ret = i + 1;
                break;
            }
        }
    }
    else if (ucVpnType == L2VPN_VPLS)
    {
        pstVpls = (SPM_VPLS_CB *)pstVpn;

        //在NNI的数组中找一个存储位置
        for (i = 0; i < pstVpls->nni_num; i++)
        {
            //如果为NULL，说明这个位置为无数据
            if (pstVpls->nni_cfg_cb[i] == NULL)
            {
                continue;
            }

            if (((pstVpls->nni_cfg_cb[i]->vc_id == pstVcKeyMain->vc_id)
                && (pstVpls->nni_cfg_cb[i]->vc_type == pstVcKeyMain->vc_type)
                && (pstVpls->nni_cfg_cb[i]->peer_ip == pstVcKeyMain->peer_ip))
                || ((pstVpls->nni_cfg_cb[i]->vc_id_bak == pstVcKeyBack->vc_id)
                && (pstVpls->nni_cfg_cb[i]->vc_type_bak == pstVcKeyBack->vc_type)
                && (pstVpls->nni_cfg_cb[i]->peer_ip_bak == pstVcKeyBack->peer_ip)))
            {
                ret = i + 1;
                break;
            }
        }
    }
    else
    {
        NBB_TRC_DETAIL((NBB_FORMAT "  ***ERROR***: spm_if_vpn_nni_exist() VPN_TYPE=%d VC_ID=%ld VC_TYPE=%d PEER_IP=%s 的 NNI 不存在!", 
        				ucVpnType, pstVcKeyMain->vc_id, pstVcKeyMain->vc_type, spm_set_ulong_to_ipv4(pstVcKeyMain->peer_ip NBB_CCXT)));

        OS_PRINTF("***ERROR***: spm_if_vpn_nni_exist() VPN_TYPE=%d VC_ID=%ld VC_TYPE=%d PEER_IP=%s 的 NNI 不存在!\n", 
        				ucVpnType, pstVcKeyMain->vc_id, pstVcKeyMain->vc_type, spm_set_ulong_to_ipv4(pstVcKeyMain->peer_ip NBB_CCXT));

        OS_SPRINTF(ucMessage, "***ERROR***: spm_if_vpn_nni_exist() VPN_TYPE=%d VC_ID=%ld VC_TYPE=%d PEER_IP=%s 的 NNI 不存在!\n", 
        				ucVpnType, pstVcKeyMain->vc_id, pstVcKeyMain->vc_type, spm_set_ulong_to_ipv4(pstVcKeyMain->peer_ip NBB_CCXT));
        BMU_SLOG(BMU_INFO, SPM_L2_LOG_DIR, ucMessage);

        NBB_EXCEPTION((PCT_SPM | VPWS_PD, 0, "ld d s s", 0,
                VPN_NOT_VPWS_NOR_VPLS,
                "VPN_NOT_VPWS_NOR_VPLS",
                ucMessage));
    }

    return ret;
}


/*****************************************************************************
   函 数 名  : spm_vpn_mod_vp_nni
   功能描述  : VPWS更改一个VP(NNI)
   输入参数  : NBB_BYTE ucVpnType
             NBB_USHORT usVpnId
             NBB_VOID* pstNniData
             SPM_VPN_PORT_INFO_CB* pstVpnPortInfo
   输出参数  : 无
   返 回 值  :
   调用函数  :
   被调函数  :

   修改历史      :
   1.日    期   : 2013年4月19日
    作    者   : xiaoxiang
    修改内容   : 新生成函数

*****************************************************************************/
NBB_INT spm_vpn_mod_vp_nni(NBB_BYTE ucVpnType,
    NBB_USHORT usVpnId,
    NBB_VOID *pstNniData,
    SPM_VPN_PORT_INFO_CB *pstVpnPortInfo)
{
    VPORT_T stNniVport;
    NBB_INT i = 0;
    NBB_INT ret = SUCCESS;
    SPM_VC_CB *pstVcMain = NULL;
    SPM_VC_CB *pstVcBack = NULL;
    ATG_DCI_VC_KEY stVcKeyMain;
    ATG_DCI_VC_KEY stVcKeyBack;
    CRTXLSP_KEY stCrLspKey;    //最新的用这个接口
    FTN_KEY stFtnKey;

    NBB_ULONG ulTunnelIndexMaster = 0;
    NBB_ULONG ulTunnelIndexSlave = 0;
    NBB_ULONG ulPortIndexMaster = 0;
    NBB_ULONG ulPortIndexSlave = 0;
    NBB_BYTE ucSlot = 0;
    NBB_BYTE ucProtectFlag = 0;
    NBB_BYTE ucProtectType = 0;
    NBB_USHORT usFrrGroupId = 0;

    ATG_DCI_VPWS_NNI_DATA *pstVpwsNni = NULL;
    ATG_DCI_VPLS_NNI_DATA *pstVplsNni = NULL;

    NBB_TRC_ENTRY("spm_vpn_add_vp_nni");

#ifdef SPU
    OS_MEMSET(&stNniVport, 0, sizeof(VPORT_T));
#endif

    OS_MEMSET(&stVcKeyMain, 0, sizeof(ATG_DCI_VC_KEY));
    OS_MEMSET(&stVcKeyBack, 0, sizeof(ATG_DCI_VC_KEY));
    OS_MEMSET(&stCrLspKey, 0, sizeof(CRTXLSP_KEY));
    OS_MEMSET(&stFtnKey, 0, sizeof(FTN_KEY));

    if (ucVpnType == L2VPN_VPWS)
    {
        pstVpwsNni = (ATG_DCI_VPWS_NNI_DATA *)pstNniData;

        stVcKeyMain.vc_id = pstVpwsNni->vc_id;
        stVcKeyMain.peer_ip = pstVpwsNni->peer_ip;
        stVcKeyMain.vc_type = pstVpwsNni->vc_type;

        stVcKeyBack.vc_id = pstVpwsNni->vc_id_bak;
        stVcKeyBack.peer_ip = pstVpwsNni->peer_ip_bak;
        stVcKeyBack.vc_type = pstVpwsNni->vc_type_bak;

        stNniVport.eVpType = NNI;
        stNniVport.vcId = pstVpwsNni->vc_id;
        stNniVport.vcType = pstVpwsNni->vc_type;
        stNniVport.peerIp = pstVpwsNni->peer_ip;

        ucProtectFlag = pstVpwsNni->use_protect;
        ucProtectType = pstVpwsNni->prot_type;
    }
    else if (ucVpnType == L2VPN_VPLS)
    {
        pstVplsNni = (ATG_DCI_VPLS_NNI_DATA *)pstNniData;

        stVcKeyMain.vc_id = pstVplsNni->vc_id;
        stVcKeyMain.peer_ip = pstVplsNni->peer_ip;
        stVcKeyMain.vc_type = pstVplsNni->vc_type;

        stVcKeyBack.vc_id = pstVplsNni->vc_id_bak;
        stVcKeyBack.peer_ip = pstVplsNni->peer_ip_bak;
        stVcKeyBack.vc_type = pstVplsNni->vc_type_bak;

        stNniVport.eVpType = VP_NNI;
        stNniVport.vcId = pstVplsNni->vc_id;
        stNniVport.vcType = pstVplsNni->vc_type;
        stNniVport.peerIp = pstVplsNni->peer_ip;

        ucProtectFlag = pstVplsNni->use_protect;
        ucProtectType = pstVplsNni->prot_type;
    }
    else
    {
        NBB_TRC_DETAIL((NBB_FORMAT "  ***ERROR***: ucVpnType=%d 不存在", ucVpnType));
        OS_PRINTF("***ERROR***: ucVpnType=%d 不存在\n", ucVpnType);
    }

    /* 获取到VC表的配置 */
    pstVcMain = AVLL_FIND(SHARED.vc_tree, &stVcKeyMain);
    pstVcBack = AVLL_FIND(SHARED.vc_tree, &stVcKeyBack);

    if ((pstVcMain == NULL)
        || (pstVcMain->basic_cfg_cb == NULL)
        || ((pstVcBack != NULL) && (pstVcBack->basic_cfg_cb == NULL)))
    {
        NBB_TRC_DETAIL((NBB_FORMAT "  ***ERROR***: 主用VC不存在，主用VC基本配置不存在，或备用VC存在但基本配置不存在！"));
        OS_PRINTF("***ERROR***: 主用VC不存在，主用VC基本配置不存在，或备用VC存在但基本配置不存在！\n");

        ret = ERROR;
        goto EXIT_LABEL;
    }

    //如果存在，记录vpn_id等值，以便在VC表下更新配置时关联
    pstVcMain->vc_info_cb.vpn_id = usVpnId;
    pstVcMain->vc_info_cb.vpn_type = ucVpnType;
    pstVcMain->vc_info_cb.if_main = VC_MAIN;

    //如果存在，记录vpn_id等值，以便在VC表下更新配置时关联
    if (pstVcBack != NULL)
    {
        pstVcBack->vc_info_cb.vpn_id = usVpnId;
        pstVcBack->vc_info_cb.vpn_type = ucVpnType;
        pstVcBack->vc_info_cb.if_main = VC_BACK;
    }

    //VLAN 接收TAG识别
    if (pstVcMain->basic_cfg_cb->recv_action == 1)
    {
        stNniVport.flags |= VPORT_SERVICE_TAGGED;
    }

    //VLAN 发送TAG行为 主用
    switch (pstVcMain->basic_cfg_cb->send_tag_action)
    {
        case ATG_DCI_ADD_VID_PRI:
        stNniVport.tNextHop.eEgrPtagAction = EGR_ENCAP;
        break;
        case ATG_DCI_DEL_VID_PRI:
        stNniVport.tNextHop.eEgrPtagAction = EGR_NO_ENCAP;
        break;
        case ATG_DCI_REP_VID:
        stNniVport.tNextHop.eEgrPtagAction = EGR_CTAG_ACTION_REPLACE_VID;
        break;
        case ATG_DCI_REP_VID_PRI:
        stNniVport.tNextHop.eEgrPtagAction = EGR_CTAG_ACTION_REPLACE_VID_PRI;
        break;
        case ATG_DCI_NOP:
        stNniVport.tNextHop.eEgrPtagAction = EGR_CTAG_ACTION_NO_ACTION;
        break;
        default:
        break;
    }

    stNniVport.tNextHop.egrPtagVlan = pstVcMain->basic_cfg_cb->send_vlan_id;
    stNniVport.tNextHop.egrPtagPri = pstVcMain->basic_cfg_cb->send_vlan_pri;
    stNniVport.tNextHop.egrServiceTpid = pstVcMain->basic_cfg_cb->tag_type;

    //主用配置
    stNniVport.matchVcLabel = pstVcMain->basic_cfg_cb->pw_in_label;
    stNniVport.globalVp = pstVcMain->basic_cfg_cb->vc_no;

    stNniVport.tNextHop.flags |= NEXT_HOP_ENCAP_TUNNEL;
    stNniVport.tNextHop.nhIdx = pstVcMain->basic_cfg_cb->vc_no;

    stNniVport.tNextHop.tPwLabel.label_un.tlabel.label = pstVcMain->basic_cfg_cb->pw_out_label;
    stNniVport.tNextHop.tPwLabel.label_un.tlabel.ttl = 255; //协议里面需要定义 todo

    //调用dk的接口获取ftnIndex
    if (pstVcMain->basic_cfg_cb->lsp_option == ATG_DCI_FTN)
    {
        stFtnKey.fec = pstVcMain->basic_cfg_cb->next_hop_ip;
        stFtnKey.mask = 32;
        stFtnKey.vrfid = 0;

        ret = spm_l3_ldpforoam(&stFtnKey, &ulPortIndexMaster, &ulTunnelIndexMaster NBB_CCXT);

        if (ret != SUCCESS)
        {
            NBB_TRC_DETAIL((NBB_FORMAT "  ***ERROR***: spm_l3_ldpforoam() error! ret=%d", ret));
            OS_PRINTF("***ERROR***: spm_l3_ldpforoam() ret=%d\n", ret);
        }
    }
    else if (pstVcMain->basic_cfg_cb->lsp_option == ATG_DCI_CR_LSP)
    {
        stCrLspKey.ingress = pstVcMain->basic_cfg_cb->ingress;
        stCrLspKey.egress = pstVcMain->basic_cfg_cb->egress;
        stCrLspKey.tunnelid = pstVcMain->basic_cfg_cb->tunnel_id;
        stCrLspKey.lspid = 0;

        ret = spm_l3_rsvpforoam(&stCrLspKey, &ulPortIndexMaster, &ulTunnelIndexMaster NBB_CCXT);    //用新接口替代

        if (ret != SUCCESS)
        {
            NBB_TRC_DETAIL((NBB_FORMAT "  ***ERROR***: spm_l3_rsvpforoam() error! ret=%d", ret));
            OS_PRINTF("***ERROR***: spm_l3_rsvpforoam() ret=%d\n", ret);
        }
    }
    else
    {
        NBB_TRC_DETAIL((NBB_FORMAT "  ***ERROR***: 主用VC LSP选择 未配置"));
        OS_PRINTF("***ERROR***: 主用VC LSP选择 未配置\n");
    }

    pstVcMain->vc_info_cb.port_index = ulPortIndexMaster;
    stNniVport.tNextHop.tunnelIdx = ulTunnelIndexMaster;

    NBB_TRC_DETAIL((NBB_FORMAT "  ulFtnIndexMaster=%d ulPortIndexMaster=%d", ulTunnelIndexMaster, ulPortIndexMaster));

    //备用配置
    if ((ucProtectFlag == 1) && (pstVcBack != NULL))
    {

        //VLAN 发送TAG行为 备用
        switch (pstVcBack->basic_cfg_cb->send_tag_action)
        {
            case ATG_DCI_ADD_VID_PRI:
            stNniVport.tNextHop_p.eEgrPtagAction = EGR_ENCAP;
            break;
            case ATG_DCI_DEL_VID_PRI:
            stNniVport.tNextHop_p.eEgrPtagAction = EGR_NO_ENCAP;
            break;
            case ATG_DCI_REP_VID:
            stNniVport.tNextHop_p.eEgrPtagAction = EGR_CTAG_ACTION_REPLACE_VID;
            break;
            case ATG_DCI_REP_VID_PRI:
            stNniVport.tNextHop_p.eEgrPtagAction = EGR_CTAG_ACTION_REPLACE_VID_PRI;
            break;
            case ATG_DCI_NOP:
            stNniVport.tNextHop_p.eEgrPtagAction = EGR_CTAG_ACTION_NO_ACTION;
            break;
            default:
            break;
        }

        stNniVport.tNextHop_p.egrPtagVlan = pstVcBack->basic_cfg_cb->send_vlan_id;
        stNniVport.tNextHop_p.egrPtagPri = pstVcBack->basic_cfg_cb->send_vlan_pri;
        stNniVport.tNextHop_p.egrServiceTpid = pstVcBack->basic_cfg_cb->tag_type;

        stNniVport.matchVcLabel_p = pstVcBack->basic_cfg_cb->pw_in_label;

        stNniVport.tNextHop_p.flags |= NEXT_HOP_ENCAP_TUNNEL;

        //stNniVport.tNextHop_p.flags |= NEXT_HOP_NHI_TYPE_VP_PW;

        stNniVport.tNextHop_p.tPwLabel.label_un.tlabel.label = pstVcBack->basic_cfg_cb->pw_out_label;
        stNniVport.tNextHop_p.tPwLabel.label_un.tlabel.ttl = 255;  //协议里面需要定义 todo

        if (pstVcBack->basic_cfg_cb->lsp_option == ATG_DCI_FTN)
        {
            stFtnKey.fec = pstVcBack->basic_cfg_cb->next_hop_ip;
            stFtnKey.mask = 32;
            stFtnKey.vrfid = 0;

            ret = spm_l3_ldpforoam(&stFtnKey, &ulPortIndexSlave, &ulTunnelIndexSlave NBB_CCXT);

            if (ret != SUCCESS)
            {
                NBB_TRC_DETAIL((NBB_FORMAT "  ***ERROR***: spm_l3_ldpforoam() error! ret=%d", ret));
                OS_PRINTF("***ERROR***: spm_l3_ldpforoam() ret=%d\n", ret);
            }
        }
        else if (pstVcBack->basic_cfg_cb->lsp_option == ATG_DCI_CR_LSP)
        {
            //调用dk的接口获取ftn_index? todo
            stCrLspKey.ingress = pstVcBack->basic_cfg_cb->ingress;
            stCrLspKey.egress = pstVcBack->basic_cfg_cb->egress;
            stCrLspKey.tunnelid = pstVcBack->basic_cfg_cb->tunnel_id;
            stCrLspKey.lspid = 0;

            ret = spm_l3_rsvpforoam(&stCrLspKey, &ulPortIndexSlave, &ulTunnelIndexSlave NBB_CCXT);    //用新接口替代

            if (ret != SUCCESS)
            {
                NBB_TRC_DETAIL((NBB_FORMAT "  ***ERROR***: spm_l3_rsvpforoam() error! ret=%d", ret));
                OS_PRINTF("***ERROR***: spm_l3_rsvpforoam() ret=%d\n", ret);
            }
        }
        else
        {
            NBB_TRC_DETAIL((NBB_FORMAT "  ***ERROR***: 备用VC LSP选择 未配置"));
            OS_PRINTF("***ERROR***: 备用VC LSP选择 未配置\n");
        }

        pstVcBack->vc_info_cb.port_index = ulPortIndexSlave;
        stNniVport.tNextHop_p.tunnelIdx = ulTunnelIndexSlave;

        NBB_TRC_DETAIL((NBB_FORMAT "  ulFtnIndexSlave=%d  ulPortIndexSlave=%d", ulTunnelIndexSlave, ulPortIndexSlave));

        //如果配置PW冗余保护
        if (ucProtectType == ATG_DCI_PW_PROT_1B1)
        {
            stNniVport.eProtType = VP_NHI_FRR;
        }

#ifdef SPU
        ret = ApiC3CreateFrrGroup(UNIT_0, &usFrrGroupId, 0, 0);

        if (ret == SUCCESS)
        {
            stNniVport.frrGroupId = usFrrGroupId;
            NBB_TRC_DETAIL((NBB_FORMAT "usFrrGroupId=%d", stNniVport.frrGroupId));
        }
        else
        {
            NBB_TRC_DETAIL((NBB_FORMAT "***ERROR***: ApiC3CreateFrrGroup() error! ret=%d", ret));
        }
#endif
    }

    //如果是VPLS业务，需要配置MCA学习和水平分割
    if (ucVpnType == L2VPN_VPLS)
    {
        //MAC学习开关
        if (pstVcMain->basic_cfg_cb->mac_learning_enable == ENABLE)
        {
            stNniVport.flags |= VPORT_ADDR_LEARN_ON;
        }

        //水平分割开关
        if (pstVcMain->basic_cfg_cb->split_horizon_enable == ENABLE)
        {
            stNniVport.flags |= VPORT_NETWORK;
        }
    }

    //控制字使能。配置了保护，使能控制字？todo
    if ((pstVcMain->basic_cfg_cb->control_word_enable == ENABLE)
        || (ucProtectFlag == 1))
    {
        //stNniVport.flags |= VPORT_CW_EXIST;
        //stNniVport.tNextHop.flags   |= NEXT_HOP_CW_WITH_SN0;
        //stNniVport.tNextHop_p.flags |= NEXT_HOP_CW_WITH_SN0;
    }

    //设置包计数等标志
    stNniVport.flags |= VPORT_COUNTER_ON;
    stNniVport.flags |= VPORT_PROT_COUNTER_ON;

    //    stNniVport.tNextHop.flags   |= NEXT_HOP_COUNTER_ON;
    //    stNniVport.tNextHop_p.flags |= NEXT_HOP_COUNTER_ON;

#ifdef SPU

    //调用API函数进行配置，将VP加入到VPN中//unit?
    stNniVport.posId = pstVpnPortInfo->vp_pos_id;

    ret = ApiC3ModVp(UNIT_0, &stNniVport);
    NBB_TRC_DETAIL((NBB_FORMAT "  ApiC3ModVp[NNI]:  ret=%d", ret));

    if (ret == SUCCESS)
    {
        pstVcMain->vc_info_cb.vp_pos_id = stNniVport.posId;
        pstVcMain->vc_info_cb.vp_api_idx = stNniVport.rvVpApiIdx;
        pstVcMain->vc_info_cb.next_hop_id = stNniVport.tNextHop.nhiIdx;
        pstVcMain->vc_info_cb.frr_group_id = usFrrGroupId;

        pstVpnPortInfo->vp_pos_id = stNniVport.posId;

        if (pstVcBack != NULL)
        {
            pstVcBack->vc_info_cb.vp_pos_id = stNniVport.posId;
            pstVcBack->vc_info_cb.vp_api_idx = stNniVport.rvVpApiIdx;
            pstVcBack->vc_info_cb.next_hop_id = stNniVport.tNextHop_p.nhiIdx;
            pstVcBack->vc_info_cb.frr_group_id = usFrrGroupId;
        }
    }
    else
    {
        NBB_TRC_DETAIL((NBB_FORMAT "  ***ERROR***:ApiAddMplsPortToVpn[NNI]:  ret=%d", ret));
        OS_PRINTF("***ERROR***:ApiAddMplsPortToVpn[NNI]:  ret=%d\n", ret);

        goto EXIT_LABEL;
    }
#endif

    /**************************************************************************/
    /*                             增加VC Diff-Serv                           */
    /**************************************************************************/
    if (pstVcMain->diff_serv_cfg_cb != NULL)
    {
        ret = spm_ds_add_vc_node(pstVcMain->diff_serv_cfg_cb->diff_serv_id,
            &stVcKeyMain,
            pstVcMain->vc_info_cb.vp_pos_id,
            pstVcMain->vc_info_cb.if_main);

        if (ret == SUCCESS)
        {
            pstVcMain->vc_info_cb.if_qos = ATG_DCI_USED;
        }
    }

    //如果备用存在，且QoS配置存在
    if ((pstVcBack != NULL) && (pstVcBack->diff_serv_cfg_cb != NULL))
    {
        ret = spm_ds_add_vc_node(pstVcBack->diff_serv_cfg_cb->diff_serv_id,
            &stVcKeyBack,
            pstVcBack->vc_info_cb.vp_pos_id,
            pstVcBack->vc_info_cb.if_main);

        if (ret == SUCCESS)
        {
            pstVcBack->vc_info_cb.if_qos = ATG_DCI_USED;
        }
    }

EXIT_LABEL: NBB_TRC_EXIT();

    return ret;
}

#endif

#endif

